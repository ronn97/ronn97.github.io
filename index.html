<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--  bing搜索-->
  <meta name="msvalidate.01" content="C978CEE5B035402910AAC2FD1C19716D" />
  
  
  
  <meta name="description" content="个人博客">
  
  <title>
    
    没有梦想的程序员
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>


  
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4620209531301821" crossorigin="anonymous"></script>
  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="没有梦想的程序员" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">没有梦想的程序员</a></h1>
      <p>爱前端 | 爱挖坑 | 爱折腾 | 爱生活</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="没有梦想的程序员"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-hello-world" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/hello-world/">Hello World</a>
  </h2>
  
  
<div class="article-topping">
  <i class="fe fe-umbrella"></i>
</div>


    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/hello-world/" class="article-date">
  <time datetime="2023-09-05T02:37:07.278Z" itemprop="datePublished">2023-09-05</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><p>欢迎来到我的博客,将会在此记录一些有趣的事！</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/hello-world/" data-id="clm609r2h0003t4wldvym35p9" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-array" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-array/">TypeScript 的数组类型</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-array/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><p>JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple）。</p>
<p>本章介绍数组，下一章介绍元组。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。</p>
<p>数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>的类型是<code>number[]</code>，其中<code>number</code>表示数组成员类型是<code>number</code>。</p>
<p>如果数组成员的类型比较复杂，可以写在圆括号里面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:(<span class="built_in">number</span>|<span class="built_in">string</span>)[];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>的成员类型是<code>number|string</code>。</p>
<p>这个例子里面的圆括号是必须的，否则因为竖杠<code>|</code>的优先级低于<code>[]</code>，TypeScript 会把<code>number|string[]</code>理解成<code>number</code>和<code>string[]</code>的联合类型。</p>
<p>如果数组成员可以是任意类型，写成<code>any[]</code>。当然，这种写法是应该避免的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">any</span>[];</span><br></pre></td></tr></table></figure>

<p>数组类型的第二种写法是使用 TypeScript 内置的 Array 接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>的类型是<code>Array&lt;number&gt;</code>，其中<code>number</code>表示成员类型是<code>number</code>。</p>
<p>这种写法对于成员类型比较复杂的数组，代码可读性会稍微好一些。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>|<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这种写法本质上属于泛型，这里只要知道怎么写就可以了，详细解释参见《泛型》一章。另外，数组类型还有第三种写法，因为很少用到，本章就省略了，详见《interface 接口》一章。</p>
<p>数组类型声明了以后，成员数量是不限制的，任意数量的成员都可以，也可以是空数组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[];</span><br><span class="line">arr = [];</span><br><span class="line">arr = [<span class="number">1</span>];</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>无论有多少个成员，都是正确的。</p>
<p>这种规定的隐藏含义就是，数组的成员是可以动态变化的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">arr <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，数组增加成员或减少成员，都是可以的。</p>
<p>正是由于成员数量可以动态变化，所以  TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> foo = arr[<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>的值是一个不存在的数组成员，TypeScript 并不会报错。</p>
<p>TypeScript 允许使用方括号读取数组成员的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="number">0</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Names</code>是字符串数组，那么<code>Names[0]</code>返回的类型就是<code>string</code>。</p>
<p>由于数组成员的索引类型都是<code>number</code>，所以读取成员类型也可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="built_in">number</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Names[number]</code>表示数组<code>Names</code>所有数值索引的成员类型，所以返回<code>string</code>。</p>
<h2 id="数组的类型推断"><a href="#数组的类型推断" class="headerlink" title="数组的类型推断"></a>数组的类型推断</h2><p>如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。这时，推断行为会因为值的不同，而有所不同。</p>
<p>如果变量的初始值是空数组，那么  TypeScript 会推断数组类型是<code>any[]</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断为 any[]</span></span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br></pre></td></tr></table></figure>

<p>后面，为这个数组赋值时，TypeScript 会自动更新类型推断。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">arr <span class="comment">// 推断为 any[]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">123</span>);</span><br><span class="line">arr <span class="comment">// 推断类型为 number[]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr <span class="comment">// 推断类型为 (string|number)[]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，数组变量<code>arr</code>的初始值是空数组，然后随着新成员的加入，TypeScript 会自动修改推断的数组类型。</p>
<p>但是，类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断类型为 number[]</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">123</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，数组变量<code>arr</code>的初始值是<code>[123]</code>，TypeScript 就推断成员类型为<code>number</code>。新成员如果不是这个类型，TypeScript 就会报错，而不会更新类型推断。</p>
<h2 id="只读数组，const-断言"><a href="#只读数组，const-断言" class="headerlink" title="只读数组，const 断言"></a>只读数组，const 断言</h2><p>JavaScript 规定，<code>const</code>命令声明的数组变量是可以改变成员的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，修改<code>const</code>命令声明的数组的成员是允许的。</p>
<p>但是，很多时候确实有声明为只读数组的需求，即不允许变动数组成员。</p>
<p>TypeScript 允许声明只读数组，方法是在数组类型前面加上<code>readonly</code>关键字。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">3</span>); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>arr</code>是一个只读数组，删除、修改、新增数组成员都会报错。</p>
<p>TypeScript 将<code>readonly number[]</code>与<code>number[]</code>视为两种不一样的类型，后者是前者的子类型。</p>
<p>这是因为只读数组没有<code>pop()</code>、<code>push()</code>之类会改变原数组的方法，所以<code>number[]</code>的方法数量要多于<code>readonly number[]</code>，这意味着<code>number[]</code>其实是<code>readonly number[]</code>的子类型。</p>
<p>我们知道，子类型继承了父类型的所有特征，并加上了自己的特征，所以子类型<code>number[]</code>可以用于所有使用父类型的场合，反过来就不行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a1</span>:<span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = a1; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">a1 = a2; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，子类型<code>number[]</code>可以赋值给父类型<code>readonly number[]</code>，但是反过来就会报错。</p>
<p>由于只读数组是数组的父类型，所以它不能代替数组。这一点很容易产生令人困惑的报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">s:<span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSum</span>(arr) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>getSum()</code>的参数<code>s</code>是一个数组，传入只读数组就会报错。原因就是只读数组是数组的父类型，父类型不能替代子类型。这个问题的解决方法是使用类型断言<code>getSum(arr as number[])</code>，详见《类型断言》一章。</p>
<p>注意，<code>readonly</code>关键字不能与数组的泛型写法一起使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>readonly</code>与数组的泛型写法一起使用，就会报错。</p>
<p>实际上，TypeScript 提供了两个专门的泛型，用来生成只读数组的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a1</span>:<span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a2</span>:<span class="title class_">Readonly</span>&lt;<span class="built_in">number</span>[]&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，泛型<code>ReadonlyArray&lt;T&gt;</code>和<code>Readonly&lt;T[]&gt;</code>都可以用来生成只读数组类型。两者尖括号里面的写法不一样，<code>Readonly&lt;T[]&gt;</code>的尖括号里面是整个数组（<code>number[]</code>），而<code>ReadonlyArray&lt;T&gt;</code>的尖括号里面是数组成员（<code>number</code>）。</p>
<p>只读数组还有一种声明方法，就是使用“const 断言”。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = [<span class="number">2</span>]; <span class="comment">// 报错 </span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>as const</code>告诉 TypeScript，推断类型时要把变量<code>arr</code>推断为只读数组，从而使得数组成员无法改变。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>TypeScript 使用<code>T[][]</code>的形式，表示二维数组，<code>T</code>是最底层数组成员的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">multi</span>:<span class="built_in">number</span>[][] =</span><br><span class="line">  [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>]];</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>multi</code>的类型是<code>number[][]</code>，表示它是一个二维数组，最底层的数组成员类型是<code>number</code>。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-array/" data-id="clm609r2m0007t4wl5q5239bg" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-assert" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-assert/">TypeScript 的类型断言</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-assert/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于没有类型声明的值，TypeScript 会进行类型推断，很多时候得到的结果，未必是开发者想要的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错，原因是 TypeScript 推断变量<code>foo</code>的类型是<code>string</code>，而变量<code>bar</code>的类型是<code>&#39;a&#39;|&#39;b&#39;|&#39;c&#39;</code>，前者是后者的父类型。父类型不能赋值给子类型，所以就报错了。</p>
<p>TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。</p>
<p>这种做法的实质是，允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。</p>
<p>回到上面的例子，解决方法就是进行类型断言，在赋值时断言变量<code>foo</code>的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo <span class="keyword">as</span> T; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行的<code>foo as T</code>表示告诉编译器，变量<code>foo</code>的类型断言为<code>T</code>，所以这一行不再需要类型推断了，编译器直接把<code>foo</code>的类型当作<code>T</code>，就不会报错了。</p>
<p>总之，类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。</p>
<p>类型断言有两种语法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法一：&lt;类型&gt;值</span></span><br><span class="line">&lt;<span class="title class_">Type</span>&gt;value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法二：值 as 类型</span></span><br><span class="line">value <span class="keyword">as</span> <span class="title class_">Type</span></span><br></pre></td></tr></table></figure>

<p>上面两种语法是等价的，<code>value</code>表示值，<code>Type</code>表示类型。早期只有语法一，后来因为 TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突，就引入了语法二。目前，推荐使用语法二。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = &lt;T&gt;foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法二</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo <span class="keyword">as</span> T;</span><br></pre></td></tr></table></figure>

<p>上面示例是两种类型断言的语法，其中的语法一因为跟 JSX 语法冲突，使用时必须关闭 TypeScript 的 React 支持，否则会无法识别。由于这个原因，现在一般都使用语法二。</p>
<p>下面看一个例子。《对象》一章提到过，对象类型有严格字面量检查，如果存在额外的属性会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，等号右侧是一个对象字面量，多出了属性<code>y</code>，导致报错。解决方法就是使用类型断言，可以用两种不同的断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p0</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; =</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; =</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种类型断言都是正确的。第一种断言将类型改成与等号左边一致，第二种断言使得等号右边的类型是左边类型的子类型，子类型可以赋值给父类型，同时因为存在类型断言，就没有严格字面量检查了，所以不报错。</p>
<p>下面是一个网页编程的实际例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username) &#123;</span><br><span class="line">  (username <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>).<span class="property">value</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>username</code>的类型是<code>HTMLElement | null</code>，排除了<code>null</code>的情况以后，HTMLElement 类型是没有<code>value</code>属性的。如果<code>username</code>是一个输入框，那么就可以通过类型断言，将它的类型改成<code>HTMLInputElement</code>，就可以读取<code>value</code>属性。</p>
<p>注意，上例的类型断言的圆括号是必需的，否则<code>username</code>会被断言成<code>HTMLInputElement.value</code>，从而报错。</p>
<p>类型断言不应滥用，因为它改变了 TypeScript 的类型检查，很可能埋下错误的隐患。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">data</span>:<span class="built_in">object</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">data.<span class="property">length</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">(data <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;).<span class="property">length</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>data</code>是一个对象，没有<code>length</code>属性。但是通过类型断言，可以将它的类型断言为数组，这样使用<code>length</code>属性就能通过类型检查。但是，编译后的代码在运行时依然会报错，所以类型断言可以让错误的代码通过编译。</p>
<p>类型断言的一大用处是，指定 unknown 类型的变量的具体类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">value</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="built_in">string</span> = value; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="built_in">string</span> = value <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，unknown 类型的变量<code>value</code>不能直接赋值给其他类型的变量，但是可以将它断言为其他类型，这样就可以赋值给别的变量了。</p>
<p>另外，类型断言也适合指定联合类型的值的具体类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="built_in">number</span>|<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="built_in">number</span> = s1 <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s1</code>是联合类型，可以断言其为联合类型里面的一种具体类型，再将其赋值给变量<code>s2</code>。</p>
<h2 id="类型断言的条件"><a href="#类型断言的条件" class="headerlink" title="类型断言的条件"></a>类型断言的条件</h2><p>类型断言并不意味着，可以把某个值断言为任意类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>n</code>是数值，无法把它断言成字符串，TypeScript 会报错。</p>
<p>类型断言的使用前提是，值的实际类型与断言的类型必须满足一个条件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr <span class="keyword">as</span> T</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>expr</code>是实际的值，<code>T</code>是类型断言，它们必须满足下面的条件：<code>expr</code>是<code>T</code>的子类型，或者<code>T</code>是<code>expr</code>的子类型。</p>
<p>也就是说，类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。</p>
<p>但是，如果真的要断言成一个完全无关的类型，也是可以做到的。那就是连续进行两次类型断言，先断言成 unknown 类型或 any 类型，然后再断言为目标类型。因为<code>any</code>类型和<code>unknown</code>类型是所有其他类型的父类型，所以可以作为两种完全无关的类型的中介。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者写成 &lt;T&gt;&lt;unknown&gt;expr</span></span><br><span class="line">expr <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> T</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>expr</code>连续进行了两次类型断言，第一次断言为<code>unknown</code>类型，第二次断言为<code>T</code>类型。这样的话，<code>expr</code>就可以断言成任意类型<code>T</code>，而不报错。</p>
<p>下面是本小节开头那个例子的改写。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，通过两次类型断言，变量<code>n</code>的类型就从数值，变成了完全无关的字符串，从而赋值时不会报错。</p>
<h2 id="as-const-断言"><a href="#as-const-断言" class="headerlink" title="as const 断言"></a>as const 断言</h2><p>如果没有声明变量类型，let 命令声明的变量，会被类型推断为 TypeScript 内置的基本类型之一；const 命令声明的变量，则被推断为值类型常量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型推断为基本类型 string</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断为字符串 “JavaScript”</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s1</code>的类型被推断为<code>string</code>，变量<code>s2</code>的类型推断为值类型<code>JavaScript</code>。后者是前者的子类型，相当于 const 命令有更强的限定作用，可以缩小变量的类型范围。</p>
<p>有些时候，let 变量会出现一些意想不到的报错，变更成 const 变量就能消除报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> =</span><br><span class="line">  |<span class="string">&#x27;JavaScript&#x27;</span></span><br><span class="line">  |<span class="string">&#x27;TypeScript&#x27;</span></span><br><span class="line">  |<span class="string">&#x27;Python&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setLang</span>(<span class="params">language:Lang</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setLang</span>(s); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错，原因是函数<code>setLang()</code>的参数<code>language</code>类型是<code>Lang</code>，这是一个联合类型。但是，传入的字符串<code>s</code>的类型被推断为<code>string</code>，属于<code>Lang</code>的父类型。父类型不能替代子类型，导致报错。</p>
<p>一种解决方法就是把 let 命令改成 const 命令。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这样的话，变量<code>s</code>的类型就是值类型<code>JavaScript</code>，它是联合类型<code>Lang</code>的子类型，传入函数<code>setLang()</code>就不会报错。</p>
<p>另一种解决方法是使用类型断言。TypeScript 提供了一种特殊的类型断言<code>as const</code>，用于告诉编译器，推断类型时，可以将这个值推断为常量，即把 let 变量断言为 const 变量，从而把内置的基本类型变更为值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="title function_">setLang</span>(s);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s</code>虽然是用 let 命令声明的，但是使用了<code>as const</code>断言以后，就等同于是用 const 命令声明的，变量<code>s</code>的类型会被推断为值类型<code>JavaScript</code>。</p>
<p>使用了<code>as const</code>断言以后，let 变量就不能再改变值了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">s = <span class="string">&#x27;Python&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，let 命令声明的变量<code>s</code>，使用<code>as const</code>断言以后，就不能改变值了，否则报错。</p>
<p>注意，<code>as const</code>断言只能用于字面量，不能用于变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="title function_">setLang</span>(s <span class="keyword">as</span> <span class="keyword">const</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>as const</code>断言用于变量<code>s</code>，就报错了。下面的写法可以更清晰地看出这一点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1 <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>as const</code>也不能用于表达式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = (<span class="string">&#x27;Java&#x27;</span> + <span class="string">&#x27;Script&#x27;</span>) <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>as const</code>用于表达式，导致报错。</p>
<p><code>as const</code>也可以写成前置的形式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置形式</span></span><br><span class="line">expr <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置形式</span></span><br><span class="line">&lt;<span class="keyword">const</span>&gt;expr</span><br></pre></td></tr></table></figure>

<p><code>as const</code>断言可以用于整个对象，也可以用于对象的单个属性，这时它的类型缩小效果是不一样的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: number; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: 1; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型是 &#123; readonly x: 1; readonly y: 2; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第二种写法是对属性<code>x</code>缩小类型，第三种写法是对整个对象缩小类型。</p>
<p>总之，<code>as const</code>会将字面量的类型断言为不可变类型，缩小成 TypeScript 允许的最小类型。</p>
<p>下面是数组的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 的类型推断为 number[]</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a2 的类型推断为 readonly [1, 2, 3]</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组字面量使用<code>as const</code>断言后，类型推断就变成了只读元组。</p>
<p>由于<code>as const</code>会将数组变成只读元组，所以很适合用于函数的 rest 参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>nums</code>的类型推断为<code>number[]</code>，导致使用扩展运算符<code>...</code>传入函数<code>add()</code>会报错，因为<code>add()</code>只能接受两个参数，而<code>...nums</code>并不能保证参数的个数。</p>
<p>事实上，对于固定参数个数的函数，如果传入的参数包含扩展运算符，那么扩展运算符只能用于元组。只有当函数定义使用了 rest 参数，扩展运算符才能用于数组。</p>
<p>解决方法就是使用<code>as const</code>断言，将数组变成元组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，使用<code>as const</code>断言后，变量<code>nums</code>的类型会被推断为<code>readonly [1, 2]</code>，使用扩展运算符展开后，正好符合函数<code>add()</code>的参数类型。</p>
<p>Enum 成员也可以使用<code>as const</code>断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  X,</span><br><span class="line">  Y,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> e1 = <span class="title class_">Foo</span>.<span class="property">X</span>;            <span class="comment">// Foo</span></span><br><span class="line"><span class="keyword">let</span> e2 = <span class="title class_">Foo</span>.<span class="property">X</span> <span class="keyword">as</span> <span class="keyword">const</span>;   <span class="comment">// Foo.X</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，如果不使用<code>as const</code>断言，变量<code>e1</code>的类型被推断为整个 Enum 类型；使用了<code>as const</code>断言以后，变量<code>e2</code>的类型被推断为 Enum 的某个成员，这意味着它不能变更为其他成员。</p>
<h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><p>对于那些可能为空的变量（即可能等于<code>undefined</code>或<code>null</code>），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号<code>!</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?:<span class="built_in">number</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="title function_">validateNumber</span>(x); <span class="comment">// 自定义函数，确保 x 是数值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x!.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateNumber</span>(<span class="params">e?:<span class="built_in">number</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> e !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>的参数<code>x</code>的类型是<code>number|null</code>，即可能为空。如果为空，就不存在<code>x.toFixed()</code>方法，这样写会报错。但是，开发者可以确认，经过<code>validateNumber()</code>的前置检验，变量<code>x</code>肯定不会为空，这时就可以使用非空断言，为函数体内部的变量<code>x</code>加上后缀<code>!</code>，<code>x!.toFixed()</code>编译就不会报错了。</p>
<p>非空断言在实际编程中很有用，有时可以省去一些额外的判断。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getElementById()</code>有可能返回空值<code>null</code>，即变量<code>root</code>可能为空，这时对它调用<code>addEventListener()</code>方法就会报错，通不过编译。但是，开发者如果可以确认<code>root</code>元素肯定会在网页中存在，这时就可以使用非空断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getElementById()</code>方法加上后缀<code>!</code>，表示这个方法肯定返回非空结果。</p>
<p>不过，非空断言会造成安全隐患，只有在确定一个表达式的值不为空时才能使用。比较保险的做法还是手动检查一下是否为空。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unable to find DOM element #root&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果<code>root</code>为空会抛错，比非空断言更保险一点。</p>
<p>非空断言还可以用于赋值断言。TypeScript 有一个编译设置，要求类的属性必须初始化（即有初始值），如果不对属性赋值就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>和<code>y</code>会报错，因为 TypeScript 认为它们没有初始化。</p>
<p>这时就可以使用非空断言，表示这两个属性肯定会有值，这样就不会报错了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!:<span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line">  y!:<span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，非空断言只有在打开编译选项<code>strictNullChecks</code>时才有意义。如果不打开这个选项，编译器就不会检查某个变量是否可能为<code>undefined</code>或<code>null</code>。</p>
<h2 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h2><p>断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isString()</code>就是一个断言函数，用来保证参数<code>value</code>是一个字符串，否则就会抛出错误，中断程序的执行。</p>
<p>下面是它的用法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toUpper</span>(<span class="params">x: <span class="built_in">string</span>|<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="title function_">isString</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>toUpper()</code>的参数<code>x</code>，可能是字符串，也可能是数值。但是，函数体的最后一行调用<code>toUpperCase()</code>方法，必须保证<code>x</code>是字符串，否则报错。所以，这一行前面调用断言函数<code>isString()</code>，调用以后 TypeScript 就能确定，变量<code>x</code>一定是字符串，不是数值，也就不报错了。</p>
<p>传统的断言函数<code>isString()</code>的写法有一个缺点，它的参数类型是<code>unknown</code>，返回值类型是<code>void</code>（即没有返回值）。单单从这样的类型声明，很难看出<code>isString()</code>是一个断言函数。</p>
<p>为了更清晰地表达断言函数，TypeScript 3.7 引入了新的类型写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isString()</code>的返回值类型写成<code>asserts value is string</code>，其中<code>asserts</code>和<code>is</code>都是关键词，<code>value</code>是函数的参数名，<code>string</code>是函数参数的预期类型。它的意思是，该函数用来断言参数<code>value</code>的类型是<code>string</code>，如果达不到要求，程序就会在这里中断。</p>
<p>使用了断言函数的新写法以后，TypeScript 就会自动识别，只要执行了该函数，对应的变量都为断言的类型。</p>
<p>注意，函数返回值的断言写法，只是用来更清晰地表达函数意图，真正的检查是需要开发者自己部署的。而且，如果内部的检查与断言不一致，TypeScript 也不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数的断言是参数<code>value</code>类型为字符串，但是实际上，内部检查的却是它是否为数值，如果不是就抛错。这段代码能够正常通过编译，表示 TypeScript 并不会检查断言与实际的类型检查是否一致。</p>
<p>另外，断言函数的<code>asserts</code>语句等同于<code>void</code>类型，所以如果返回除了<code>undefined</code>和<code>null</code>以外的值，都会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，断言函数返回了<code>true</code>，导致报错。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AccessLevel</span> = <span class="string">&#x27;r&#x27;</span> | <span class="string">&#x27;w&#x27;</span> | <span class="string">&#x27;rw&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">allowsReadAccess</span>(<span class="params"></span></span><br><span class="line"><span class="params">  level:AccessLevel</span></span><br><span class="line"><span class="params"></span>):asserts level is <span class="string">&#x27;r&#x27;</span> | <span class="string">&#x27;rw&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!level.<span class="title function_">includes</span>(<span class="string">&#x27;r&#x27;</span>))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Read not allowed&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>allowsReadAccess()</code>用来断言参数<code>level</code>一定等于<code>r</code>或<code>rw</code>。</p>
<p>如果要断言参数非空，可以使用工具类型<code>NonNullable&lt;T&gt;</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> assertIsDefined&lt;T&gt;(</span><br><span class="line">  <span class="attr">value</span>:T</span><br><span class="line">):asserts value is <span class="title class_">NonNullable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span> || value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not defined`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，工具类型<code>NonNullable&lt;T&gt;</code>对应类型<code>T</code>去除空类型后的剩余类型。</p>
<p>如果要将断言函数用于函数表达式，可以采用下面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> assertIsNumber = (</span><br><span class="line">  <span class="attr">value</span>:<span class="built_in">unknown</span></span><br><span class="line">):asserts value is <span class="built_in">number</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AssertIsNumber</span> =</span><br><span class="line">  <span class="function">(<span class="params">value:<span class="built_in">unknown</span></span>) =&gt;</span> asserts value is <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">assertIsNumber</span>:<span class="title class_">AssertIsNumber</span> = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，断言函数与类型保护函数（type guard）是两种不同的函数。它们的区别是，断言函数不返回值，而类型保护函数总是返回一个布尔值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">unknown</span></span></span><br><span class="line"><span class="params"></span>):value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例就是一个类型保护函数<code>isString()</code>，作用是检查参数<code>value</code>是否为字符串。如果是的，返回<code>true</code>，否则返回<code>false</code>。该函数的返回值类型是<code>value is string</code>，其中的<code>is</code>是一个类型运算符，如果左侧的值符合右侧的类型，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p>如果要断言某个参数保证为真（即不等于<code>false</code>、<code>undefined</code>和<code>null</code>），TypeScript 提供了断言函数的一种简写形式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">x:<span class="built_in">unknown</span></span>):asserts x &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>assert()</code>的断言部分，<code>asserts x</code>省略了谓语和宾语，表示参数<code>x</code>保证为真（<code>true</code>）。</p>
<p>同样的，参数为真的实际检查需要开发者自己实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">x:<span class="built_in">unknown</span></span>):asserts x &#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;x&#125;</span> should be a truthy value.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种断言函数的简写形式，通常用来检查某个操作是否成功。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  email?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadPerson</span>(<span class="params"></span>): <span class="title class_">Person</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">loadPerson</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params"></span></span><br><span class="line"><span class="params">  condition: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  message: <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):asserts condition &#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Person is not defined</span></span><br><span class="line"><span class="title function_">assert</span>(person, <span class="string">&#x27;Person is not defined&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，只有<code>loadPerson()</code>返回结果为真（即操作成功），<code>assert()</code>才不会报错。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mariusschulz.com/blog/const-assertions-in-literal-expressions-in-typescript">Const Assertions in Literal Expressions in TypeScript</a>, Marius Schulz</li>
<li><a target="_blank" rel="noopener" href="https://mariusschulz.com/blog/assertion-functions-in-typescript">Assertion Functions in TypeScript</a>, Marius Schulz</li>
<li><a target="_blank" rel="noopener" href="https://blog.logrocket.com/assertion-functions-typescript/">Assertion functions in TypeScript</a>, Matteo Di Pirro</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-assert/" data-id="clm609r2o0009t4wl3vqf70nx" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-any" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-any/">any 类型，unknown 类型，never 类型</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-any/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><p>本章介绍 TypeScript 的三种特殊类型，它们可以作为学习 TypeScript 类型系统的起点。</p>
<h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><h3 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h3><p>any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>any</code>，就可以被赋值为任意类型的值。</p>
<p>变量类型一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>) <span class="comment">// 不报错</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="number">100</span>; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的值是一个字符串，但是把它当作函数调用，或者当作对象读取任意属性，TypeScript 编译时都不报错。原因就是<code>x</code>的类型是<code>any</code>，TypeScript 不对其进行类型检查。</p>
<p>由于这个原因，应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义。</p>
<p>实际开发中，<code>any</code>类型主要适用以下两个场合。</p>
<p>（1）出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为<code>any</code>。</p>
<p>（2）为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为<code>any</code>。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，这时你为那些类型复杂的变量加上<code>any</code>，TypeScript 编译时就不会报错。</p>
<p>总之，TypeScript 认为，只要开发者使用了<code>any</code>类型，就表示开发者想要自己来处理这些代码，所以就不对<code>any</code>类型进行任何限制，怎么使用都可以。</p>
<p>从集合论的角度看，<code>any</code>类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。</p>
<h3 id="类型推断问题"><a href="#类型推断问题" class="headerlink" title="类型推断问题"></a>类型推断问题</h3><p>对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>add()</code>的参数变量<code>x</code>和<code>y</code>，都没有足够的信息，TypeScript 无法推断出它们的类型，就会认为这两个变量和函数返回值的类型都是<code>any</code>。以至于后面就不再对函数<code>add()</code>进行类型检查了，怎么用都可以。</p>
<p>这显然是很糟糕的情况，所以对于那些类型不明显的变量，一定要显式声明类型，防止被推断为<code>any</code>。</p>
<p>TypeScript 提供了一个编译选项<code>noImplicitAny</code>，打开该选项，只要推断出<code>any</code>类型就会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --noImplicitAny app.ts</span><br></pre></td></tr></table></figure>

<p>上面命令使用了<code>noImplicitAny</code>编译选项进行编译，这时上面的函数<code>add()</code>就会报错。</p>
<p>这里有一个特殊情况，即使打开了<code>noImplicitAny</code>，使用<code>let</code>和<code>var</code>命令声明变量，但不赋值也不指定类型，是不会报错的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> y; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>和<code>y</code>声明时没有赋值，也没有指定类型，TypeScript 会推断它们的类型为<code>any</code>。这时即使打开了<code>noImplicitAny</code>，也不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line">x = &#123; <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型推断为<code>any</code>，但是不报错，可以顺利通过编译。</p>
<p>由于这个原因，建议使用<code>let</code>和<code>var</code>声明变量时，如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。</p>
<p><code>const</code>命令没有这个问题，因为 JavaScript 语言规定<code>const</code>声明变量时，必须同时进行初始化（赋值）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>const</code>命令声明的<code>x</code>是不能改变值的，声明时必须同时赋值，否则报错，所以它不存在类型推断为<code>any</code>的问题。</p>
<h3 id="污染问题"><a href="#污染问题" class="headerlink" title="污染问题"></a>污染问题</h3><p><code>any</code>类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 不报错</span></span><br><span class="line"></span><br><span class="line">y * <span class="number">123</span> <span class="comment">// 不报错</span></span><br><span class="line">y.<span class="title function_">toFixed</span>() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>any</code>，实际的值是一个字符串。变量<code>y</code>的类型是<code>number</code>，表示这是一个数值变量，但是它被赋值为<code>x</code>，这时并不会报错。然后，变量<code>y</code>继续进行各种数值运算，TypeScript 也检查不出错误，问题就这样留到运行时才会暴露。</p>
<p>污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用<code>any</code>类型的另一个主要原因。</p>
<h2 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a>unknown 类型</h2><p>为了解决<code>any</code>类型“污染”其他变量的问题，TypeScript 3.0 引入了<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type"><code>unknown</code>类型</a>。它与<code>any</code>含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像<code>any</code>那样自由，可以视为严格版的<code>any</code>。</p>
<p><code>unknown</code>跟<code>any</code>的相似之处，在于所有类型的值都可以分配给<code>unknown</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="number">42</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;Hello World&#x27;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>unknown</code>，可以赋值为各种类型的值。这与<code>any</code>的行为一致。</p>
<p><code>unknown</code>类型跟<code>any</code>类型的不同之处在于，它不能直接使用。主要有以下几个限制。</p>
<p>首先，<code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>:<span class="built_in">unknown</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">boolean</span> = v; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">number</span> = v; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>v</code>是<code>unknown</code>类型，赋值给<code>any</code>和<code>unknown</code>以外类型的变量都会报错，这就避免了污染问题，从而克服了<code>any</code>类型的一大缺点。</p>
<p>其次，不能直接调用<code>unknown</code>类型变量的方法和属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">unknown</span> = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">v1.<span class="property">foo</span>  <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">v2.<span class="title function_">trim</span>() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>:<span class="built_in">unknown</span> = <span class="function">(<span class="params">n = <span class="number">0</span></span>) =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="title function_">v3</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，直接调用<code>unknown</code>类型变量的属性和方法，或者直接当作函数执行，都会报错。</p>
<p>再次，<code>unknown</code>类型变量能够进行的运算是有限的，只能进行比较运算（运算符<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>）、取反运算（运算符<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符这几种，其他运算都会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a + <span class="number">1</span> <span class="comment">// 报错</span></span><br><span class="line">a === <span class="number">1</span> <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>unknown</code>类型的变量<code>a</code>进行加法运算会报错，因为这是不允许的运算。但是，进行比较运算就是可以的。</p>
<p>那么，怎么才能使用<code>unknown</code>类型变量呢？</p>
<p>答案是只有经过“类型缩小”，<code>unknown</code>类型变量才可以使用。所谓“类型缩小”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> r = a + <span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>unknown</code>类型的变量<code>a</code>经过<code>typeof</code>运算以后，能够确定实际类型是<code>number</code>，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">s</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> s === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  s.<span class="property">length</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，确定变量<code>s</code>的类型为字符串以后，才能调用它的<code>length</code>属性。</p>
<p>这样设计的目的是，只有明确<code>unknown</code>变量的实际类型，才允许使用它，防止像<code>any</code>那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。</p>
<p>总之，<code>unknown</code>可以看作是更安全的<code>any</code>。一般来说，凡是需要设为<code>any</code>类型的地方，通常都应该优先考虑设为<code>unknown</code>类型。</p>
<p>在集合论上，<code>unknown</code>也可以视为所有其他类型（除了<code>any</code>）的全集，所以它和<code>any</code>一样，也属于 TypeScript 的顶层类型。</p>
<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><p>为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了“空类型”的概念，即该类型为空，不包含任何值。</p>
<p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>never</code>，就不可能赋给它任何值，否则都会报错。</p>
<p><code>never</code>类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性，详见后面章节。另外，不可能返回值的函数，返回值的类型就可以写成<code>never</code>，详见《函数》一章。</p>
<p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span>|<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x; <span class="comment">// never 类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数变量<code>x</code>可能是字符串，也可能是数值，判断了这两种情况后，剩下的最后那个<code>else</code>分支里面，<code>x</code>就是<code>never</code>类型了。</p>
<p><code>never</code>类型的一个重要特点是，可以赋值给任意其他类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">number</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">string</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>:<span class="built_in">boolean</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>会抛出错误，所以返回值类型可以写成<code>never</code>，即不可能返回任何值。各种其他类型的变量都可以赋值为<code>f()</code>的运行结果（<code>never</code>类型）。</p>
<p>为什么<code>never</code>类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了<code>never</code>类型。因此，<code>never</code>类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottom type）。</p>
<p>总之，TypeScript 有两个“顶层类型”（<code>any</code>和<code>unknown</code>），但是“底层类型”只有<code>never</code>唯一一个。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-any/" data-id="clm609r2q000bt4wl2su09a90" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-basic" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-basic/">TypeScript 基本用法</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-basic/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><p>本章介绍 TypeScript 的一些最基本的语法和用法。</p>
<h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><p>TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>的后面使用冒号，声明了它的类型为<code>string</code>。</p>
<p>类型声明的写法，一律为在标识符后面添加“冒号 + 类型”。函数参数和返回值，也是这样来声明类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num:<span class="built_in">number</span></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>toString()</code>的参数<code>num</code>的类型是<code>number</code>。参数列表的圆括号后面，声明了返回值的类型是<code>string</code>。更详细的介绍，参见《函数》一章。</p>
<p>注意，变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">string</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>的类型是字符串，但是赋值为数值<code>123</code>，TypeScript 就报错了。</p>
<p>另外，TypeScript 规定，变量只有赋值后才能使用，否则就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>没有赋值就被读取，导致报错。而 JavaScript 允许这种行为，不会报错，没有赋值的变量会返回<code>undefined</code>。</p>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>并没有类型声明，TypeScript 就会推断它的类型。由于它被赋值为一个数值，因此 TypeScript 推断它的类型为<code>number</code>。</p>
<p>后面，如果变量<code>foo</code>更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br><span class="line">foo = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>的类型推断为<code>number</code>，后面赋值为字符串，TypeScript 就报错了。</p>
<p>TypeScript 也可以推断函数的返回值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>toString()</code>没有声明返回值的类型，但是 TypeScript 推断返回的是字符串。正是因为 TypeScript 的类型推断，所以函数返回值的类型通常是省略不写的。</p>
<p>从这里可以看到，TypeScript 的设计思想是，类型声明是可选的，你可以加，也可以不加。即使不加类型声明，依然是有效的 TypeScript 代码，只是这时不能保证 TypeScript 会正确推断出类型。由于这个原因，所有 JavaScript 代码都是合法的 TypeScript 代码。</p>
<p>这样设计还有一个好处，将以前的 JavaScript 项目改为 TypeScript 项目时，你可以逐步地为老代码添加类型，即使有些代码没有添加，也不会无法运行。</p>
<h2 id="TypeScript-的编译"><a href="#TypeScript-的编译" class="headerlink" title="TypeScript 的编译"></a>TypeScript 的编译</h2><p>JavaScript 的运行环境（浏览器和 Node.js）不认识 TypeScript 代码。所以，TypeScript 项目要想运行，必须先转为 JavaScript 代码，这个代码转换的过程就叫做“编译”（compile）。</p>
<p>TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p>
<p>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p>
<h2 id="值与类型"><a href="#值与类型" class="headerlink" title="值与类型"></a>值与类型</h2><p>学习 TypeScript 需要分清楚“值”（value）和“类型”（type）。</p>
<p>“类型”是针对“值”的，可以视为是后者的一个元属性。每一个值在 TypeScript 里面都是有类型的。比如，<code>3</code>是一个值，它的类型是<code>number</code>。</p>
<p>TypeScript 代码只涉及类型，不涉及值。所有跟“值”相关的处理，都由 JavaScript 完成。</p>
<p>这一点务必牢记。TypeScript 项目里面，其实存在两种代码，一种是底层的“值代码”，另一种是上层的“类型代码”。前者使用 JavaScript 语法，后者使用 TypeScript 的类型语法。</p>
<p>它们是可以分离的，TypeScript 的编译过程，实际上就是把“类型代码”全部拿掉，只保留“值代码”。</p>
<p>编写 TypeScript 项目时，不要混淆哪些是值代码，哪些是类型代码。</p>
<h2 id="TypeScript-Playground"><a href="#TypeScript-Playground" class="headerlink" title="TypeScript Playground"></a>TypeScript Playground</h2><p>最简单的 TypeScript 使用方法，就是使用官网的在线编译页面，叫做 <a target="_blank" rel="noopener" href="http://www.typescriptlang.org/play/">TypeScript Playground</a>。</p>
<p>只要打开这个网页，把 TypeScript 代码贴进文本框，它就会在当前页面自动编译出 JavaScript 代码，还可以在浏览器执行编译产物。如果编译报错，它也会给出详细的报错信息。</p>
<p>这个页面还具有支持完整的 IDE 支持，可以自动语法提示。此外，它支持把代码片段和编译器设置保存成 URL，分享给他人。</p>
<p>本书的示例都建议放到这个页面，进行查看和编译。</p>
<h2 id="tsc-编译器"><a href="#tsc-编译器" class="headerlink" title="tsc 编译器"></a>tsc 编译器</h2><p>TypeScript 官方提供的编译器叫做 tsc，可以将 TypeScript 脚本编译成 JavaScript 脚本。本机想要编译 TypeScript 代码，必须安装 tsc。</p>
<p>根据约定，TypeScript 脚本文件使用<code>.ts</code>后缀名，JavaScript 脚本文件使用<code>.js</code>后缀名。tsc 的作用就是把<code>.ts</code>脚本转变成<code>.js</code>脚本。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>tsc 是一个 npm 模块，使用下面的命令安装（必须先安装 npm）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g typescript</span><br></pre></td></tr></table></figure>

<p>上面命令是全局安装 tsc，也可以在项目中将 tsc 安装为一个依赖模块。</p>
<p>安装完成后，检查一下是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者 tsc --version</span></span><br><span class="line">$ tsc -v</span><br><span class="line">Version 5.1.6</span><br></pre></td></tr></table></figure>

<p>上面命令中，<code>-v</code>或<code>--version</code>参数可以输出当前安装的 tsc 版本。</p>
<h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><p><code>-h</code>或<code>--help</code>参数输出帮助信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc -h</span><br></pre></td></tr></table></figure>

<p>默认情况下，“–help”参数仅显示基本的可用选项。我们可以使用“–all”参数，查看完整的帮助信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --all</span><br></pre></td></tr></table></figure>

<h3 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h3><p>安装 tsc 之后，就可以编译 TypeScript 脚本了。</p>
<p><code>tsc</code>命令后面，加上 TypeScript 脚本文件，就可以将其编译成 JavaScript 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc app.ts</span><br></pre></td></tr></table></figure>

<p>上面命令会在当前目录下，生成一个<code>app.js</code>脚本文件，这个脚本就完全是编译后生成的 JavaScript 代码。</p>
<p><code>tsc</code>命令也可以一次编译多个 TypeScript 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc file1.ts file2.ts file3.ts</span><br></pre></td></tr></table></figure>

<p>上面命令会在当前目录生成三个 JavaScript 脚本文件<code>file1.js</code>、<code>file2.js</code>、<code>file3.js</code>。</p>
<p>tsc 有很多参数，可以调整编译行为。</p>
<p><strong>（1）–outFile</strong></p>
<p>如果想将多个 TypeScript 脚本编译成一个 JavaScript 文件，使用<code>--outFile</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc file1.ts file2.ts --outFile app.js</span><br></pre></td></tr></table></figure>

<p>上面命令将<code>file1.ts</code>和<code>file2.ts</code>两个脚本编译成一个 JavaScript 文件<code>app.js</code>。</p>
<p><strong>（2）–outDir</strong></p>
<p>编译结果默认都保存在当前目录，<code>--outDir</code>参数可以指定保存到其他目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc app.ts --outDir dist</span><br></pre></td></tr></table></figure>

<p>上面命令会在<code>dist</code>子目录下生成<code>app.js</code>。</p>
<p><strong>（3）–target</strong></p>
<p>为了保证编译结果能在各种 JavaScript 引擎运行，tsc 默认会将 TypeScript 代码编译成很低版本的 JavaScript，即3.0版本（以<code>es3</code>表示）。这通常不是我们想要的结果。</p>
<p>这时可以使用<code>--target</code>参数，指定编译后的 JavaScript 版本。建议使用<code>es2015</code>，或者更新版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --target es2015 app.ts</span><br></pre></td></tr></table></figure>

<h3 id="编译错误的处理"><a href="#编译错误的处理" class="headerlink" title="编译错误的处理"></a>编译错误的处理</h3><p>编译过程中，如果没有报错，<code>tsc</code>命令不会有任何显示。所以，如果你没有看到任何提示，就表示编译成功了。</p>
<p>如果编译报错，<code>tsc</code>命令就会显示报错信息，但是这种情况下，依然会编译生成 JavaScript 脚本。</p>
<p>举例来说，下面是一个错误的 TypeScript 脚本<code>app.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line">foo = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>是数值类型，赋值为字符串，<code>tsc</code>命令编译这个脚本就会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tsc app.ts</span><br><span class="line"></span><br><span class="line">app.ts:2:1 - error TS2322: Type <span class="string">&#x27;string&#x27;</span> is not assignable to <span class="built_in">type</span> <span class="string">&#x27;number&#x27;</span>.</span><br><span class="line"></span><br><span class="line">2 foo = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">Found 1 error <span class="keyword">in</span> app.ts:2</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>tsc</code>命令输出报错信息，表示变量<code>foo</code>被错误地赋值为字符串。</p>
<p>这种情况下，编译产物<code>app.js</code>还是会照样生成，下面就是编译后的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">123</span>;</span><br><span class="line">foo = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，尽管有错，tsc 依然原样将 TypeScript 编译成 JavaScript 脚本。</p>
<p>这是因为 TypeScript 团队认为，编译器的作用只是给出编译错误，至于怎么处理这些错误，那就是开发者自己的判断了。开发者更了解自己的代码，所以不管怎样，编译产物都会生成，让开发者决定下一步怎么处理。</p>
<p>如果希望一旦报错就停止编译，不生成编译产物，可以使用<code>--noEmitOnError</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --noEmitOnError app.ts</span><br></pre></td></tr></table></figure>

<p>上面命令在报错后，就不会生成<code>app.js</code>。</p>
<p>tsc 还有一个<code>--noEmit</code>参数，只检查类型是否正确，不生成 JavaScript 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --noEmit app.ts</span><br></pre></td></tr></table></figure>

<p>上面命令只检查是否有编译错误，不会生成<code>app.js</code>。</p>
<p>tsc 命令的更多参数，详见《tsc 编译器》一章。</p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>TypeScript 允许将<code>tsc</code>的编译参数，写在配置文件<code>tsconfig.json</code>。只要当前目录有这个文件，<code>tsc</code>就会自动读取，所以运行时可以不写参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc file1.ts file2.ts --outFile dist/app.js</span><br></pre></td></tr></table></figure>

<p>上面这个命令写成<code>tsconfig.json</code>，就是下面这样。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;file1.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;file2.ts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/app.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>有了这个配置文件，编译时直接调用<code>tsc</code>命令就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc</span><br></pre></td></tr></table></figure>

<p><code>tsconfig.json</code>的详细介绍，参见《tsconfig.json 配置文件》一章。</p>
<h2 id="ts-node-模块"><a href="#ts-node-模块" class="headerlink" title="ts-node 模块"></a>ts-node 模块</h2><p><a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node">ts-node</a> 是一个非官方的 npm 模块，可以直接运行 TypeScript 代码。</p>
<p>使用时，可以先全局安装它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g ts-node</span><br></pre></td></tr></table></figure>

<p>安装后，就可以直接运行 TypeScript 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ts-node script.ts</span><br></pre></td></tr></table></figure>

<p>上面命令运行了 TypeScript 脚本<code>script.ts</code>，给出运行结果。</p>
<p>如果不安装 ts-node，也可以通过 npx 调用它来运行 TypeScript 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx ts-node script.ts</span><br></pre></td></tr></table></figure>

<p>上面命令中，<code>npx</code>会在线调用 ts-node，从而在不安装的情况下，运行<code>script.ts</code>。</p>
<p>如果执行 ts-node 命令不带有任何参数，它会提供一个 TypeScript 的命令行 REPL 运行环境，你可以在这个环境中输入 TypeScript 代码，逐行执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ts-node</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>上面示例中，单独运行<code>ts-node</code>命令，会给出一个大于号，这就是 TypeScript 的 REPL 运行环境，可以逐行输入代码运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ts-node</span><br><span class="line">&gt; const twice = (x:string) =&gt; x + x;</span><br><span class="line">&gt; twice(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span></span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>上面示例中，在 TypeScript 命令行 REPL 环境中，先输入一个函数<code>twice</code>，然后调用该函数，就会得到结果。</p>
<p>要退出这个 REPL 环境，可以按下 Ctrl + d，或者输入<code>.exit</code>。</p>
<p>如果只是想简单运行 TypeScript 代码看看结果，ts-node 不失为一个便捷的方法。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-basic/" data-id="clm609r2s000dt4wl2riybzuv" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-class" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-class/">TypeScript 的 class 类型</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-class/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>类（class）是面向对象编程的基本构件，封装了属性和方法，TypeScript 给予了全面支持。</p>
<h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>类的属性可以在顶层声明，也可以在构造方法内部声明。</p>
<p>对于顶层声明的属性，可以在声明时同时给出类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面声明中，属性<code>x</code>和<code>y</code>的类型都是<code>number</code>。</p>
<p>如果不给出类型，TypeScript 会认为<code>x</code>和<code>y</code>的类型都是<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x;</span><br><span class="line">  y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>和<code>y</code>的类型都是<code>any</code>。</p>
<p>如果声明时给出初值，可以不写类型，TypeScript 会自行推断属性的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>和<code>y</code>的类型都会被推断为 number。</p>
<p>TypeScript 有一个配置项<code>strictPropertyInitialization</code>，只要打开（默认是打开的），就会检查属性是否设置了初值，如果没有就报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开 strictPropertyInitialization</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果类的顶层属性不赋值，就会报错。如果不希望出现报错，可以使用非空断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!: <span class="built_in">number</span>;</span><br><span class="line">  y!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>和<code>y</code>没有初值，但是属性名后面添加了感叹号，表示这两个属性肯定不会为空，所以 TypeScript 就不报错了，详见《类型断言》一章。</p>
<h3 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h3><p>属性名前面加上 readonly 修饰符，就表示该属性是只读的。实例对象不能修改这个属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> id = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>id</code>属性前面有 readonly 修饰符，实例对象修改这个属性就会报错。</p>
<p>readonly 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法内部设置只读属性的初值，这是可以的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>:<span class="built_in">string</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法修改只读属性的值也是可以的。或者说，如果两个地方都设置了只读属性的值，以构造方法为准。在其他方法修改只读属性都会报错。</p>
<h3 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h3><p>类的方法就是普通函数，类型声明方式与函数一致。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">point:Point</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">x</span> + point.<span class="property">x</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">y</span> + point.<span class="property">y</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法<code>constructor()</code>和普通方法<code>add()</code>都注明了参数类型，但是省略了返回值类型，因为 TypeScript 可以自己推断出来。</p>
<p>类的方法跟普通函数一样，可以使用参数默认值，以及函数重载。</p>
<p>下面是参数默认值的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果新建实例时，不提供属性<code>x</code>和<code>y</code>的值，它们都等于默认值<code>0</code>。</p>
<p>下面是函数重载的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">s:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">xs:<span class="built_in">number</span>|<span class="built_in">string</span>, y?:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法可以接受一个参数，也可以接受两个参数，采用函数重载进行类型声明。</p>
<p>另外，构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>):<span class="built_in">object</span> &#123; <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法声明了返回值类型<code>object</code>，导致报错。</p>
<h3 id="存取器方法"><a href="#存取器方法" class="headerlink" title="存取器方法"></a>存取器方法</h3><p>存取器（accessor）是特殊的类方法，包括取值器（getter）和存值器（setter）两种方法。</p>
<p>它们用于读写某个属性，取值器用来读取属性，存值器用来写入属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>get name()</code>是取值器，其中<code>get</code>是关键词，<code>name</code>是属性名。外部读取<code>name</code>属性时，实例对象会自动调用这个方法，该方法的返回值就是<code>name</code>属性的值。</p>
<p><code>set name()</code>是存值器，其中<code>set</code>是关键词，<code>name</code>是属性名。外部写入<code>name</code>属性时，实例对象会自动调用这个方法，并将所赋的值作为函数参数传入。</p>
<p>TypeScript 对存取器有以下规则。</p>
<p>（1）如果某个属性只有<code>get</code>方法，没有<code>set</code>方法，那么该属性自动成为只读属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">name</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>name</code>属性没有<code>set</code>方法，对该属性赋值就会报错。</p>
<p>（2）TypeScript 5.1 版之前，<code>set</code>方法的参数类型，必须兼容<code>get</code>方法的返回值类型，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 5.1 版之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>():<span class="built_in">string</span> &#123;  <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>get</code>方法的返回值类型是字符串，与<code>set</code>方法的参数类型<code>number</code>不兼容，导致报错。改成下面这样，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value:<span class="built_in">number</span>|<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>set</code>方法的参数类型（<code>number|string</code>）兼容<code>get</code>方法的返回值类型（<code>string</code>），这是允许的。</p>
<p>TypeScript 5.1 版做出了<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#unrelated-types-for-getters-and-setters">改变</a>，现在两者可以不兼容。</p>
<p>（3）<code>get</code>方法与<code>set</code>方法的可访问性必须一致，要么都为公开方法，要么都为私有方法。</p>
<h3 id="属性索引"><a href="#属性索引" class="headerlink" title="属性索引"></a>属性索引</h3><p>类允许定义属性索引。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span> |</span><br><span class="line">    (<span class="function">(<span class="params">s:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[s] <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[s:string]</code>表示所有属性名类型为字符串的属性，它们的属性值要么是布尔值，要么是返回布尔值的函数。</p>
<p>注意，由于类的方法是一种特殊属性（属性值为函数的属性），所以属性索引的类型定义也涵盖了方法。如果一个对象同时定义了属性索引和方法，那么前者必须包含后者的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性索引的类型里面不包括方法，导致后面的方法<code>f()</code>定义直接报错。正确的写法是下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span> | (<span class="function">() =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性存取器视同属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isInstance</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>inInstance</code>的读取器虽然是一个函数方法，但是视同属性，所以属性索引虽然没有涉及方法类型，但是不会报错。</p>
<h2 id="类的-interface-接口"><a href="#类的-interface-接口" class="headerlink" title="类的 interface 接口"></a>类的 interface 接口</h2><h3 id="implements-关键字"><a href="#implements-关键字" class="headerlink" title="implements 关键字"></a>implements 关键字</h3><p>interface 接口或 type 别名，可以用对象的形式，为 class 指定一组检查条件。然后，类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCountry</span> <span class="keyword">implements</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  capital = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>interface</code>或<code>type</code>都可以定义一个对象类型。类<code>MyCountry</code>使用<code>implements</code>关键字，表示该类的实例对象满足这个外部类型。</p>
<p>interface 只是指定检查条件，如果不满足这些条件就会报错。它并不能代替 class 自身的类型声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">name</span>:<span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s</span>) &#123; <span class="comment">// s 的类型是 any</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>B</code>实现了接口<code>A</code>，但是后者并不能代替<code>B</code>的类型声明。因此，<code>B</code>的<code>get()</code>方法的参数<code>s</code>的类型是<code>any</code>，而不是<code>string</code>。<code>B</code>类依然需要声明参数<code>s</code>的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">y</span> = <span class="number">10</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>A</code>有一个可选属性<code>y</code>，类<code>B</code>没有声明这个属性，所以可以通过类型检查。但是，如果给<code>B</code>的实例对象的属性<code>y</code>赋值，就会报错。所以，<code>B</code>类还是需要声明可选属性<code>y</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，类可以定义接口没有声明的方法和属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPoint</span> <span class="keyword">implements</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="attr">z</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>MyPoint</code>类实现了<code>Point</code>接口，但是内部还定义了一个额外的属性<code>z</code>，这是允许的，表示除了满足接口给出的条件，类还有额外的条件。</p>
<p><code>implements</code>关键字后面，不仅可以是接口，也可以是另一个类。这时，后面的类将被当作接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="attr">id</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">move</span>():<span class="built_in">void</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  id = <span class="number">2</span>; <span class="comment">// 不可省略</span></span><br><span class="line">  <span class="title function_">move</span>():<span class="built_in">void</span> &#123;&#125;;   <span class="comment">// 不可省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>implements</code>后面是类<code>Car</code>，这时 TypeScript 就把<code>Car</code>视为一个接口，要求<code>MyCar</code>实现<code>Car</code>里面的每一个属性和方法，否则就会报错。所以，这时不能因为<code>Car</code>类已经实现过一次，而在<code>MyCar</code>类省略属性或方法。</p>
<p>注意，interface 描述的是类的对外接口，也就是实例的公开属性和公开方法，不能定义私有的属性和方法。这是因为 TypeScript 设计者认为，私有属性是类的内部实现，接口作为模板，不应该涉及类的内部代码写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">member</span>:&#123;&#125;; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>Foo</code>有一个私有属性，结果就报错了。</p>
<h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><p>类可以实现多个接口（其实是接受多重限制），每个接口之间使用逗号分隔。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span>, <span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Car</code>类同时实现了<code>MotorVehicle</code>、<code>Flyable</code>、<code>Swimmable</code>三个接口。这意味着，它必须部署这三个接口声明的所有属性和方法，满足它们的所有条件。</p>
<p>但是，同时实现多个接口并不是一个好的写法，容易使得代码难以管理，可以使用两种方法替代。</p>
<p>第一种方法是类的继承。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecretCar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Car</code>类实现了<code>MotorVehicle</code>，而<code>SecretCar</code>类继承了<code>Car</code>类，然后再实现<code>Flyable</code>和<code>Swimmable</code>两个接口，相当于<code>SecretCar</code>类同时实现了三个接口。</p>
<p>第二种方法是接口的继承。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">b</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>B</code>继承了接口<code>A</code>，类只要实现接口<code>B</code>，就相当于实现<code>A</code>和<code>B</code>两个接口。</p>
<p>前一个例子可以用接口继承改写。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SuperCar</span> <span class="keyword">extends</span> <span class="title class_">MotoVehicle</span>,<span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecretCar</span> <span class="keyword">implements</span> <span class="title class_">SuperCar</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>SecretCar</code>通过<code>SuperCar</code>接口，就间接实现了多个接口。</p>
<p>注意，发生多重实现时（即一个接口同时实现多个接口），不同接口不能有互相冲突的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>foo</code>在两个接口里面的类型不同，如果同时实现这两个接口，就会报错。</p>
<h3 id="类与接口的合并"><a href="#类与接口的合并" class="headerlink" title="类与接口的合并"></a>类与接口的合并</h3><p>TypeScript 不允许两个同名的类，但是如果一个类和一个接口同名，那么接口会被合并进类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 1</span></span><br><span class="line">a.<span class="property">y</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>与接口<code>A</code>同名，后者会被合并进前者的类型定义。</p>
<p>注意，合并进类的非空属性（上例的<code>y</code>），如果在赋值之前读取，会返回<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">y</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，根据类型定义，<code>y</code>应该是一个非空属性。但是合并后，<code>y</code>有可能是<code>undefined</code>。</p>
<h2 id="Class-类型"><a href="#Class-类型" class="headerlink" title="Class 类型"></a>Class 类型</h2><h3 id="实例类型"><a href="#实例类型" class="headerlink" title="实例类型"></a>实例类型</h3><p>TypeScript 的类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">green</span>:<span class="title class_">Color</span> = <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="string">&#x27;green&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，定义了一个类<code>Color</code>。它的类名就代表一种类型，实例对象<code>green</code>就属于该类型。</p>
<p>对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为 Interface，因为两者都代表实例对象的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c1</span>:<span class="title class_">Car</span> = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c2</span>:<span class="title class_">MotorVehicle</span> = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量的类型可以写成类<code>Car</code>，也可以写成接口<code>MotorVehicle</code>。它们的区别是，如果类<code>Car</code>有接口<code>MotoVehicle</code>没有的属性和方法，那么只有变量<code>c1</code>可以调用这些属性和方法。</p>
<p>作为类型使用时，类名只能表示实例的类型，不能表示类的自身类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass:Point,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>createPoint()</code>的第一个参数<code>PointClass</code>，需要传入 Point 这个类，但是如果把参数的类型写成<code>Point</code>就会报错，因为<code>Point</code>描述的是实例类型，而不是 Class 的自身类型。</p>
<p>由于类名作为类型使用，实际上代表一个对象，因此可以把类看作为对象类型起名。事实上，TypeScript 有三种方法可以为对象类型起名：type、interface 和 class。</p>
<h3 id="类的自身类型"><a href="#类的自身类型" class="headerlink" title="类的自身类型"></a>类的自身类型</h3><p>要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass:<span class="keyword">typeof</span> Point,</span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>createPoint()</code>的第一个参数<code>PointClass</code>是<code>Point</code>类自身，要声明这个参数的类型，简便的方法就是使用<code>typeof Point</code>。因为<code>Point</code>类是一个值，<code>typeof Point</code>返回这个值的类型。注意，<code>createPoint()</code>的返回值类型是<code>Point</code>，代表实例类型。</p>
<p>JavaScript 语言中，类只是构造函数的一种语法糖，本质上是构造函数的另一种写法。所以，类的自身类型可以写成构造函数的形式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: <span class="keyword">new</span> (x:<span class="built_in">number</span>, y:<span class="built_in">number</span>) =&gt; Point,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>PointClass</code>的类型写成了一个构造函数，这时就可以把<code>Point</code>类传入。</p>
<p>构造函数也可以写成对象形式，所以参数<code>PointClass</code>的类型还有另一种写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">new</span> (x:<span class="built_in">number</span>, y:<span class="built_in">number</span>): Point</span></span><br><span class="line"><span class="params">  &#125;,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的写法，可以把构造函数提取出来，单独定义一个接口（interface），这样可以大大提高代码的通用性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointConstructor</span> &#123;</span><br><span class="line">  <span class="title function_">new</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="title class_">Point</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: PointConstructor,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，类的自身类型就是一个构造函数，可以单独定义一个接口来表示。</p>
<h3 id="结构类型原则"><a href="#结构类型原则" class="headerlink" title="结构类型原则"></a>结构类型原则</h3><p>Class 也遵循“结构类型原则”。一个对象只要满足 Class 的实例结构，就跟该 Class 属于同一个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  id!:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arg:Foo</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(bar); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>bar</code>满足类<code>Foo</code>的实例结构，只是多了一个属性<code>amount</code>。所以，它可以当作参数，传入函数<code>fn()</code>。</p>
<p>如果两个类的实例结构相同，那么这两个类就是兼容的，可以用在对方的使用场合。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person</code>和<code>Customer</code>是两个结构相同的类，TypeScript 将它们视为相同类型，因此<code>Person</code>可以用在类型为<code>Customer</code>的场合。</p>
<p>现在修改一下代码，<code>Person</code>类添加一个属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person</code>类添加了一个属性<code>age</code>，跟<code>Customer</code>类的结构不再相同。但是这种情况下，TypeScript 依然认为，<code>Person</code>属于<code>Customer</code>类型。</p>
<p>这是因为根据“结构类型原则”，只要<code>Person</code>类具有<code>name</code>属性，就满足<code>Customer</code>类型的实例结构，所以可以代替它。反过来就不行，如果<code>Customer</code>类多出一个属性，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person</code>类比<code>Customer</code>类少一个属性<code>age</code>，它就不满足<code>Customer</code>类型的实例结构，就报错了。因为在使用<code>Customer</code>类型的情况下，可能会用到它的<code>age</code>属性，而<code>Person</code>类就没有这个属性。</p>
<p>总之，只要 A 类具有 B 类的结构，哪怕还有额外的属性和方法，TypeScript 也认为 A 兼容 B 的类型。</p>
<p>不仅是类，如果某个对象跟某个 class 的实例结构相同，TypeScript 也认为两者的类型相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Person</span> = obj; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>obj</code>并不是<code>Person</code>的实例，但是赋值给变量<code>p</code>不会报错，TypeScript 认为<code>obj</code>也属于<code>Person</code>类型，因为它们的属性相同。</p>
<p>由于这种情况，运算符<code>instanceof</code>不适用于判断某个对象是否跟某个 class 属于同一类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，运算符<code>instanceof</code>确认变量<code>obj</code>不是 Person 的实例，但是两者的类型是相同的。</p>
<p>空类不包含任何成员，任何其他类都可以看作与空类结构相同。因此，凡是类型为空类的地方，所有类（包括对象）都可以使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:Empty</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">fn</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="title function_">fn</span>(fn);</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fn()</code>的参数是一个空类，这意味着任何对象都可以用作<code>fn()</code>的参数。</p>
<p>注意，确定两个类的兼容关系时，只检查实例成员，不考虑静态成员和构造方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">t</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:<span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Position</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Point</code>与<code>Position</code>的静态属性和构造方法都不一样，但因为<code>Point</code>的实例成员与<code>Position</code>相同，所以<code>Position</code>兼容<code>Point</code>。</p>
<p>如果类中存在私有成员（private）或保护成员（protected），那么确定兼容关系时，TypeScript 要求私有成员和保护成员来自同一个类，这意味着两个类需要存在继承关系。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>和<code>B</code>都有私有成员（或保护成员）<code>name</code>，这时只有在<code>B</code>继承<code>A</code>的情况下（<code>class B extends A</code>），<code>B</code>才兼容<code>A</code>。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>类（这里又称“子类”）可以使用 extends 关键字继承另一个类（这里又称“基类”）的所有属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">greet</span>() <span class="comment">// &quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>继承了基类<code>A</code>，因此就拥有了<code>greet()</code>方法，不需要再次在类的内部定义这个方法了。</p>
<p>根据结构类型原则，子类也可以用于类型为基类的场合。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = b;</span><br><span class="line">a.<span class="title function_">greet</span>()</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>的类型是基类，但是可以赋值为子类的实例。</p>
<p>子类可以覆盖基类的同名方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">greet</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>定义了一个方法<code>greet()</code>，覆盖了基类<code>A</code>的同名方法。其中，参数<code>name</code>省略时，就调用基类<code>A</code>的<code>greet()</code>方法，这里可以写成<code>super.greet()</code>，使用<code>super</code>关键字指代基类是常见做法。</p>
<p>但是，子类的同名方法不能与基类的类型定义相冲突。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>的<code>greet()</code>有一个<code>name</code>参数，跟基类<code>A</code>的<code>greet()</code>定义不兼容，因此就报错了。</p>
<p>如果基类包括保护成员（<code>protected</code>修饰符），子类可以将该成员的可访问性设置为公开（<code>public</code>修饰符），也可以保持保护成员不变，但是不能改用私有成员（<code>private</code>修饰符），详见后文。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">y</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">x</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">y</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>将基类<code>A</code>的受保护成员改成私有成员，就会报错。</p>
<p>注意，<code>extends</code>关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from A&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from B&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GreeterConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (): <span class="title class_">Greeter</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGreeterBase</span>(<span class="params"></span>):<span class="title class_">GreeterConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt;= <span class="number">0.5</span> ? A : B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">getGreeterBase</span>() &#123;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">greeting</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，例一和例二的<code>extends</code>关键字后面都是构造函数，例三的<code>extends</code>关键字后面是一个表达式，执行后得到的也是一个构造函数。</p>
<p>对于那些只设置了类型、没有初值的顶层属性，有一个细节需要注意。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Animal</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">animal:Animal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resident</span> = animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog:Dog</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>DogHouse</code>的顶层成员<code>resident</code>只设置了类型（<code>Dog</code>），没有设置初值。这段代码在不同的编译设置下，编译结果不一样。</p>
<p>如果编译设置的<code>target</code>设成大于等于<code>ES2022</code>，或者<code>useDefineForClassFields</code>设成<code>true</code>，那么下面代码的执行结果是不一样的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="string">&#x27;animal&#x27;</span>,</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="string">&#x27;dog&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dogHouse = <span class="keyword">new</span> <span class="title class_">DogHouse</span>(dog);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dogHouse.<span class="property">resident</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>DogHouse</code>实例的属性<code>resident</code>输出的是<code>undefined</code>，而不是预料的<code>dog</code>。原因在于 ES2022 标准的 Class Fields 部分，与早期的 TypeScript 实现不一致，导致子类的那些只设置类型、没有设置初值的顶层成员在基类中被赋值后，会在子类被重置为<code>undefined</code>，详细的解释参见《tsconfig.json》一章，以及官方 3.7 版本的<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier">发布说明</a>。</p>
<p>解决方法就是使用<code>declare</code>命令，去声明顶层成员的类型，告诉 TypeScript 这些成员的赋值由基类实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog:Dog</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>resident</code>属性的类型声明前面用了<code>declare</code>命令，这样就能确保在编译目标大于等于<code>ES2022</code>时（或者打开<code>useDefineForClassFields</code>时），代码行为正确。</p>
<h2 id="可访问性修饰符"><a href="#可访问性修饰符" class="headerlink" title="可访问性修饰符"></a>可访问性修饰符</h2><p>类的内部成员的外部可访问性，由三个可访问性修饰符（access modifiers）控制：<code>public</code>、<code>private</code>和<code>protected</code>。</p>
<p>这三个修饰符的位置，都写在属性或方法的最前面。</p>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p><code>public</code>修饰符表示这是公开成员，外部可以自由访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>greet()</code>方法前面的<code>public</code>修饰符，表示该方法可以在类的外部调用，即外部实例可以调用。</p>
<p><code>public</code>修饰符是默认修饰符，如果省略不写，实际上就带有该修饰符。因此，类的属性和方法默认都是外部可访问的。</p>
<p>正常情况下，除非为了醒目和代码可读性，<code>public</code>都是省略不写的。</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p><code>private</code>修饰符表示私有成员，只能用在当前类的内部，类的实例和子类都不能使用该成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">showX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>前面有<code>private</code>修饰符，表示这是私有成员。因此，实例对象和子类使用该成员，都会报错。</p>
<p>注意，子类不能定义父类私有成员的同名成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>类有一个私有属性<code>x</code>，子类<code>B</code>就不能定义自己的属性<code>x</code>了。</p>
<p>如果在类的内部，当前类的实例可以获取私有成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">f</span>(<span class="params">obj:A</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="title function_">f</span>(a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，在类<code>A</code>内部，<code>A</code>的实例对象可以获取私有成员<code>x</code>。</p>
<p>严格地说，<code>private</code>定义的私有成员，并不是真正意义的私有成员。一方面，编译成 JavaScript 后，<code>private</code>关键字就被剥离了，这时外部访问该成员就不会报错。另一方面，由于前一个原因，TypeScript 对于访问<code>private</code>成员没有严格禁止，使用方括号写法（<code>[]</code>）或者<code>in</code>运算符，实例对象就能访问该成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> a) &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>类的属性<code>x</code>是私有属性，但是实例使用方括号，就可以读取这个属性，或者使用<code>in</code>运算符检查这个属性是否存在，都可以正确执行。</p>
<p>由于<code>private</code>存在这些问题，加上它是 ES2022 标准发布前出台的，而 ES2022 引入了自己的私有成员写法<code>#propName</code>。因此建议不使用<code>private</code>，改用 ES2022 的写法，获得真正意义的私有成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  #x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，采用了 ES2022 的私有成员写法（属性名前加<code>#</code>），TypeScript 就正确识别了实例对象没有属性<code>x</code>，从而报错。</p>
<p>构造方法也可以是私有的，这就直接防止了使用<code>new</code>命令生成实例对象，只能在类的内部创建实例对象。</p>
<p>这时一般会有一个静态方法，充当工厂函数，强制所有实例都通过该方法生成。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> instance?: <span class="title class_">Singleton</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Singleton</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="title class_">Singleton</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Singleton</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例使用私有构造方法，实现了单例模式。想要获得 Singleton 的实例，不能使用<code>new</code>命令，只能使用<code>getInstance()</code>方法。</p>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p><code>protected</code>修饰符表示该成员是保护成员，只能在类的内部使用该成员，实例无法使用该成员，但是子类内部可以使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">getX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line">b.<span class="title function_">getX</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>的属性<code>x</code>是保护成员，直接从实例读取该属性（<code>a.x</code>）会报错，但是子类<code>B</code>内部可以读取该属性。</p>
<p>子类不仅可以拿到父类的保护成员，还可以定义同名成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>定义了父类<code>A</code>的同名成员<code>x</code>，并且父类的<code>x</code>是保护成员，子类将其改成了公开成员。<code>B</code>类的<code>x</code>属性前面没有修饰符，等同于修饰符是<code>public</code>，外界可以读取这个属性。</p>
<p>在类的外部，实例对象不能读取保护成员，但是在类的内部可以。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">f</span>(<span class="params">obj:A</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line">a.<span class="title function_">f</span>(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>是类<code>A</code>的保护成员，在类的外部，实例对象<code>a</code>拿不到这个属性。但是，实例对象<code>a</code>传入类<code>A</code>的内部，就可以从<code>a</code>拿到<code>x</code>。</p>
<h3 id="实例属性的简写形式"><a href="#实例属性的简写形式" class="headerlink" title="实例属性的简写形式"></a>实例属性的简写形式</h3><p>实际开发中，很多实例属性的值，是通过构造方法传入的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面实例中，属性<code>x</code>和<code>y</code>的值是通过构造方法的参数传入的。</p>
<p>这样的写法等于对同一个属性要声明两次类型，一次在类的头部，另一次在构造方法的参数里面。这有些累赘，TypeScript 就提供了一种简写形式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">p.<span class="property">x</span> <span class="comment">// 10</span></span><br><span class="line">p.<span class="property">y</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法的参数<code>x</code>前面有<code>public</code>修饰符，这时 TypeScript 就会自动声明一个公开属性<code>x</code>，不必在构造方法里面写任何代码，同时还会设置<code>x</code>的值为构造方法的参数值。注意，这里的<code>public</code>不能省略。</p>
<p>除了<code>public</code>修饰符，构造方法的参数名只要有<code>private</code>、<code>protected</code>、<code>readonly</code>修饰符，都会自动声明对应修饰符的实例属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> a: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> b: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> c: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">readonly</span> d: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a;</span><br><span class="line">    b;</span><br><span class="line">    c;</span><br><span class="line">    d;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a, b, c, d</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">b</span> = b;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">c</span> = c;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">d</span> = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，从编译结果可以看到，构造方法的<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>会生成对应的实例属性。</p>
<p><code>readonly</code>还可以与其他三个可访问性修饰符，一起使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">readonly</span> x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> <span class="keyword">readonly</span> y:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> z:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>类的内部可以使用<code>static</code>关键字，定义静态成员。</p>
<p>静态成员是只能通过类本身使用的成员，不能通过实例对象使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span> <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>是静态属性，<code>printX()</code>是静态方法。它们都必须通过<code>MyClass</code>获取，而不能通过实例对象调用。</p>
<p><code>static</code>关键字前面可以使用 public、private、protected 修饰符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性<code>x</code>前面有<code>private</code>修饰符，表示只能在<code>MyClass</code>内部使用，如果在外部调用这个属性就会报错。</p>
<p>静态私有属性也可以用 ES6 语法的<code>#</code>前缀表示，上面示例可以改写如下。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>public</code>和<code>protected</code>的静态成员可以被继承。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getY</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> B.<span class="property">y</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">x</span> <span class="comment">// 1</span></span><br><span class="line">B.<span class="title function_">getY</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>的静态属性<code>x</code>和<code>y</code>都被<code>B</code>继承，公开成员<code>x</code>可以在<code>B</code>的外部获取，保护成员<code>y</code>只能在<code>B</code>的内部获取。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>类也可以写成泛型，使用类型参数。关于泛型的详细介绍，请看《泛型》一章。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value:Type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>Box</code>有类型参数<code>Type</code>，因此属于泛型类。新建实例时，变量的类型声明需要带有类型参数的值，不过本例等号左边的<code>Box&lt;string&gt;</code>可以省略不写，因为可以从等号右边推断得到。</p>
<p>注意，静态成员不能使用泛型的类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">defaultContents</span>: <span class="title class_">Type</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性<code>defaultContents</code>的类型写成类型参数<code>Type</code>会报错。因为这意味着调用时必须给出类型参数（即写成<code>Box&lt;string&gt;.defaultContents</code>），并且类型参数发生变化，这个属性也会跟着变，这并不是好的做法。</p>
<h2 id="抽象类，抽象成员"><a href="#抽象类，抽象成员" class="headerlink" title="抽象类，抽象成员"></a>抽象类，抽象成员</h2><p>TypeScript 允许在类的定义前面，加上关键字<code>abstract</code>，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做“抽象类”（abstract class）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，直接新建抽象类的实例，会报错。</p>
<p>抽象类只能当作基类使用，用来在它的基础上定义子类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  amount = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"></span><br><span class="line">b.<span class="property">id</span> <span class="comment">// 1</span></span><br><span class="line">b.<span class="property">amount</span> <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>是一个抽象类，<code>B</code>是<code>A</code>的子类，继承了<code>A</code>的所有成员，并且可以定义自己的成员和实例化。</p>
<p>抽象类的子类也可以是抽象类，也就是说，抽象类可以继承其他抽象类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="attr">bar</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类的内部可以有已经实现好的属性和方法，也可以有还未实现的属性和方法。后者就叫做“抽象成员”（abstract member），即属性名和方法名有<code>abstract</code>关键字，表示该方法需要子类实现。如果子类没有实现抽象成员，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">bar</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  foo = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，抽象类<code>A</code>定义了抽象属性<code>foo</code>，子类<code>B</code>必须实现这个属性，否则会报错。</p>
<p>下面是抽象方法的例子。如果抽象类的方法前面加上<code>abstract</code>，就表明子类必须给出该方法的实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">execute</span>():<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`B executed`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个注意点。</p>
<p>（1）抽象成员只能存在于抽象类，不能存在于普通类。</p>
<p>（2）抽象成员不能有具体实现的代码。也就是说，已经实现好的成员前面不能加<code>abstract</code>关键字。</p>
<p>（3）抽象成员前也不能有<code>private</code>修饰符，否则无法在子类中实现该成员。</p>
<p>（4）一个子类最多只能继承一个抽象类。</p>
<p>总之，抽象类的作用是，确保各种相关的子类都拥有跟基类相同的接口，可以看作是模板。其中的抽象成员都是必须由子类实现的成员，非抽象成员则表示基类已经实现的、由所有子类共享的成员。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>类的方法经常用到<code>this</code>关键字，它表示该方法当前所在的对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="title function_">getName</span>() <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: a.<span class="property">getName</span></span><br><span class="line">&#125;;</span><br><span class="line">b.<span class="title function_">getName</span>() <span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>b</code>的<code>getName()</code>是同一个方法，但是执行结果不一样，原因就是它们内部的<code>this</code>指向不一样的对象。如果<code>getName()</code>在变量<code>a</code>上运行，<code>this</code>指向<code>a</code>；如果在<code>b</code>上运行，<code>this</code>指向<code>b</code>。</p>
<p>有些场合需要给出<code>this</code>类型，但是 JavaScript 函数通常不带有<code>this</code>参数，这时 TypeScript 允许函数增加一个名为<code>this</code>的参数，放在参数列表的第一位，用来描述函数内部的<code>this</code>关键字的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: SomeType,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fn()</code>的第一个参数是<code>this</code>，用来声明函数内部的<code>this</code>的类型。编译时，TypeScript 一旦发现函数的第一个参数名为<code>this</code>，则会去除这个参数，即编译结果不会带有该参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"><span class="variable language_">this</span>: A</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="property">getName</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>的<code>getName()</code>添加了<code>this</code>参数，如果直接调用这个方法，<code>this</code>的类型就会跟声明的类型不一致，从而报错。</p>
<p><code>this</code>参数的类型可以声明为各种对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: &#123; name: <span class="built_in">string</span> &#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="number">123</span> &#125;); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>this</code>的类型是一个带有<code>name</code>属性的对象，不符合这个条件的<code>this</code>都会报错。</p>
<p>TypeScript 提供了一个<code>noImplicitThis</code>编译选项。如果打开了这个设置项，如果<code>this</code>的值推断为<code>any</code>类型，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// noImplicitThis 打开</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> width:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> height:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getAreaFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>; <span class="comment">// 报错</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getAreaFunction()</code>方法返回一个函数，这个函数里面用到了<code>this</code>，但是这个<code>this</code>跟<code>Rectangle</code>这个类没关系，它的类型推断为<code>any</code>，所以就报错了。</p>
<p>在类的内部，<code>this</code>本身也可以当作类型使用，表示当前类的实例对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">contents</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">value</span>:<span class="built_in">string</span>):<span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>set()</code>方法的返回值类型就是<code>this</code>，表示当前的实例对象。</p>
<p>注意，<code>this</code>类型不允许应用于静态成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">a</span>:<span class="variable language_">this</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性<code>a</code>的返回值类型是<code>this</code>，就报错了。原因是<code>this</code>类型表示实例对象，但是静态成员拿不到实例对象。</p>
<p>有些方法返回一个布尔值，表示当前的<code>this</code>是否属于某种类型。这时，这些方法的返回值类型可以写成<code>this is Type</code>的形式，其中用到了<code>is</code>运算符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemObject</span> &#123;</span><br><span class="line">  <span class="title function_">isFile</span>(): <span class="variable language_">this</span> is <span class="title class_">FileRep</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">FileRep</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isDirectory</span>(): <span class="variable language_">this</span> is <span class="title class_">Directory</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Directory</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两个方法的返回值类型都是布尔值，写成<code>this is Type</code>的形式，可以精确表示返回值。<code>is</code>运算符的介绍详见《类型断言》一章。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="http://fritzthecat-blog.blogspot.com/2018/06/typescript-constructor-in-interface.html">TypeScript Constructor in Interface</a></li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-class/" data-id="clm609r2t000ft4wl78a2a08g" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-comment" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-comment/">TypeScript 的注释指令</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-comment/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><p>TypeScript 接受一些注释指令。</p>
<p>所谓“注释指令”，指的是采用 JS 双斜杠注释的形式，向编译器发出的命令。</p>
<h2 id="ts-nocheck"><a href="#ts-nocheck" class="headerlink" title="// @ts-nocheck"></a><code>// @ts-nocheck</code></h2><p><code>// @ts-nocheck</code>告诉编译器不对当前脚本进行类型检查，可以用于 TypeScript 脚本，也可以用于 JavaScript 脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-nocheck</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>document.getElementById(123)</code>存在类型错误，但是编译器不对该脚本进行类型检查，所以不会报错。</p>
<h2 id="ts-check"><a href="#ts-check" class="headerlink" title="// @ts-check"></a><code>// @ts-check</code></h2><p>如果一个 JavaScript 脚本顶部添加了<code>// @ts-check</code>，那么编译器将对该脚本进行类型检查，不论是否启用了<code>checkJs</code>编译选项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"><span class="keyword">let</span> isChecked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isChceked); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例是一个 JavaScript 脚本，<code>// @ts-check</code>告诉 TypeScript 编译器对其进行类型检查，所以最后一行会报错，提示拼写错误。</p>
<h2 id="ts-ignore"><a href="#ts-ignore" class="headerlink" title="// @ts-ignore"></a><code>// @ts-ignore</code></h2><p><code>// @ts-ignore</code>告诉编译器不对下一行代码进行类型检查，可以用于 TypeScript 脚本，也可以用于 JavaScript 脚本。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行是类型错误，变量<code>x</code>的类型是<code>number</code>，不能等于布尔值。但是因为前面加上了<code>// @ts-ignore</code>，编译器会跳过这一行的类型检查，所以不会报错。</p>
<h2 id="ts-expect-error"><a href="#ts-expect-error" class="headerlink" title="// @ts-expect-error"></a><code>// @ts-expect-error</code></h2><p><code>// @ts-expect-error</code>主要用在测试用例，当下一行有类型错误时，它会压制 TypeScript 的报错信息（即不显示报错信息），把错误留给代码自己处理。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params">abc: <span class="built_in">string</span>, xyz: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="title function_">assert</span>(<span class="keyword">typeof</span> abc === <span class="string">&quot;string&quot;</span>);</span><br><span class="line">  <span class="title function_">assert</span>(<span class="keyword">typeof</span> xyz === <span class="string">&quot;string&quot;</span>);</span><br><span class="line">  <span class="comment">// do some stuff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line"><span class="title function_">expect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">doStuff</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">&#125;).<span class="title function_">toThrow</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例是一个测试用例，倒数第二行的<code>doStuff(123, 456)</code>的参数类型与定义不一致，TypeScript 引擎会报错。但是，测试用例本身测试的就是这个错误，已经有专门的处理代码，所以这里可以使用<code>// @ts-expect-error</code>，不显示引擎的报错信息。</p>
<p>如果下一行没有类型错误，<code>// @ts-expect-error</code>则会显示一行提示。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 输出 Unused &#x27;@ts-expect-error&#x27; directive.</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第二行是正确代码，这时系统会给出一个提示，表示<code>@ts-expect-error</code>没有用到。</p>
<h2 id="JSDoc"><a href="#JSDoc" class="headerlink" title="JSDoc"></a>JSDoc</h2><p>TypeScript 直接处理 JS 文件时，如果无法推断出类型，会使用 JS 脚本里面的 JSDoc 注释。</p>
<p>使用 JSDoc 时，有两个基本要求。</p>
<p>（1）JSDoc 注释必须以<code>/**</code>开始，其中星号（<code>*</code>）的数量必须为两个。若使用其他形式的多行注释，则 JSDoc 会忽略该条注释。</p>
<p>（2）JSDoc 注释必须与它描述的代码处于相邻的位置，并且注释在上，代码在下。</p>
<p>下面是 JSDoc 的一个简单例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">somebody</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">somebody</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello &#x27;</span> + somebody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，注释里面的<code>@param</code>是一个 JSDoc 声明，表示下面的函数<code>sayHello()</code>的参数<code>somebody</code>类型为<code>string</code>。</p>
<p>TypeScript 编译器支持大部分的 JSDoc 声明，下面介绍其中的一些。</p>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="@typedef"></a>@typedef</h3><p><code>@typedef</code>命令创建自定义类型，等同于 TypeScript 里面的类型别名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">(number | string)</span>&#125; <span class="variable">NumberLike</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，定义了一个名为<code>NumberLike</code>的新类型，它是由<code>number</code>和<code>string</code>构成的联合类型，等同于 TypeScript 的如下语句。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NumberLike</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><p><code>@type</code>命令定义变量的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>@type</code>定义了变量<code>a</code>的类型为<code>string</code>。</p>
<p>在<code>@type</code>命令中可以使用由<code>@typedef</code>命令创建的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">(number | string)</span>&#125; <span class="variable">NumberLike</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">NumberLike</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>@type</code>命令中允许使用 TypeScript 类型及其语法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**<span class="doctag">@type</span> &#123;<span class="type">true | false</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">number[]</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">Array&lt;number&gt;</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">&#123; readonly x: number, y?: string </span>&#125;&#125; */</span></span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">(s: string, b: boolean) =&gt; number</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> e;</span><br></pre></td></tr></table></figure>

<h3 id="param"><a href="#param" class="headerlink" title="@param"></a>@param</h3><p><code>@param</code>命令用于定义函数参数的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125;  <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果是可选参数，需要将参数名放在方括号<code>[]</code>里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125;  [x]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>方括号里面，还可以指定参数默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; [x=&quot;bar&quot;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>x</code>的默认值是字符串<code>bar</code>。</p>
<h3 id="return，-returns"><a href="#return，-returns" class="headerlink" title="@return，@returns"></a>@return，@returns</h3><p><code>@return</code>和<code>@returns</code>命令的作用相同，指定函数返回值的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="extends-和类型修饰符"><a href="#extends-和类型修饰符" class="headerlink" title="@extends 和类型修饰符"></a>@extends 和类型修饰符</h3><p><code>@extends</code>命令用于定义继承的基类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@extends</span> &#123;<span class="type">Base</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@public</code>、<code>@protected</code>、<code>@private</code>分别指定类的公开成员、保护成员和私有成员。</p>
<p><code>@readonly</code>指定只读成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@public</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@readonly</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-comment/" data-id="clm609r2w000jt4wlbfl6dywz" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-d.ts" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-d.ts/">d.ts 类型声明文件</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-d.ts/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单独使用的模块，一般会同时提供一个单独的类型声明文件（declaration file），把本模块的外部接口的所有类型都写在这个文件里面，便于模块使用者了解接口，也便于编译器检查使用者的用法是否正确。</p>
<p>类型声明文件里面只有类型代码，没有具体的代码实现。它的文件名一般为<code>[模块名].d.ts</code>的形式，其中的<code>d</code>表示 declaration（声明）。</p>
<p>举例来说，有一个模块的代码如下。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxInterval = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  getArrayLength,</span><br><span class="line">  maxInterval,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的类型声明文件可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">maxInterval</span>: <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>类型声明文件也可以使用<code>export =</code>命令，输出对外接口。下面是 moment 模块的类型声明文件的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">moment</span>(<span class="params"></span>): <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">export</span> = moment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，模块<code>moment</code>内部有一个函数<code>moment()</code>，而<code>export =</code>表示<code>module.exports</code>输出的就是这个函数。</p>
<p>除了使用<code>export =</code>，模块输出在类型声明文件中，也可以使用<code>export default</code>表示。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块输出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="number">3.142</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型输出文件</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">pi</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">pi</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span>= pi;</span><br></pre></td></tr></table></figure>

<p>上面示例中，模块输出的是一个整数，那么可以用<code>export default</code>或<code>export =</code>表示输出这个值。</p>
<p>下面是一个如何使用类型声明文件的简单例子。有一个类型声明文件<code>types.d.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">  catchphrase?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，就可以在 TypeScript 脚本里面导入该文件声明的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Character</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">character</span>:<span class="title class_">Character</span> = &#123;</span><br><span class="line">  <span class="attr">catchphrase</span>: <span class="string">&quot;Yee-haw!&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sandy Cheeks&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类型声明文件也可以包括在项目的 tsconfig.json 文件里面，这样的话，编译器打包项目时，会自动将类型声明文件加入编译，而不必在每个脚本里面加载类型声明文件。比如，moment 模块的类型声明文件是<code>moment.d.ts</code>，使用 moment 模块的项目可以将其加入项目的 tsconfig.json 文件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src/index.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typings/moment.d.ts&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型声明文件的来源"><a href="#类型声明文件的来源" class="headerlink" title="类型声明文件的来源"></a>类型声明文件的来源</h2><p>类型声明文件主要有以下三种来源。</p>
<ul>
<li>TypeScript 编译器自动生成。</li>
<li>TypeScript 内置类型文件。</li>
<li>外部模块的类型声明文件，需要自己安装。</li>
</ul>
<h3 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h3><p>只要使用编译选项<code>declaration</code>，编译器就会在编译时自动生成单独的类型声明文件。</p>
<p>下面是在<code>tsconfig.json</code>文件里面，打开这个选项。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以在命令行打开这个选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --declaration</span><br></pre></td></tr></table></figure>

<h3 id="内置声明文件"><a href="#内置声明文件" class="headerlink" title="内置声明文件"></a>内置声明文件</h3><p>安装 TypeScript 语言时，会同时安装一些内置的类型声明文件，主要是内置的全局对象（JavaScript 语言接口和运行环境 API）的类型声明。</p>
<p>这些内置声明文件位于 TypeScript 语言安装目录的<code>lib</code>文件夹内，数量大概有几十个，下面是其中一些主要文件。</p>
<ul>
<li>lib.d.ts</li>
<li>lib.dom.d.ts</li>
<li>lib.es2015.d.ts</li>
<li>lib.es2016.d.ts</li>
<li>lib.es2017.d.ts</li>
<li>lib.es2018.d.ts</li>
<li>lib.es2019.d.ts</li>
<li>lib.es2020.d.ts</li>
<li>lib.es5.d.ts</li>
<li>lib.es6.d.ts</li>
</ul>
<p>这些内置声明文件的文件名统一为“lib.[description].d.ts”的形式，其中<code>description</code>部分描述了文件内容。比如，<code>lib.dom.d.ts</code>这个文件就描述了 DOM 结构的类型。</p>
<p>如果开发者想了解全局对象的类型接口（比如 ES6 全局对象的类型），那么就可以去查看这些内置声明文件。</p>
<p>TypeScript 编译器会自动根据编译目标<code>target</code>的值，加载对应的内置声明文件，所以不需要特别的配置。但是，可以使用编译选项<code>lib</code>，指定加载哪些内置声明文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;dom&quot;</span>, <span class="string">&quot;es2021&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>lib</code>选项指定加载<code>dom</code>和<code>es2021</code>这两个内置类型声明文件。</p>
<p>编译选项<code>noLib</code>会禁止加载任何内置声明文件。</p>
<h3 id="外部类型声明文件"><a href="#外部类型声明文件" class="headerlink" title="外部类型声明文件"></a>外部类型声明文件</h3><p>如果项目中使用了外部的某个第三方代码库，那么就需要这个库的类型声明文件。</p>
<p>这时又分成三种情况。</p>
<p>（1）这个库自带了类型声明文件。</p>
<p>一般来说，如果这个库的源码包含了<code>[vendor].d.ts</code>文件，那么就自带了类型声明文件。其中的<code>vendor</code>表示这个库的名字，比如<code>moment</code>这个库就自带<code>moment.d.ts</code>。使用这个库可能需要单独加载它的类型声明文件。</p>
<p>（2）这个库没有自带，但是可以找到社区制作的类型声明文件。</p>
<p>第三方库如果没有提供类型声明文件，社区往往会提供。TypeScript 社区主要使用 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped 仓库</a>，各种类型声明文件都会提交到那里，已经包含了几千个第三方库。</p>
<p>这些声明文件都会作为一个单独的库，发布到 npm 的<code>@types</code>名称空间之下。比如，jQuery 的类型声明文件就发布成<code>@types/jquery</code>这个库，使用时安装这个库就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure>

<p>执行上面的命令，<code>@types/jquery</code>这个库就安装到项目的<code>node_modules/@types/jquery</code>目录，里面的<code>index.d.ts</code>文件就是 jQuery 的类型声明文件。如果类型声明文件不是<code>index.d.ts</code>，那么就需要在<code>package.json</code>的<code>types</code>或<code>typings</code>字段，指定类型声明文件的文件名。</p>
<p>TypeScript 会自动加载<code>node_modules/@types</code>目录下的模块，但可以使用编译选项<code>typeRoots</code>改变这种行为。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [<span class="string">&quot;./typings&quot;</span>, <span class="string">&quot;./vendor/types&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例表示，TypeScript 不再去<code>node_modules/@types</code>目录，而是去跟当前<code>tsconfig.json</code>同级的<code>typings</code>和<code>vendor/types</code>子目录，加载类型模块了。</p>
<p>默认情况下，TypeScript 会自动加载<code>typeRoots</code>目录里的所有模块，编译选项<code>types</code>可以指定加载哪些模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;types&quot;</span> : [<span class="string">&quot;jquery&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面设置中，<code>types</code>属性是一个数组，成员是所要加载的类型模块，要加载几个模块，这个数组就有几个成员，每个类型模块在<code>typeRoots</code>目录下都有一个自己的子目录。这样的话，TypeScript 就会自动去<code>jquery</code>子目录，加载 jQuery 的类型声明文件。</p>
<p>（3）找不到类型声明文件，需要自己写。</p>
<p>有时实在没有第三方库的类型声明文件，又很难完整给出该库的类型描述，这时你可以告诉 TypeScript 相关对象的类型是<code>any</code>。比如，使用 jQuery 的脚本可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">$</span>:<span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">JQuery</span> = <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">$</span>:<span class="title class_">JQuery</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，jQuery 的<code>$</code>对象是外部引入的，类型是<code>any</code>，也就是 TypeScript 不用对它进行类型检查。</p>
<p>也可以采用下面的写法，将整个外部模块的类型设为<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;模块名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>有了上面的命令，指定模块的所有接口都将视为<code>any</code>类型。</p>
<h2 id="declare-关键字"><a href="#declare-关键字" class="headerlink" title="declare 关键字"></a>declare 关键字</h2><p>类型声明文件只包含类型描述，不包含具体实现，所以非常适合使用 declare 语句来描述类型。declare 关键字的具体用法，详见《declare 关键字》一章，这里讲解如何在类型声明文件里面使用它。</p>
<p>类型声明文件里面，变量的类型描述必须使用<code>declare</code>命令，否则会报错，因为变量声明语句是值相关代码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>interface 类型有没有<code>declare</code>都可以，因为 interface 是完全的类型代码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;&#125; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;&#125; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>类型声明文件里面，顶层可以使用<code>export</code>命令，也可以不用，除非使用者脚本会显式使用<code>export</code>命令输入类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是类型声明文件的一些例子。先看 moment 模块的类型描述文件<code>moment.d.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Moment</span> &#123;</span><br><span class="line">    <span class="title function_">format</span>(<span class="attr">format</span>:<span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">add</span>(</span><br><span class="line">      <span class="attr">amount</span>: <span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">unit</span>: <span class="string">&#x27;days&#x27;</span> | <span class="string">&#x27;months&#x27;</span> | <span class="string">&#x27;years&#x27;</span></span><br><span class="line">    ): <span class="title class_">Moment</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">subtract</span>(</span><br><span class="line">      <span class="attr">amount</span>:<span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">unit</span>:<span class="string">&#x27;days&#x27;</span> | <span class="string">&#x27;months&#x27;</span> | <span class="string">&#x27;years&#x27;</span></span><br><span class="line">    ): <span class="title class_">Moment</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">moment</span>(<span class="params"></span></span><br><span class="line"><span class="params">    input?: <span class="built_in">string</span> | <span class="built_in">Date</span></span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Moment</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> moment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，可以注意一下默认接口<code>moment()</code>的写法。</p>
<p>下面是 D3 库的类型声明文件<code>D3.d.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> D3 &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Selectors</span> &#123;</span><br><span class="line">    <span class="attr">select</span>: &#123;</span><br><span class="line">      (<span class="attr">selector</span>: <span class="built_in">string</span>): <span class="title class_">Selection</span>;</span><br><span class="line">      (<span class="attr">element</span>: <span class="title class_">EventTarget</span>): <span class="title class_">Selection</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Base</span> <span class="keyword">extends</span> <span class="title class_">Selectors</span> &#123;</span><br><span class="line">    <span class="attr">event</span>: <span class="title class_">Event</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">d3</span>: <span class="variable constant_">D3</span>.<span class="property">Base</span>;</span><br></pre></td></tr></table></figure>

<h2 id="模块发布"><a href="#模块发布" class="headerlink" title="模块发布"></a>模块发布</h2><p>当前模块如果包含自己的类型声明文件，可以在 package.json 文件里面添加一个<code>types</code>字段或<code>typings</code>字段，指明类型声明文件的位置。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;awesome&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vandelay Industries&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./lib/main.d.ts&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>types</code>字段给出了类型声明文件的位置。</p>
<p>注意，如果类型声明文件名为<code>index.d.ts</code>，且在项目的根目录中，那就不需要在<code>package.json</code>里面注明了。</p>
<p>有时，类型声明文件会单独发布成一个 npm 模块，这时用户就必须同时加载该模块。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;browserify-typescript-extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vandelay Industries&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./lib/main.d.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;browserify&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/browserify&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescript&quot;</span>: <span class="string">&quot;next&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是一个模块的 package.json 文件，该模块需要 browserify 模块。由于后者的类型声明文件是一个单独的模块<code>@types/browserify</code>，所以还需要加载那个模块。</p>
<h2 id="三斜杠命令"><a href="#三斜杠命令" class="headerlink" title="三斜杠命令"></a>三斜杠命令</h2><p>如果类型声明文件的内容非常多，可以拆分成多个文件，然后入口文件使用三斜杠命令，加载其他拆分后的文件。</p>
<p>举例来说，入口文件是<code>main.d.ts</code>，里面的接口定义在<code>interfaces.d.ts</code>，函数定义在<code>functions.d.ts</code>。那么，<code>main.d.ts</code>里面可以用三斜杠命令，加载后面两个文件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;./interfaces.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;./functions.d.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>三斜杠命令（<code>///</code>）是一个 TypeScript 编译器命令，用来指定编译器行为。它只能用在文件的头部，如果用在其他地方，会被当作普通的注释。另外，若一个文件中使用了三斜线命令，那么在三斜线命令之前只允许使用单行注释、多行注释和其他三斜线命令，否则三斜杠命令也会被当作普通的注释。</p>
<p>除了拆分类型声明文件，三斜杠命令也可以用于普通脚本加载类型声明文件。</p>
<p>三斜杠命令主要包含三个参数，代表三种不同的命令。</p>
<ul>
<li>path</li>
<li>types</li>
<li>lib</li>
</ul>
<p>下面依次进行讲解。</p>
<h3 id="lt-reference-path-quot-quot-gt"><a href="#lt-reference-path-quot-quot-gt" class="headerlink" title="/// &lt;reference path=&quot;&quot; /&gt;"></a><code>/// &lt;reference path=&quot;&quot; /&gt;</code></h3><p><code>/// &lt;reference path=&quot;&quot; /&gt;</code>是最常见的三斜杠命令，告诉编译器在编译时需要包括的文件，常用来声明当前脚本依赖的类型文件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;./lib.ts&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例表示，当前脚本依赖于<code>./lib.ts</code>，里面是<code>add()</code>的定义。编译当前脚本时，还会同时编译<code>./lib.ts</code>。编译产物会有两个 JS 文件，一个当前脚本，另一个就是<code>./lib.js</code>。</p>
<p>下面的例子是当前脚本依赖于 Node.js 类型声明文件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">URL</span> <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = <span class="variable constant_">URL</span>.<span class="title function_">parse</span>(<span class="string">&quot;https://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会在预处理阶段，找出所有三斜杠引用的文件，将其添加到编译列表中，然后一起编译。</p>
<p><code>path</code>参数指定了所引入文件的路径。如果该路径是一个相对路径，则基于当前脚本的路径进行计算。</p>
<p>使用该命令时，有以下两个注意事项。</p>
<ul>
<li><code>path</code>参数必须指向一个存在的文件，若文件不存在会报错。</li>
<li><code>path</code>参数不允许指向当前文件。</li>
</ul>
<p>默认情况下，每个三斜杠命令引入的脚本，都会编译成单独的 JS 文件。如果希望编译后只产出一个合并文件，可以使用编译选项<code>outFile</code>。但是，<code>outFile</code>编译选项不支持合并 CommonJS 模块和 ES 模块，只有当编译参数<code>module</code>的值设为 None、System 或 AMD 时，才能编译成一个文件。</p>
<p>如果打开了编译参数<code>noResolve</code>，则忽略三斜杠指令。将其当作一般的注释，原样保留在编译产物中。</p>
<h3 id="lt-reference-types-quot-quot-gt"><a href="#lt-reference-types-quot-quot-gt" class="headerlink" title="/// &lt;reference types=&quot;&quot; /&gt;"></a><code>/// &lt;reference types=&quot;&quot; /&gt;</code></h3><p>types 参数用来告诉编译器当前脚本依赖某个 DefinitelyTyped 类型库，通常安装在<code>node_modules/@types</code>目录。</p>
<p>types 参数的值是类型库的名称，也就是安装到<code>node_modules/@types</code>目录中的子目录的名字。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;node&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，这个三斜杠命令表示编译时添加 Node.js 的类型库，实际添加的脚本是<code>node_modules</code>目录里面的<code>@types/node/index.d.ts</code>。</p>
<p>可以看到，这个命令的作用类似于<code>import</code>命令。</p>
<p>注意，这个命令只在你自己手写类型声明文件（<code>.d.ts</code>文件）时，才有必要用到，也就是说，只应该用在<code>.d.ts</code>文件中，普通的<code>.ts</code>脚本文件不需要写这个命令。如果是普通的<code>.ts</code>脚本，可以使用<code>tsconfig.json</code>文件的<code>types</code>属性指定依赖的类型库。</p>
<h3 id="lt-reference-lib-quot-quot-gt"><a href="#lt-reference-lib-quot-quot-gt" class="headerlink" title="/// &lt;reference lib=&quot;&quot; /&gt;"></a><code>/// &lt;reference lib=&quot;&quot; /&gt;</code></h3><p><code>/// &lt;reference lib=&quot;...&quot; /&gt;</code>命令允许脚本文件显式包含内置 lib 库，等同于在<code>tsconfig.json</code>文件里面使用<code>lib</code>属性指定 lib 库。</p>
<p>前文说过，安装 TypeScript 软件包时，会同时安装一些内置的类型声明文件，即内置的 lib 库。这些库文件位于 TypeScript 安装目录的<code>lib</code>文件夹中，它们描述了 JavaScript 语言和引擎的标准 API。</p>
<p>库文件并不是固定的，会随着 TypeScript 版本的升级而更新。库文件统一使用“lib.[description].d.ts”的命名方式，而<code>/// &lt;reference lib=&quot;&quot; /&gt;</code>里面的<code>lib</code>属性的值就是库文件名的<code>description</code>部分，比如<code>lib=&quot;es2015&quot;</code>就表示加载库文件<code>lib.es2015.d.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference lib=&quot;es2017.string&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>es2017.string</code>对应的库文件就是<code>lib.es2017.string.d.ts</code>。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-d.ts/" data-id="clm609r2y000kt4wlcmxjdtuo" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-declare" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-declare/">declare 关键字</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-declare/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>declare 关键字用来告诉编译器，某个类型是存在的，可以在当前文件中使用。</p>
<p>它的主要作用，就是让当前文件可以使用其他文件声明的类型。举例来说，自己的脚本使用外部库定义的函数，编译器会因为不知道外部函数的类型定义而报错，这时就可以在自己的脚本里面使用<code>declare</code>关键字，告诉编译器外部函数的类型。这样的话，编译单个脚本就不会因为使用了外部类型而报错。</p>
<p>declare 关键字可以描述以下类型。</p>
<ul>
<li>变量（const、let、var 命令声明）</li>
<li>type 或者 interface 命令声明的类型</li>
<li>class</li>
<li>enum</li>
<li>函数（function）</li>
<li>模块（module）</li>
<li>命名空间（namespace）</li>
</ul>
<p>declare 关键字的重要特点是，它只是通知编译器某个类型是存在的，不用给出具体实现。比如，只描述函数的类型，不给出函数的实现，如果不使用<code>declare</code>，这是做不到的。</p>
<p>declare 只能用来描述已经存在的变量和数据结构，不能用来声明新的变量和数据结构。另外，所有 declare 语句都不会出现在编译后的文件里面。</p>
<h2 id="declare-variable"><a href="#declare-variable" class="headerlink" title="declare variable"></a>declare variable</h2><p>declare 关键字可以给出外部变量的类型描述。</p>
<p>举例来说，当前脚本使用了其他脚本定义的全局变量<code>x</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">123</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>是其他脚本定义的，当前脚本不知道它的类型，编译器就会报错。</p>
<p>这时使用 declare 命令给出它的类型，就不会报错了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果 declare 关键字没有给出变量的具体类型，那么变量类型就是<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> x;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型为<code>any</code>。</p>
<p>下面的例子是脚本使用浏览器全局对象<code>document</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="variable language_">document</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 告诉编译器，变量<code>document</code>的类型是外部定义的（具体定义在 TypeScript 内置文件<code>lib.d.ts</code>）。</p>
<p>如果 TypeScript 没有找到<code>document</code>的外部定义，这里就会假定它的类型是<code>any</code>。</p>
<p>注意，declare 关键字只用来给出类型描述，是纯的类型代码，不允许设置变量的初始值，即不能涉及值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 设置了变量的初始值，结果就报错了。</p>
<h2 id="declare-function"><a href="#declare-function" class="headerlink" title="declare function"></a>declare function</h2><p>declare 关键字可以给出外部函数的类型描述。</p>
<p>下面是一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 命令给出了<code>sayHello()</code>的类型描述，因此可以直接使用它。</p>
<p>注意，这种单独的函数类型声明语句，只能用于<code>declare</code>命令后面。一方面，TypeScript 不支持单独的函数类型声明语句；另一方面，declare 关键字后面也不能带有函数的具体实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;你好，&#x27;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，单独写函数的类型声明就会报错。</p>
<h2 id="declare-class"><a href="#declare-class" class="headerlink" title="declare class"></a>declare class</h2><p>declare 给出 class 类型描述的写法如下。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">eat</span>():<span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">sleep</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个复杂一点的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="comment">// 静态成员</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">s0</span>():<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">s1</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">b</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">arg:<span class="built_in">number</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="title function_">m</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存取器</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">c</span>():<span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">c</span>(<span class="params">value:<span class="built_in">number</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 索引签名</span></span><br><span class="line">  [<span class="attr">index</span>:<span class="built_in">string</span>]:<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，declare 后面不能给出 Class 的具体实现或初始值。</p>
<h2 id="declare-module，declare-namespace"><a href="#declare-module，declare-namespace" class="headerlink" title="declare module，declare namespace"></a>declare module，declare namespace</h2><p>如果想把变量、函数、类组织在一起，可以将 declare 与 module 或 namespace 一起使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">AnimalLib</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">eat</span>():<span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">sleep</span>():<span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="string">&#x27;Fish&#x27;</span> | <span class="string">&#x27;Dog&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="title class_">AnimalLib</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">eat</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">sleep</span>(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="string">&#x27;Fish&#x27;</span> | <span class="string">&#x27;Dog&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 关键字给出了 module 或 namespace 的类型描述。</p>
<p>declare module 和 declare namespace 里面，加不加 export 关键字都可以。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">a</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;io&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">filename:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，namespace 和 module 里面使用了 export 关键字。</p>
<p>下面的例子是当前脚本使用了<code>myLib</code>这个外部库，它有方法<code>makeGreeting()</code>和属性<code>numberOfGreetings</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = myLib.<span class="title function_">makeGreeting</span>(<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;欢迎词：&#x27;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = myLib.<span class="property">numberOfGreetings</span>;</span><br></pre></td></tr></table></figure>

<p><code>myLib</code>的类型描述就可以这样写。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">makeGreeting</span>(<span class="params">s:<span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">numberOfGreetings</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>declare 关键字的另一个用途，是为外部模块添加属性和方法时，给出新增部分的类型描述。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Foo</span> <span class="keyword">as</span> <span class="title class_">Bar</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moduleA&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="attr">custom</span>: &#123;</span><br><span class="line">      <span class="attr">prop1</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，从模块<code>moduleA</code>导入了<code>Foo</code>接口，将其重命名为<code>Bar</code>，并用 declare 关键字为<code>Bar</code>增加一个属性<code>custom</code>。</p>
<p>下面是另一个例子。一个项目有多个模块，可以在一个模块中，对另一个模块的接口进行类型扩展。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;./a&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，脚本<code>a.ts</code>定义了一个接口<code>A</code>，脚本<code>b.ts</code>为这个接口添加了属性<code>y</code>。<code>declare module &#39;./a&#39; &#123;&#125;</code>表示对<code>a.ts</code>里面的模块，进行类型声明，而同名 interface 会自动合并，所以等同于扩展类型。</p>
<p>使用这种语法进行模块的类型扩展时，有两点需要注意：</p>
<p>（1）<code>declare module NAME</code>语法里面的模块名<code>NAME</code>，跟 import 和 export 的模块名规则是一样的，且必须跟当前文件加载该模块的语句写法（上例<code>import &#123; A &#125; from &#39;./a&#39;</code>）保持一致。</p>
<p>（2）不能创建新的顶层类型。也就是说，只能对<code>a.ts</code>模块中已经存在的类型进行扩展，不允许增加新的顶层类型，比如新定义一个接口<code>B</code>。</p>
<p>（3）不能对默认的<code>default</code>接口进行扩展，只能对 export 命令输出的命名接口进行扩充。这是因为在进行类型扩展时，需要依赖输出的接口名。</p>
<p>某些第三方模块，原始作者没有提供接口类型，这时可以在自己的脚本顶部加上下面一行命令。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;模块名&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;hot-new-module&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>加上上面的命令以后，外部模块即使没有类型声明，也可以通过编译。但是，从该模块输入的所有接口都将为<code>any</code>类型。</p>
<p>declare module 描述的模块名可以使用通配符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;my-plugin-*&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">PluginOptions</span> &#123;</span><br><span class="line">    <span class="attr">enabled</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">priority</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params">options: PluginOptions</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="keyword">export</span> = initialize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，模块名<code>my-plugin-*</code>表示适配所有以<code>my-plugin-</code>开头的模块名（比如<code>my-plugin-logger</code>）。</p>
<h2 id="declare-global"><a href="#declare-global" class="headerlink" title="declare global"></a>declare global</h2><p>如果要为 JavaScript 引擎的原生对象添加属性和方法，可以使用<code>declare global &#123;&#125;</code>语法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">toSmallString</span>(): <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toSmallString</span> = ():<span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 具体实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，为 JavaScript 原生的<code>String</code>对象添加了<code>toSmallString()</code>方法。declare global 给出这个新增方法的类型描述。</p>
<p>这个示例第一行的空导出语句<code>export &#123;&#125;</code>，作用是强制编译器将这个脚本当作模块处理。这是因为<code>declare global</code>必须用在模块里面。</p>
<p>下面的示例是为 window 对象添加一个属性<code>myAppConfig</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> window &#123;</span><br><span class="line">    <span class="attr">myAppConfig</span>:<span class="built_in">object</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="variable language_">window</span>.<span class="property">myAppConfig</span>;</span><br></pre></td></tr></table></figure>

<p>declare global 只能扩充现有对象的类型描述，不能增加新的顶层类型。</p>
<h2 id="declare-enum"><a href="#declare-enum" class="headerlink" title="declare enum"></a>declare enum</h2><p>declare 关键字给出 enum 类型描述的例子如下，下面的写法都是允许的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="variable constant_">E1</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="variable constant_">E2</span> &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">E3</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">E4</span> &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="declare-module-用于类型声明文件"><a href="#declare-module-用于类型声明文件" class="headerlink" title="declare module 用于类型声明文件"></a>declare module 用于类型声明文件</h2><p>我们可以为每个模块脚本，定义一个<code>.d.ts</code>文件，把该脚本用到的类型定义都放在这个文件里面。但是，更方便的做法是为整个项目，定义一个大的<code>.d.ts</code>文件，在这个文件里面使用<code>declare module</code>定义每个模块脚本的类型。</p>
<p>下面的示例是<code>node.d.ts</code>文件的一部分。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;url&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">    protocol?: <span class="built_in">string</span>;</span><br><span class="line">    hostname?: <span class="built_in">string</span>;</span><br><span class="line">    pathname?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params"></span></span><br><span class="line"><span class="params">    urlStr: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    parseQueryString?,</span></span><br><span class="line"><span class="params">    slashesDenoteHost?</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Url</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;path&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">sep</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>url</code>和<code>path</code>都是单独的模块脚本，但是它们的类型都定义在<code>node.d.ts</code>这个文件里面。</p>
<p>使用时，自己的脚本使用三斜杠命令，加载这个类型声明文件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果没有上面这一行命令，自己的脚本使用外部模块时，就需要在脚本里面使用 declare 命令单独给出外部模块的类型。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://timmousk.com/blog/typescript-declare/">How Does The Declare Keyword Work In TypeScript?</a>, Tim Mouskhelichvili</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-declare/" data-id="clm609r30000ot4wlex4j0npc" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-enum" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-enum/">TypeScript 的 Enum 类型</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-enum/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><p>Enum 是 TypeScript 新增的一种数据结构和类型，中文译为“枚举”。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>实际开发中，经常需要定义一组相关的常量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RED</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">GREEN</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BLUE</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> color = <span class="title function_">userInput</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (color === <span class="variable constant_">RED</span>) &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (color === <span class="variable constant_">GREEN</span>) &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (color === <span class="variable constant_">BLUE</span>) &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong color&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，常量<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>是相关的，意为变量<code>color</code>的三个可能的取值。它们具体等于什么值其实并不重要，只要不相等就可以了。</p>
<p>TypeScript 就设计了 Enum 结构，用来将相关常量放在一个容器里面，方便使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,     <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span>,   <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Blue</span>     <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个 Enum 结构<code>Color</code>，里面包含三个成员<code>Red</code>、<code>Green</code>和<code>Blue</code>。第一个成员的值默认为整数<code>0</code>，第二个为<code>1</code>，第三个为<code>2</code>，以此类推。</p>
<p>使用时，调用 Enum 的某个成员，与调用对象属性的写法一样，可以使用点运算符，也可以使用方括号运算符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Color</span>[<span class="string">&#x27;Green&#x27;</span>]; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>Enum 结构本身也是一种类型。比如，上例的变量<code>c</code>等于<code>1</code>，它的类型可以是 Color，也可以是<code>number</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:<span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:<span class="built_in">number</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>c</code>的类型写成<code>Color</code>或<code>number</code>都可以。但是，<code>Color</code>类型的语义更好。</p>
<p>Enum 结构的特别之处在于，它既是一种类型，也是一个值。绝大多数 TypeScript 语法都是类型语法，编译后会全部去除，但是 Enum 结构是一个值，编译后会变成 JavaScript 对象，留在代码中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,     <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span>,   <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Blue</span>     <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Color</span> = &#123;</span><br><span class="line">  <span class="title class_">Red</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Blue</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例是 Enum 结构编译前后的对比。</p>
<p>由于 TypeScript 的定位是 JavaScript 语言的类型增强，所以官方建议谨慎使用 Enum 结构，因为它不仅仅是类型，还会为编译后的代码加入一个对象。</p>
<p>Enum 结构比较适合的场景是，成员的值不重要，名字更重要，从而增加代码的可读性和可维护性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">  <span class="variable constant_">ADD</span>,</span><br><span class="line">  <span class="variable constant_">DIV</span>,</span><br><span class="line">  <span class="variable constant_">MUL</span>,</span><br><span class="line">  <span class="variable constant_">SUB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compute</span>(<span class="params"></span></span><br><span class="line"><span class="params">  op:Operator,</span></span><br><span class="line"><span class="params">  a:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  b:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">ADD</span>:</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">DIV</span>:</span><br><span class="line">      <span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">MUL</span>:</span><br><span class="line">      <span class="keyword">return</span> a * b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">SUB</span>:</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong operator&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">compute</span>(<span class="title class_">Operator</span>.<span class="property">ADD</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 结构<code>Operator</code>的四个成员表示四则运算“加减乘除”。代码根本不需要用到这四个成员的值，只用成员名就够了。</p>
<p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#enum-overhaul">TypeScript 5.0</a> 之前，Enum 有一个 Bug，就是 Enum 类型的变量可以赋值为任何数值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Bool</span> &#123;</span><br><span class="line">  <span class="title class_">No</span>,</span><br><span class="line">  <span class="title class_">Yes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">noYes:Bool</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">33</span>);  <span class="comment">// TypeScript 5.0 之前不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>foo</code>的参数<code>noYes</code>是 Enum 类型，只有两个可用的值。但是，TypeScript 5.0 之前，任何数值作为函数<code>foo</code>的参数，编译都不会报错，TypeScript 5.0 纠正了这个问题。</p>
<p>另外，由于 Enum 结构编译后是一个对象，所以不能有与它同名的变量（包括对象、函数、类等）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Color</span> = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例，Enum 结构与变量同名，导致报错。</p>
<p>很大程度上，Enum 结构可以被对象的<code>as const</code>断言替代。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">A</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">B</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">C</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x === <span class="title class_">Foo</span>.<span class="property">A</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="title class_">Bar</span>.<span class="property">A</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>Bar</code>使用了<code>as const</code>断言，作用就是使得它的属性无法修改。这样的话，<code>Foo</code>和<code>Bar</code>的行为就很类似了，前者完全可以用后者替代，而且后者还是 JavaScript 的原生数据结构。</p>
<h2 id="Enum-成员的值"><a href="#Enum-成员的值" class="headerlink" title="Enum 成员的值"></a>Enum 成员的值</h2><p>Enum 成员默认不必赋值，系统会从零开始逐一递增，按照顺序为每个成员赋值，比如0、1、2……</p>
<p>但是，也可以为 Enum 成员显式赋值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 每个成员的值都是显式赋值。</p>
<p>成员的值可以是任意数值，但不能是大整数（Bigint）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">90</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">0.5</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">7n</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 成员的值可以是小数，但不能是 Bigint。</p>
<p>成员的值甚至可以相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只设定第一个成员的值，后面成员的值就会从这个值开始递增。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">Green</span>,  <span class="comment">// 8</span></span><br><span class="line">  <span class="title class_">Blue</span>   <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>, <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">Blue</span> <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum 成员的值也可以使用计算式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Permission</span> &#123;</span><br><span class="line">  <span class="title class_">UserRead</span>     = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">  <span class="title class_">UserWrite</span>    = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">UserExecute</span>  = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">  <span class="title class_">GroupRead</span>    = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  <span class="title class_">GroupWrite</span>   = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">  <span class="title class_">GroupExecute</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  <span class="title class_">AllRead</span>      = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">AllWrite</span>     = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">AllExecute</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Bool</span> &#123;</span><br><span class="line">  <span class="title class_">No</span> = <span class="number">123</span>,</span><br><span class="line">  <span class="title class_">Yes</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 成员的值等于一个计算式，或者等于函数的返回值，都是正确的。</p>
<p>Enum 成员值都是只读的，不能重新赋值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Color</span>.<span class="property">Red</span> = <span class="number">4</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，重新为 Enum 成员赋值就会报错。</p>
<p>为了让这一点更醒目，通常会在 enum 关键字前面加上<code>const</code>修饰，表示这是常量，不能再次赋值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上<code>const</code>还有一个好处，就是编译为 JavaScript 代码后，代码中 Enum 成员会被替换成对应的值，这样能提高性能表现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="title class_">Color</span>.<span class="property">Blue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">0</span> <span class="comment">/* Color.Red */</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">1</span> <span class="comment">/* Color.Green */</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="number">2</span> <span class="comment">/* Color.Blue */</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于 Enum 结构前面加了<code>const</code>关键字，所以编译产物里面就没有生成对应的对象，而是把所有 Enum 成员出现的场合，都替换成对应的常量。</p>
<p>如果希望加上<code>const</code>关键词后，运行时还能访问 Enum 结构（即编译后依然将 Enum 转成对象），需要在编译时打开<code>preserveConstEnums</code>编译选项。</p>
<h2 id="同名-Enum-的合并"><a href="#同名-Enum-的合并" class="headerlink" title="同名 Enum 的合并"></a>同名 Enum 的合并</h2><p>多个同名的 Enum 结构会自动合并。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  C = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B = <span class="number">1</span>，</span><br><span class="line">  C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Foo</code>分成三段定义，系统会自动把它们合并。</p>
<p>Enum 结构合并时，只允许其中一个的首成员省略初始值，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  B, <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Foo</code>的两段定义的第一个成员，都没有设置初始值，导致报错。</p>
<p>同名 Enum 合并时，不能有同名成员，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  B = <span class="number">1</span>, <span class="comment">// 报错</span></span><br><span class="line">  C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Foo</code>的两段定义有一个同名成员<code>B</code>，导致报错。</p>
<p>同名 Enum 合并的另一个限制是，所有定义必须同为 const 枚举或者非 const 枚举，不允许混合使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> E &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> E &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> E &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同名 Enum 的合并，最大用处就是补充外部定义的 Enum 结构。</p>
<h2 id="字符串-Enum"><a href="#字符串-Enum" class="headerlink" title="字符串 Enum"></a>字符串 Enum</h2><p>Enum 成员的值除了设为数值，还可以设为字符串。也就是说，Enum 也可以用作一组相关字符串的集合。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&#x27;RIGHT&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Direction</code>就是字符串枚举，每个成员的值都是字符串。</p>
<p>注意，字符串枚举的所有成员值，都必须显式设置。如果没有设置，成员值默认为数值，且位置必须在字符串成员之前。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A, <span class="comment">// 0</span></span><br><span class="line">  B = <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  C <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>之前没有其他成员，所以可以不设置初始值，默认等于<code>0</code>；<code>C</code>之前有一个字符串成员，所以<code>C</code>必须有初始值，不赋值就报错了。</p>
<p>Enum 成员可以是字符串和数值混合赋值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">  <span class="title class_">Three</span> = <span class="number">3</span>,</span><br><span class="line">  <span class="title class_">Four</span> = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了数值和字符串，Enum 成员不允许使用其他值（比如 Symbol 值）。</p>
<p>变量类型如果是字符串 Enum，就不能再赋值为字符串，这跟数值 Enum 不一样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">MyEnum</span>.<span class="property">One</span>;</span><br><span class="line">s = <span class="string">&#x27;One&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s</code>的类型是<code>MyEnum</code>，再赋值为字符串就报错。</p>
<p>由于这个原因，如果函数的参数类型是字符串 Enum，传参时就不能直接传入字符串，而要传入 Enum 成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg:MyEnum</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;arg is &#x27;</span> + arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;One&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数类型是<code>MyEnum</code>，直接传入字符串会报错。</p>
<p>所以，字符串 Enum 作为一种类型，有限定函数参数的作用。</p>
<p>前面说过，数值 Enum 的成员值往往不重要。但是有些场合，开发者可能希望 Enum 成员值可以保存一些有用的信息，所以 TypeScript 才设计了字符串 Enum。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">MediaTypes</span> &#123;</span><br><span class="line">  <span class="title class_">JSON</span> = <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">XML</span> = <span class="string">&#x27;application/xml&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="title class_">Accept</span>: <span class="title class_">MediaTypes</span>.<span class="property">JSON</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fetch()</code>的参数对象的属性<code>Accept</code>，只能接受一些指定的字符串。这时就很适合把字符串放进一个 Enum 结构，通过成员值来引用这些字符串。</p>
<p>字符串 Enum 可以使用联合类型（union）代替。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"></span></span><br><span class="line"><span class="params">  where:<span class="string">&#x27;Up&#x27;</span>|<span class="string">&#x27;Down&#x27;</span>|<span class="string">&#x27;Left&#x27;</span>|<span class="string">&#x27;Right&#x27;</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数参数<code>where</code>属于联合类型，效果跟指定为字符串 Enum 是一样的。</p>
<p>注意，字符串 Enum 的成员值，不能使用表达式赋值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">  B = [<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，成员<code>B</code>的值是一个字符串表达式，导致报错。</p>
<h2 id="keyof-运算符"><a href="#keyof-运算符" class="headerlink" title="keyof 运算符"></a>keyof 运算符</h2><p>keyof 运算符可以取出 Enum 结构的所有成员名，作为联合类型返回。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;A&#x27;|&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="keyword">typeof</span> <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>keyof typeof MyEnum</code>可以取出<code>MyEnum</code>的所有成员名，所以类型<code>Foo</code>等同于联合类型<code>&#39;A&#39;|&#39;B&#39;</code>。</p>
<p>注意，这里的<code>typeof</code>是必需的，否则<code>keyof MyEnum</code>相当于<code>keyof number</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="title class_">MyEnum</span>;</span><br><span class="line"><span class="comment">// &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; |</span></span><br><span class="line"><span class="comment">// &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Foo</code>等于类型<code>number</code>的所有原生属性名组成的联合类型。</p>
<p>这是因为 Enum 作为类型，本质上属于<code>number</code>或<code>string</code>的一种变体，而<code>typeof MyEnum</code>会将<code>MyEnum</code>当作一个值处理，从而先其转为对象类型，就可以再用<code>keyof</code>运算符返回该对象的所有属性名。</p>
<p>如果要返回 Enum 所有的成员值，可以使用<code>in</code>运算符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; a: any, b: any &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123; [key <span class="keyword">in</span> <span class="title class_">MyEnum</span>]: <span class="built_in">any</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，采用属性索引可以取出<code>MyEnum</code>的所有成员值。</p>
<h2 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h2><p>数值 Enum 存在反向映射，即可以通过成员值获得成员名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekdays</span> &#123;</span><br><span class="line">  <span class="title class_">Monday</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Tuesday</span>,</span><br><span class="line">  <span class="title class_">Wednesday</span>,</span><br><span class="line">  <span class="title class_">Thursday</span>,</span><br><span class="line">  <span class="title class_">Friday</span>,</span><br><span class="line">  <span class="title class_">Saturday</span>,</span><br><span class="line">  <span class="title class_">Sunday</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Weekdays</span>[<span class="number">3</span>]) <span class="comment">// Wednesday</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 成员<code>Wednesday</code>的值等于3，从而可以从成员值<code>3</code>取到对应的成员名<code>Wednesday</code>，这就叫反向映射。</p>
<p>这是因为 TypeScript 会将上面的 Enum 结构，编译成下面的 JavaScript 代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Weekdays</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Weekdays</span>) &#123;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Tuesday&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Wednesday&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Thursday&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Friday&quot;</span>] = <span class="number">5</span>] = <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Saturday&quot;</span>] = <span class="number">6</span>] = <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Sunday&quot;</span>] = <span class="number">7</span>] = <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Weekdays</span> || (<span class="title class_">Weekdays</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>上面代码中，实际进行了两组赋值，以第一个成员为例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Weekdays</span>[</span><br><span class="line">  <span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span></span><br><span class="line">] = <span class="string">&quot;Monday&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码有两个赋值运算符（<code>=</code>），实际上等同于下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Weekdays</span>[<span class="number">1</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这种情况只发生在数值 Enum，对于字符串 Enum，不存在反向映射。这是因为字符串 Enum 编译后只有一组赋值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyEnum</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">MyEnum</span>) &#123;</span><br><span class="line">    <span class="title class_">MyEnum</span>[<span class="string">&quot;A&quot;</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="title class_">MyEnum</span>[<span class="string">&quot;B&quot;</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">MyEnum</span> || (<span class="title class_">MyEnum</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-enum/" data-id="clm609r31000rt4wlaoh2giu0" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>没有梦想的程序员 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="没有梦想的程序员"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/TS%E6%95%99%E7%A8%8B">TS教程</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
      <li class="nav-item">
        <div id="translate"></div>
      </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

<!--添加多语言翻译效果-->
<script src="https://res.zvo.cn/translate/translate.js"></script>
<script>
  translate.setUseVersion2(); //设置使用v2.x 版本
  translate.language.setLocal('chinese_simplified'); //设置本地语种（当前网页的语种）。如果不设置，默认自动识别当前网页显示文字的语种。 可填写如 'english'、'chinese_simplified' 等，具体参见文档下方关于此的说明。
  translate.execute();//进行翻译
</script>
</html>