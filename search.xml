<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/05/hello-world/</url>
    <content><![CDATA[<div id="readmore-container"><p>欢迎来到我的博客,将会在此记录一些有趣的事！</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
  </entry>
  <entry>
    <title>TypeScript 的数组类型</title>
    <url>/2023/09/05/ts-array/</url>
    <content><![CDATA[<div id="readmore-container"><p>JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple）。</p>
<p>本章介绍数组，下一章介绍元组。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。</p>
<p>数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>的类型是<code>number[]</code>，其中<code>number</code>表示数组成员类型是<code>number</code>。</p>
<p>如果数组成员的类型比较复杂，可以写在圆括号里面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:(<span class="built_in">number</span>|<span class="built_in">string</span>)[];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>的成员类型是<code>number|string</code>。</p>
<p>这个例子里面的圆括号是必须的，否则因为竖杠<code>|</code>的优先级低于<code>[]</code>，TypeScript 会把<code>number|string[]</code>理解成<code>number</code>和<code>string[]</code>的联合类型。</p>
<p>如果数组成员可以是任意类型，写成<code>any[]</code>。当然，这种写法是应该避免的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">any</span>[];</span><br></pre></td></tr></table></figure>

<p>数组类型的第二种写法是使用 TypeScript 内置的 Array 接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>的类型是<code>Array&lt;number&gt;</code>，其中<code>number</code>表示成员类型是<code>number</code>。</p>
<p>这种写法对于成员类型比较复杂的数组，代码可读性会稍微好一些。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>|<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这种写法本质上属于泛型，这里只要知道怎么写就可以了，详细解释参见《泛型》一章。另外，数组类型还有第三种写法，因为很少用到，本章就省略了，详见《interface 接口》一章。</p>
<p>数组类型声明了以后，成员数量是不限制的，任意数量的成员都可以，也可以是空数组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[];</span><br><span class="line">arr = [];</span><br><span class="line">arr = [<span class="number">1</span>];</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>无论有多少个成员，都是正确的。</p>
<p>这种规定的隐藏含义就是，数组的成员是可以动态变化的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">arr <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，数组增加成员或减少成员，都是可以的。</p>
<p>正是由于成员数量可以动态变化，所以  TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> foo = arr[<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>的值是一个不存在的数组成员，TypeScript 并不会报错。</p>
<p>TypeScript 允许使用方括号读取数组成员的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="number">0</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Names</code>是字符串数组，那么<code>Names[0]</code>返回的类型就是<code>string</code>。</p>
<p>由于数组成员的索引类型都是<code>number</code>，所以读取成员类型也可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="built_in">number</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Names[number]</code>表示数组<code>Names</code>所有数值索引的成员类型，所以返回<code>string</code>。</p>
<h2 id="数组的类型推断"><a href="#数组的类型推断" class="headerlink" title="数组的类型推断"></a>数组的类型推断</h2><p>如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。这时，推断行为会因为值的不同，而有所不同。</p>
<p>如果变量的初始值是空数组，那么  TypeScript 会推断数组类型是<code>any[]</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推断为 any[]</span></span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br></pre></td></tr></table></figure>

<p>后面，为这个数组赋值时，TypeScript 会自动更新类型推断。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">arr <span class="comment">// 推断为 any[]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">123</span>);</span><br><span class="line">arr <span class="comment">// 推断类型为 number[]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr <span class="comment">// 推断类型为 (string|number)[]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，数组变量<code>arr</code>的初始值是空数组，然后随着新成员的加入，TypeScript 会自动修改推断的数组类型。</p>
<p>但是，类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推断类型为 number[]</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">123</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，数组变量<code>arr</code>的初始值是<code>[123]</code>，TypeScript 就推断成员类型为<code>number</code>。新成员如果不是这个类型，TypeScript 就会报错，而不会更新类型推断。</p>
<h2 id="只读数组，const-断言"><a href="#只读数组，const-断言" class="headerlink" title="只读数组，const 断言"></a>只读数组，const 断言</h2><p>JavaScript 规定，<code>const</code>命令声明的数组变量是可以改变成员的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，修改<code>const</code>命令声明的数组的成员是允许的。</p>
<p>但是，很多时候确实有声明为只读数组的需求，即不允许变动数组成员。</p>
<p>TypeScript 允许声明只读数组，方法是在数组类型前面加上<code>readonly</code>关键字。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">3</span>); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>arr</code>是一个只读数组，删除、修改、新增数组成员都会报错。</p>
<p>TypeScript 将<code>readonly number[]</code>与<code>number[]</code>视为两种不一样的类型，后者是前者的子类型。</p>
<p>这是因为只读数组没有<code>pop()</code>、<code>push()</code>之类会改变原数组的方法，所以<code>number[]</code>的方法数量要多于<code>readonly number[]</code>，这意味着<code>number[]</code>其实是<code>readonly number[]</code>的子类型。</p>
<p>我们知道，子类型继承了父类型的所有特征，并加上了自己的特征，所以子类型<code>number[]</code>可以用于所有使用父类型的场合，反过来就不行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a1</span>:<span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = a1; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">a1 = a2; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，子类型<code>number[]</code>可以赋值给父类型<code>readonly number[]</code>，但是反过来就会报错。</p>
<p>由于只读数组是数组的父类型，所以它不能代替数组。这一点很容易产生令人困惑的报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">s:<span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSum</span>(arr) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>getSum()</code>的参数<code>s</code>是一个数组，传入只读数组就会报错。原因就是只读数组是数组的父类型，父类型不能替代子类型。这个问题的解决方法是使用类型断言<code>getSum(arr as number[])</code>，详见《类型断言》一章。</p>
<p>注意，<code>readonly</code>关键字不能与数组的泛型写法一起使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>readonly</code>与数组的泛型写法一起使用，就会报错。</p>
<p>实际上，TypeScript 提供了两个专门的泛型，用来生成只读数组的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a1</span>:<span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a2</span>:<span class="title class_">Readonly</span>&lt;<span class="built_in">number</span>[]&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，泛型<code>ReadonlyArray&lt;T&gt;</code>和<code>Readonly&lt;T[]&gt;</code>都可以用来生成只读数组类型。两者尖括号里面的写法不一样，<code>Readonly&lt;T[]&gt;</code>的尖括号里面是整个数组（<code>number[]</code>），而<code>ReadonlyArray&lt;T&gt;</code>的尖括号里面是数组成员（<code>number</code>）。</p>
<p>只读数组还有一种声明方法，就是使用“const 断言”。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = [<span class="number">2</span>]; <span class="comment">// 报错 </span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>as const</code>告诉 TypeScript，推断类型时要把变量<code>arr</code>推断为只读数组，从而使得数组成员无法改变。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>TypeScript 使用<code>T[][]</code>的形式，表示二维数组，<code>T</code>是最底层数组成员的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">multi</span>:<span class="built_in">number</span>[][] =</span><br><span class="line">  [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>]];</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>multi</code>的类型是<code>number[][]</code>，表示它是一个二维数组，最底层的数组成员类型是<code>number</code>。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的类型断言</title>
    <url>/2023/09/05/ts-assert/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于没有类型声明的值，TypeScript 会进行类型推断，很多时候得到的结果，未必是开发者想要的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错，原因是 TypeScript 推断变量<code>foo</code>的类型是<code>string</code>，而变量<code>bar</code>的类型是<code>&#39;a&#39;|&#39;b&#39;|&#39;c&#39;</code>，前者是后者的父类型。父类型不能赋值给子类型，所以就报错了。</p>
<p>TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。</p>
<p>这种做法的实质是，允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。</p>
<p>回到上面的例子，解决方法就是进行类型断言，在赋值时断言变量<code>foo</code>的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo <span class="keyword">as</span> T; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行的<code>foo as T</code>表示告诉编译器，变量<code>foo</code>的类型断言为<code>T</code>，所以这一行不再需要类型推断了，编译器直接把<code>foo</code>的类型当作<code>T</code>，就不会报错了。</p>
<p>总之，类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。</p>
<p>类型断言有两种语法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法一：&lt;类型&gt;值</span></span><br><span class="line">&lt;<span class="title class_">Type</span>&gt;value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法二：值 as 类型</span></span><br><span class="line">value <span class="keyword">as</span> <span class="title class_">Type</span></span><br></pre></td></tr></table></figure>

<p>上面两种语法是等价的，<code>value</code>表示值，<code>Type</code>表示类型。早期只有语法一，后来因为 TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突，就引入了语法二。目前，推荐使用语法二。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = &lt;T&gt;foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法二</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo <span class="keyword">as</span> T;</span><br></pre></td></tr></table></figure>

<p>上面示例是两种类型断言的语法，其中的语法一因为跟 JSX 语法冲突，使用时必须关闭 TypeScript 的 React 支持，否则会无法识别。由于这个原因，现在一般都使用语法二。</p>
<p>下面看一个例子。《对象》一章提到过，对象类型有严格字面量检查，如果存在额外的属性会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，等号右侧是一个对象字面量，多出了属性<code>y</code>，导致报错。解决方法就是使用类型断言，可以用两种不同的断言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p0</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; =</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; =</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种类型断言都是正确的。第一种断言将类型改成与等号左边一致，第二种断言使得等号右边的类型是左边类型的子类型，子类型可以赋值给父类型，同时因为存在类型断言，就没有严格字面量检查了，所以不报错。</p>
<p>下面是一个网页编程的实际例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username) &#123;</span><br><span class="line">  (username <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>).<span class="property">value</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>username</code>的类型是<code>HTMLElement | null</code>，排除了<code>null</code>的情况以后，HTMLElement 类型是没有<code>value</code>属性的。如果<code>username</code>是一个输入框，那么就可以通过类型断言，将它的类型改成<code>HTMLInputElement</code>，就可以读取<code>value</code>属性。</p>
<p>注意，上例的类型断言的圆括号是必需的，否则<code>username</code>会被断言成<code>HTMLInputElement.value</code>，从而报错。</p>
<p>类型断言不应滥用，因为它改变了 TypeScript 的类型检查，很可能埋下错误的隐患。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">data</span>:<span class="built_in">object</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">data.<span class="property">length</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">(data <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;).<span class="property">length</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>data</code>是一个对象，没有<code>length</code>属性。但是通过类型断言，可以将它的类型断言为数组，这样使用<code>length</code>属性就能通过类型检查。但是，编译后的代码在运行时依然会报错，所以类型断言可以让错误的代码通过编译。</p>
<p>类型断言的一大用处是，指定 unknown 类型的变量的具体类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">value</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="built_in">string</span> = value; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="built_in">string</span> = value <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，unknown 类型的变量<code>value</code>不能直接赋值给其他类型的变量，但是可以将它断言为其他类型，这样就可以赋值给别的变量了。</p>
<p>另外，类型断言也适合指定联合类型的值的具体类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="built_in">number</span>|<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="built_in">number</span> = s1 <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s1</code>是联合类型，可以断言其为联合类型里面的一种具体类型，再将其赋值给变量<code>s2</code>。</p>
<h2 id="类型断言的条件"><a href="#类型断言的条件" class="headerlink" title="类型断言的条件"></a>类型断言的条件</h2><p>类型断言并不意味着，可以把某个值断言为任意类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>n</code>是数值，无法把它断言成字符串，TypeScript 会报错。</p>
<p>类型断言的使用前提是，值的实际类型与断言的类型必须满足一个条件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">expr <span class="keyword">as</span> T</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>expr</code>是实际的值，<code>T</code>是类型断言，它们必须满足下面的条件：<code>expr</code>是<code>T</code>的子类型，或者<code>T</code>是<code>expr</code>的子类型。</p>
<p>也就是说，类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。</p>
<p>但是，如果真的要断言成一个完全无关的类型，也是可以做到的。那就是连续进行两次类型断言，先断言成 unknown 类型或 any 类型，然后再断言为目标类型。因为<code>any</code>类型和<code>unknown</code>类型是所有其他类型的父类型，所以可以作为两种完全无关的类型的中介。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 或者写成 &lt;T&gt;&lt;unknown&gt;expr</span></span><br><span class="line">expr <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> T</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>expr</code>连续进行了两次类型断言，第一次断言为<code>unknown</code>类型，第二次断言为<code>T</code>类型。这样的话，<code>expr</code>就可以断言成任意类型<code>T</code>，而不报错。</p>
<p>下面是本小节开头那个例子的改写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，通过两次类型断言，变量<code>n</code>的类型就从数值，变成了完全无关的字符串，从而赋值时不会报错。</p>
<h2 id="as-const-断言"><a href="#as-const-断言" class="headerlink" title="as const 断言"></a>as const 断言</h2><p>如果没有声明变量类型，let 命令声明的变量，会被类型推断为 TypeScript 内置的基本类型之一；const 命令声明的变量，则被推断为值类型常量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型推断为基本类型 string</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断为字符串 “JavaScript”</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s1</code>的类型被推断为<code>string</code>，变量<code>s2</code>的类型推断为值类型<code>JavaScript</code>。后者是前者的子类型，相当于 const 命令有更强的限定作用，可以缩小变量的类型范围。</p>
<p>有些时候，let 变量会出现一些意想不到的报错，变更成 const 变量就能消除报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> =</span><br><span class="line">  |<span class="string">&#x27;JavaScript&#x27;</span></span><br><span class="line">  |<span class="string">&#x27;TypeScript&#x27;</span></span><br><span class="line">  |<span class="string">&#x27;Python&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setLang</span>(<span class="params">language:Lang</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setLang</span>(s); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错，原因是函数<code>setLang()</code>的参数<code>language</code>类型是<code>Lang</code>，这是一个联合类型。但是，传入的字符串<code>s</code>的类型被推断为<code>string</code>，属于<code>Lang</code>的父类型。父类型不能替代子类型，导致报错。</p>
<p>一种解决方法就是把 let 命令改成 const 命令。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这样的话，变量<code>s</code>的类型就是值类型<code>JavaScript</code>，它是联合类型<code>Lang</code>的子类型，传入函数<code>setLang()</code>就不会报错。</p>
<p>另一种解决方法是使用类型断言。TypeScript 提供了一种特殊的类型断言<code>as const</code>，用于告诉编译器，推断类型时，可以将这个值推断为常量，即把 let 变量断言为 const 变量，从而把内置的基本类型变更为值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="title function_">setLang</span>(s);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s</code>虽然是用 let 命令声明的，但是使用了<code>as const</code>断言以后，就等同于是用 const 命令声明的，变量<code>s</code>的类型会被推断为值类型<code>JavaScript</code>。</p>
<p>使用了<code>as const</code>断言以后，let 变量就不能再改变值了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">s = <span class="string">&#x27;Python&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，let 命令声明的变量<code>s</code>，使用<code>as const</code>断言以后，就不能改变值了，否则报错。</p>
<p>注意，<code>as const</code>断言只能用于字面量，不能用于变量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="title function_">setLang</span>(s <span class="keyword">as</span> <span class="keyword">const</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>as const</code>断言用于变量<code>s</code>，就报错了。下面的写法可以更清晰地看出这一点。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1 <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>as const</code>也不能用于表达式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = (<span class="string">&#x27;Java&#x27;</span> + <span class="string">&#x27;Script&#x27;</span>) <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>as const</code>用于表达式，导致报错。</p>
<p><code>as const</code>也可以写成前置的形式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后置形式</span></span><br><span class="line">expr <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置形式</span></span><br><span class="line">&lt;<span class="keyword">const</span>&gt;expr</span><br></pre></td></tr></table></figure>

<p><code>as const</code>断言可以用于整个对象，也可以用于对象的单个属性，这时它的类型缩小效果是不一样的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: number; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: 1; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型是 &#123; readonly x: 1; readonly y: 2; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第二种写法是对属性<code>x</code>缩小类型，第三种写法是对整个对象缩小类型。</p>
<p>总之，<code>as const</code>会将字面量的类型断言为不可变类型，缩小成 TypeScript 允许的最小类型。</p>
<p>下面是数组的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a1 的类型推断为 number[]</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a2 的类型推断为 readonly [1, 2, 3]</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组字面量使用<code>as const</code>断言后，类型推断就变成了只读元组。</p>
<p>由于<code>as const</code>会将数组变成只读元组，所以很适合用于函数的 rest 参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>nums</code>的类型推断为<code>number[]</code>，导致使用扩展运算符<code>...</code>传入函数<code>add()</code>会报错，因为<code>add()</code>只能接受两个参数，而<code>...nums</code>并不能保证参数的个数。</p>
<p>事实上，对于固定参数个数的函数，如果传入的参数包含扩展运算符，那么扩展运算符只能用于元组。只有当函数定义使用了 rest 参数，扩展运算符才能用于数组。</p>
<p>解决方法就是使用<code>as const</code>断言，将数组变成元组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，使用<code>as const</code>断言后，变量<code>nums</code>的类型会被推断为<code>readonly [1, 2]</code>，使用扩展运算符展开后，正好符合函数<code>add()</code>的参数类型。</p>
<p>Enum 成员也可以使用<code>as const</code>断言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  X,</span><br><span class="line">  Y,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> e1 = <span class="title class_">Foo</span>.<span class="property">X</span>;            <span class="comment">// Foo</span></span><br><span class="line"><span class="keyword">let</span> e2 = <span class="title class_">Foo</span>.<span class="property">X</span> <span class="keyword">as</span> <span class="keyword">const</span>;   <span class="comment">// Foo.X</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，如果不使用<code>as const</code>断言，变量<code>e1</code>的类型被推断为整个 Enum 类型；使用了<code>as const</code>断言以后，变量<code>e2</code>的类型被推断为 Enum 的某个成员，这意味着它不能变更为其他成员。</p>
<h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><p>对于那些可能为空的变量（即可能等于<code>undefined</code>或<code>null</code>），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号<code>!</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?:<span class="built_in">number</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="title function_">validateNumber</span>(x); <span class="comment">// 自定义函数，确保 x 是数值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x!.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateNumber</span>(<span class="params">e?:<span class="built_in">number</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> e !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>的参数<code>x</code>的类型是<code>number|null</code>，即可能为空。如果为空，就不存在<code>x.toFixed()</code>方法，这样写会报错。但是，开发者可以确认，经过<code>validateNumber()</code>的前置检验，变量<code>x</code>肯定不会为空，这时就可以使用非空断言，为函数体内部的变量<code>x</code>加上后缀<code>!</code>，<code>x!.toFixed()</code>编译就不会报错了。</p>
<p>非空断言在实际编程中很有用，有时可以省去一些额外的判断。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getElementById()</code>有可能返回空值<code>null</code>，即变量<code>root</code>可能为空，这时对它调用<code>addEventListener()</code>方法就会报错，通不过编译。但是，开发者如果可以确认<code>root</code>元素肯定会在网页中存在，这时就可以使用非空断言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getElementById()</code>方法加上后缀<code>!</code>，表示这个方法肯定返回非空结果。</p>
<p>不过，非空断言会造成安全隐患，只有在确定一个表达式的值不为空时才能使用。比较保险的做法还是手动检查一下是否为空。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unable to find DOM element #root&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果<code>root</code>为空会抛错，比非空断言更保险一点。</p>
<p>非空断言还可以用于赋值断言。TypeScript 有一个编译设置，要求类的属性必须初始化（即有初始值），如果不对属性赋值就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>和<code>y</code>会报错，因为 TypeScript 认为它们没有初始化。</p>
<p>这时就可以使用非空断言，表示这两个属性肯定会有值，这样就不会报错了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!:<span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line">  y!:<span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，非空断言只有在打开编译选项<code>strictNullChecks</code>时才有意义。如果不打开这个选项，编译器就不会检查某个变量是否可能为<code>undefined</code>或<code>null</code>。</p>
<h2 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h2><p>断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isString()</code>就是一个断言函数，用来保证参数<code>value</code>是一个字符串，否则就会抛出错误，中断程序的执行。</p>
<p>下面是它的用法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toUpper</span>(<span class="params">x: <span class="built_in">string</span>|<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="title function_">isString</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>toUpper()</code>的参数<code>x</code>，可能是字符串，也可能是数值。但是，函数体的最后一行调用<code>toUpperCase()</code>方法，必须保证<code>x</code>是字符串，否则报错。所以，这一行前面调用断言函数<code>isString()</code>，调用以后 TypeScript 就能确定，变量<code>x</code>一定是字符串，不是数值，也就不报错了。</p>
<p>传统的断言函数<code>isString()</code>的写法有一个缺点，它的参数类型是<code>unknown</code>，返回值类型是<code>void</code>（即没有返回值）。单单从这样的类型声明，很难看出<code>isString()</code>是一个断言函数。</p>
<p>为了更清晰地表达断言函数，TypeScript 3.7 引入了新的类型写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isString()</code>的返回值类型写成<code>asserts value is string</code>，其中<code>asserts</code>和<code>is</code>都是关键词，<code>value</code>是函数的参数名，<code>string</code>是函数参数的预期类型。它的意思是，该函数用来断言参数<code>value</code>的类型是<code>string</code>，如果达不到要求，程序就会在这里中断。</p>
<p>使用了断言函数的新写法以后，TypeScript 就会自动识别，只要执行了该函数，对应的变量都为断言的类型。</p>
<p>注意，函数返回值的断言写法，只是用来更清晰地表达函数意图，真正的检查是需要开发者自己部署的。而且，如果内部的检查与断言不一致，TypeScript 也不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数的断言是参数<code>value</code>类型为字符串，但是实际上，内部检查的却是它是否为数值，如果不是就抛错。这段代码能够正常通过编译，表示 TypeScript 并不会检查断言与实际的类型检查是否一致。</p>
<p>另外，断言函数的<code>asserts</code>语句等同于<code>void</code>类型，所以如果返回除了<code>undefined</code>和<code>null</code>以外的值，都会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，断言函数返回了<code>true</code>，导致报错。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AccessLevel</span> = <span class="string">&#x27;r&#x27;</span> | <span class="string">&#x27;w&#x27;</span> | <span class="string">&#x27;rw&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">allowsReadAccess</span>(<span class="params"></span></span><br><span class="line"><span class="params">  level:AccessLevel</span></span><br><span class="line"><span class="params"></span>):asserts level is <span class="string">&#x27;r&#x27;</span> | <span class="string">&#x27;rw&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!level.<span class="title function_">includes</span>(<span class="string">&#x27;r&#x27;</span>))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Read not allowed&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>allowsReadAccess()</code>用来断言参数<code>level</code>一定等于<code>r</code>或<code>rw</code>。</p>
<p>如果要断言参数非空，可以使用工具类型<code>NonNullable&lt;T&gt;</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> assertIsDefined&lt;T&gt;(</span><br><span class="line">  <span class="attr">value</span>:T</span><br><span class="line">):asserts value is <span class="title class_">NonNullable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span> || value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not defined`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，工具类型<code>NonNullable&lt;T&gt;</code>对应类型<code>T</code>去除空类型后的剩余类型。</p>
<p>如果要将断言函数用于函数表达式，可以采用下面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> assertIsNumber = (</span><br><span class="line">  <span class="attr">value</span>:<span class="built_in">unknown</span></span><br><span class="line">):asserts value is <span class="built_in">number</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AssertIsNumber</span> =</span><br><span class="line">  <span class="function">(<span class="params">value:<span class="built_in">unknown</span></span>) =&gt;</span> asserts value is <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">assertIsNumber</span>:<span class="title class_">AssertIsNumber</span> = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，断言函数与类型保护函数（type guard）是两种不同的函数。它们的区别是，断言函数不返回值，而类型保护函数总是返回一个布尔值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">unknown</span></span></span><br><span class="line"><span class="params"></span>):value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例就是一个类型保护函数<code>isString()</code>，作用是检查参数<code>value</code>是否为字符串。如果是的，返回<code>true</code>，否则返回<code>false</code>。该函数的返回值类型是<code>value is string</code>，其中的<code>is</code>是一个类型运算符，如果左侧的值符合右侧的类型，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p>如果要断言某个参数保证为真（即不等于<code>false</code>、<code>undefined</code>和<code>null</code>），TypeScript 提供了断言函数的一种简写形式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">x:<span class="built_in">unknown</span></span>):asserts x &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>assert()</code>的断言部分，<code>asserts x</code>省略了谓语和宾语，表示参数<code>x</code>保证为真（<code>true</code>）。</p>
<p>同样的，参数为真的实际检查需要开发者自己实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">x:<span class="built_in">unknown</span></span>):asserts x &#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;x&#125;</span> should be a truthy value.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种断言函数的简写形式，通常用来检查某个操作是否成功。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  email?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadPerson</span>(<span class="params"></span>): <span class="title class_">Person</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">loadPerson</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params"></span></span><br><span class="line"><span class="params">  condition: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  message: <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):asserts condition &#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Person is not defined</span></span><br><span class="line"><span class="title function_">assert</span>(person, <span class="string">&#x27;Person is not defined&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，只有<code>loadPerson()</code>返回结果为真（即操作成功），<code>assert()</code>才不会报错。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://mariusschulz.com/blog/const-assertions-in-literal-expressions-in-typescript">Const Assertions in Literal Expressions in TypeScript</a>, Marius Schulz</li>
<li><a href="https://mariusschulz.com/blog/assertion-functions-in-typescript">Assertion Functions in TypeScript</a>, Marius Schulz</li>
<li><a href="https://blog.logrocket.com/assertion-functions-typescript/">Assertion functions in TypeScript</a>, Matteo Di Pirro</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>any 类型，unknown 类型，never 类型</title>
    <url>/2023/09/05/ts-any/</url>
    <content><![CDATA[<div id="readmore-container"><p>本章介绍 TypeScript 的三种特殊类型，它们可以作为学习 TypeScript 类型系统的起点。</p>
<h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><h3 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h3><p>any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>any</code>，就可以被赋值为任意类型的值。</p>
<p>变量类型一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>) <span class="comment">// 不报错</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="number">100</span>; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的值是一个字符串，但是把它当作函数调用，或者当作对象读取任意属性，TypeScript 编译时都不报错。原因就是<code>x</code>的类型是<code>any</code>，TypeScript 不对其进行类型检查。</p>
<p>由于这个原因，应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义。</p>
<p>实际开发中，<code>any</code>类型主要适用以下两个场合。</p>
<p>（1）出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为<code>any</code>。</p>
<p>（2）为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为<code>any</code>。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，这时你为那些类型复杂的变量加上<code>any</code>，TypeScript 编译时就不会报错。</p>
<p>总之，TypeScript 认为，只要开发者使用了<code>any</code>类型，就表示开发者想要自己来处理这些代码，所以就不对<code>any</code>类型进行任何限制，怎么使用都可以。</p>
<p>从集合论的角度看，<code>any</code>类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。</p>
<h3 id="类型推断问题"><a href="#类型推断问题" class="headerlink" title="类型推断问题"></a>类型推断问题</h3><p>对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>add()</code>的参数变量<code>x</code>和<code>y</code>，都没有足够的信息，TypeScript 无法推断出它们的类型，就会认为这两个变量和函数返回值的类型都是<code>any</code>。以至于后面就不再对函数<code>add()</code>进行类型检查了，怎么用都可以。</p>
<p>这显然是很糟糕的情况，所以对于那些类型不明显的变量，一定要显式声明类型，防止被推断为<code>any</code>。</p>
<p>TypeScript 提供了一个编译选项<code>noImplicitAny</code>，打开该选项，只要推断出<code>any</code>类型就会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --noImplicitAny app.ts</span><br></pre></td></tr></table></figure>

<p>上面命令使用了<code>noImplicitAny</code>编译选项进行编译，这时上面的函数<code>add()</code>就会报错。</p>
<p>这里有一个特殊情况，即使打开了<code>noImplicitAny</code>，使用<code>let</code>和<code>var</code>命令声明变量，但不赋值也不指定类型，是不会报错的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> y; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>和<code>y</code>声明时没有赋值，也没有指定类型，TypeScript 会推断它们的类型为<code>any</code>。这时即使打开了<code>noImplicitAny</code>，也不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line">x = &#123; <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型推断为<code>any</code>，但是不报错，可以顺利通过编译。</p>
<p>由于这个原因，建议使用<code>let</code>和<code>var</code>声明变量时，如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。</p>
<p><code>const</code>命令没有这个问题，因为 JavaScript 语言规定<code>const</code>声明变量时，必须同时进行初始化（赋值）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>const</code>命令声明的<code>x</code>是不能改变值的，声明时必须同时赋值，否则报错，所以它不存在类型推断为<code>any</code>的问题。</p>
<h3 id="污染问题"><a href="#污染问题" class="headerlink" title="污染问题"></a>污染问题</h3><p><code>any</code>类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 不报错</span></span><br><span class="line"></span><br><span class="line">y * <span class="number">123</span> <span class="comment">// 不报错</span></span><br><span class="line">y.<span class="title function_">toFixed</span>() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>any</code>，实际的值是一个字符串。变量<code>y</code>的类型是<code>number</code>，表示这是一个数值变量，但是它被赋值为<code>x</code>，这时并不会报错。然后，变量<code>y</code>继续进行各种数值运算，TypeScript 也检查不出错误，问题就这样留到运行时才会暴露。</p>
<p>污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用<code>any</code>类型的另一个主要原因。</p>
<h2 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a>unknown 类型</h2><p>为了解决<code>any</code>类型“污染”其他变量的问题，TypeScript 3.0 引入了<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type"><code>unknown</code>类型</a>。它与<code>any</code>含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像<code>any</code>那样自由，可以视为严格版的<code>any</code>。</p>
<p><code>unknown</code>跟<code>any</code>的相似之处，在于所有类型的值都可以分配给<code>unknown</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="number">42</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;Hello World&#x27;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>unknown</code>，可以赋值为各种类型的值。这与<code>any</code>的行为一致。</p>
<p><code>unknown</code>类型跟<code>any</code>类型的不同之处在于，它不能直接使用。主要有以下几个限制。</p>
<p>首先，<code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>:<span class="built_in">unknown</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">boolean</span> = v; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">number</span> = v; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>v</code>是<code>unknown</code>类型，赋值给<code>any</code>和<code>unknown</code>以外类型的变量都会报错，这就避免了污染问题，从而克服了<code>any</code>类型的一大缺点。</p>
<p>其次，不能直接调用<code>unknown</code>类型变量的方法和属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">unknown</span> = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">v1.<span class="property">foo</span>  <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">v2.<span class="title function_">trim</span>() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>:<span class="built_in">unknown</span> = <span class="function">(<span class="params">n = <span class="number">0</span></span>) =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="title function_">v3</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，直接调用<code>unknown</code>类型变量的属性和方法，或者直接当作函数执行，都会报错。</p>
<p>再次，<code>unknown</code>类型变量能够进行的运算是有限的，只能进行比较运算（运算符<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>）、取反运算（运算符<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符这几种，其他运算都会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a + <span class="number">1</span> <span class="comment">// 报错</span></span><br><span class="line">a === <span class="number">1</span> <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>unknown</code>类型的变量<code>a</code>进行加法运算会报错，因为这是不允许的运算。但是，进行比较运算就是可以的。</p>
<p>那么，怎么才能使用<code>unknown</code>类型变量呢？</p>
<p>答案是只有经过“类型缩小”，<code>unknown</code>类型变量才可以使用。所谓“类型缩小”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> r = a + <span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>unknown</code>类型的变量<code>a</code>经过<code>typeof</code>运算以后，能够确定实际类型是<code>number</code>，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">s</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> s === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  s.<span class="property">length</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，确定变量<code>s</code>的类型为字符串以后，才能调用它的<code>length</code>属性。</p>
<p>这样设计的目的是，只有明确<code>unknown</code>变量的实际类型，才允许使用它，防止像<code>any</code>那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。</p>
<p>总之，<code>unknown</code>可以看作是更安全的<code>any</code>。一般来说，凡是需要设为<code>any</code>类型的地方，通常都应该优先考虑设为<code>unknown</code>类型。</p>
<p>在集合论上，<code>unknown</code>也可以视为所有其他类型（除了<code>any</code>）的全集，所以它和<code>any</code>一样，也属于 TypeScript 的顶层类型。</p>
<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><p>为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了“空类型”的概念，即该类型为空，不包含任何值。</p>
<p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>never</code>，就不可能赋给它任何值，否则都会报错。</p>
<p><code>never</code>类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性，详见后面章节。另外，不可能返回值的函数，返回值的类型就可以写成<code>never</code>，详见《函数》一章。</p>
<p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span>|<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x; <span class="comment">// never 类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数变量<code>x</code>可能是字符串，也可能是数值，判断了这两种情况后，剩下的最后那个<code>else</code>分支里面，<code>x</code>就是<code>never</code>类型了。</p>
<p><code>never</code>类型的一个重要特点是，可以赋值给任意其他类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">number</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">string</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>:<span class="built_in">boolean</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>会抛出错误，所以返回值类型可以写成<code>never</code>，即不可能返回任何值。各种其他类型的变量都可以赋值为<code>f()</code>的运行结果（<code>never</code>类型）。</p>
<p>为什么<code>never</code>类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了<code>never</code>类型。因此，<code>never</code>类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottom type）。</p>
<p>总之，TypeScript 有两个“顶层类型”（<code>any</code>和<code>unknown</code>），但是“底层类型”只有<code>never</code>唯一一个。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 基本用法</title>
    <url>/2023/09/05/ts-basic/</url>
    <content><![CDATA[<div id="readmore-container"><p>本章介绍 TypeScript 的一些最基本的语法和用法。</p>
<h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><p>TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>的后面使用冒号，声明了它的类型为<code>string</code>。</p>
<p>类型声明的写法，一律为在标识符后面添加“冒号 + 类型”。函数参数和返回值，也是这样来声明类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num:<span class="built_in">number</span></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>toString()</code>的参数<code>num</code>的类型是<code>number</code>。参数列表的圆括号后面，声明了返回值的类型是<code>string</code>。更详细的介绍，参见《函数》一章。</p>
<p>注意，变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">string</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>的类型是字符串，但是赋值为数值<code>123</code>，TypeScript 就报错了。</p>
<p>另外，TypeScript 规定，变量只有赋值后才能使用，否则就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>没有赋值就被读取，导致报错。而 JavaScript 允许这种行为，不会报错，没有赋值的变量会返回<code>undefined</code>。</p>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>并没有类型声明，TypeScript 就会推断它的类型。由于它被赋值为一个数值，因此 TypeScript 推断它的类型为<code>number</code>。</p>
<p>后面，如果变量<code>foo</code>更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br><span class="line">foo = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>的类型推断为<code>number</code>，后面赋值为字符串，TypeScript 就报错了。</p>
<p>TypeScript 也可以推断函数的返回值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>toString()</code>没有声明返回值的类型，但是 TypeScript 推断返回的是字符串。正是因为 TypeScript 的类型推断，所以函数返回值的类型通常是省略不写的。</p>
<p>从这里可以看到，TypeScript 的设计思想是，类型声明是可选的，你可以加，也可以不加。即使不加类型声明，依然是有效的 TypeScript 代码，只是这时不能保证 TypeScript 会正确推断出类型。由于这个原因，所有 JavaScript 代码都是合法的 TypeScript 代码。</p>
<p>这样设计还有一个好处，将以前的 JavaScript 项目改为 TypeScript 项目时，你可以逐步地为老代码添加类型，即使有些代码没有添加，也不会无法运行。</p>
<h2 id="TypeScript-的编译"><a href="#TypeScript-的编译" class="headerlink" title="TypeScript 的编译"></a>TypeScript 的编译</h2><p>JavaScript 的运行环境（浏览器和 Node.js）不认识 TypeScript 代码。所以，TypeScript 项目要想运行，必须先转为 JavaScript 代码，这个代码转换的过程就叫做“编译”（compile）。</p>
<p>TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p>
<p>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p>
<h2 id="值与类型"><a href="#值与类型" class="headerlink" title="值与类型"></a>值与类型</h2><p>学习 TypeScript 需要分清楚“值”（value）和“类型”（type）。</p>
<p>“类型”是针对“值”的，可以视为是后者的一个元属性。每一个值在 TypeScript 里面都是有类型的。比如，<code>3</code>是一个值，它的类型是<code>number</code>。</p>
<p>TypeScript 代码只涉及类型，不涉及值。所有跟“值”相关的处理，都由 JavaScript 完成。</p>
<p>这一点务必牢记。TypeScript 项目里面，其实存在两种代码，一种是底层的“值代码”，另一种是上层的“类型代码”。前者使用 JavaScript 语法，后者使用 TypeScript 的类型语法。</p>
<p>它们是可以分离的，TypeScript 的编译过程，实际上就是把“类型代码”全部拿掉，只保留“值代码”。</p>
<p>编写 TypeScript 项目时，不要混淆哪些是值代码，哪些是类型代码。</p>
<h2 id="TypeScript-Playground"><a href="#TypeScript-Playground" class="headerlink" title="TypeScript Playground"></a>TypeScript Playground</h2><p>最简单的 TypeScript 使用方法，就是使用官网的在线编译页面，叫做 <a href="http://www.typescriptlang.org/play/">TypeScript Playground</a>。</p>
<p>只要打开这个网页，把 TypeScript 代码贴进文本框，它就会在当前页面自动编译出 JavaScript 代码，还可以在浏览器执行编译产物。如果编译报错，它也会给出详细的报错信息。</p>
<p>这个页面还具有支持完整的 IDE 支持，可以自动语法提示。此外，它支持把代码片段和编译器设置保存成 URL，分享给他人。</p>
<p>本书的示例都建议放到这个页面，进行查看和编译。</p>
<h2 id="tsc-编译器"><a href="#tsc-编译器" class="headerlink" title="tsc 编译器"></a>tsc 编译器</h2><p>TypeScript 官方提供的编译器叫做 tsc，可以将 TypeScript 脚本编译成 JavaScript 脚本。本机想要编译 TypeScript 代码，必须安装 tsc。</p>
<p>根据约定，TypeScript 脚本文件使用<code>.ts</code>后缀名，JavaScript 脚本文件使用<code>.js</code>后缀名。tsc 的作用就是把<code>.ts</code>脚本转变成<code>.js</code>脚本。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>tsc 是一个 npm 模块，使用下面的命令安装（必须先安装 npm）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g typescript</span><br></pre></td></tr></table></figure>

<p>上面命令是全局安装 tsc，也可以在项目中将 tsc 安装为一个依赖模块。</p>
<p>安装完成后，检查一下是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 或者 tsc --version</span></span><br><span class="line">$ tsc -v</span><br><span class="line">Version 5.1.6</span><br></pre></td></tr></table></figure>

<p>上面命令中，<code>-v</code>或<code>--version</code>参数可以输出当前安装的 tsc 版本。</p>
<h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><p><code>-h</code>或<code>--help</code>参数输出帮助信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc -h</span><br></pre></td></tr></table></figure>

<p>默认情况下，“–help”参数仅显示基本的可用选项。我们可以使用“–all”参数，查看完整的帮助信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --all</span><br></pre></td></tr></table></figure>

<h3 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h3><p>安装 tsc 之后，就可以编译 TypeScript 脚本了。</p>
<p><code>tsc</code>命令后面，加上 TypeScript 脚本文件，就可以将其编译成 JavaScript 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc app.ts</span><br></pre></td></tr></table></figure>

<p>上面命令会在当前目录下，生成一个<code>app.js</code>脚本文件，这个脚本就完全是编译后生成的 JavaScript 代码。</p>
<p><code>tsc</code>命令也可以一次编译多个 TypeScript 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc file1.ts file2.ts file3.ts</span><br></pre></td></tr></table></figure>

<p>上面命令会在当前目录生成三个 JavaScript 脚本文件<code>file1.js</code>、<code>file2.js</code>、<code>file3.js</code>。</p>
<p>tsc 有很多参数，可以调整编译行为。</p>
<p><strong>（1）–outFile</strong></p>
<p>如果想将多个 TypeScript 脚本编译成一个 JavaScript 文件，使用<code>--outFile</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc file1.ts file2.ts --outFile app.js</span><br></pre></td></tr></table></figure>

<p>上面命令将<code>file1.ts</code>和<code>file2.ts</code>两个脚本编译成一个 JavaScript 文件<code>app.js</code>。</p>
<p><strong>（2）–outDir</strong></p>
<p>编译结果默认都保存在当前目录，<code>--outDir</code>参数可以指定保存到其他目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc app.ts --outDir dist</span><br></pre></td></tr></table></figure>

<p>上面命令会在<code>dist</code>子目录下生成<code>app.js</code>。</p>
<p><strong>（3）–target</strong></p>
<p>为了保证编译结果能在各种 JavaScript 引擎运行，tsc 默认会将 TypeScript 代码编译成很低版本的 JavaScript，即3.0版本（以<code>es3</code>表示）。这通常不是我们想要的结果。</p>
<p>这时可以使用<code>--target</code>参数，指定编译后的 JavaScript 版本。建议使用<code>es2015</code>，或者更新版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --target es2015 app.ts</span><br></pre></td></tr></table></figure>

<h3 id="编译错误的处理"><a href="#编译错误的处理" class="headerlink" title="编译错误的处理"></a>编译错误的处理</h3><p>编译过程中，如果没有报错，<code>tsc</code>命令不会有任何显示。所以，如果你没有看到任何提示，就表示编译成功了。</p>
<p>如果编译报错，<code>tsc</code>命令就会显示报错信息，但是这种情况下，依然会编译生成 JavaScript 脚本。</p>
<p>举例来说，下面是一个错误的 TypeScript 脚本<code>app.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line">foo = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>是数值类型，赋值为字符串，<code>tsc</code>命令编译这个脚本就会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc app.ts</span><br><span class="line"></span><br><span class="line">app.ts:2:1 - error TS2322: Type <span class="string">&#x27;string&#x27;</span> is not assignable to <span class="built_in">type</span> <span class="string">&#x27;number&#x27;</span>.</span><br><span class="line"></span><br><span class="line">2 foo = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  ~~~</span><br><span class="line"></span><br><span class="line">Found 1 error <span class="keyword">in</span> app.ts:2</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>tsc</code>命令输出报错信息，表示变量<code>foo</code>被错误地赋值为字符串。</p>
<p>这种情况下，编译产物<code>app.js</code>还是会照样生成，下面就是编译后的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">123</span>;</span><br><span class="line">foo = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，尽管有错，tsc 依然原样将 TypeScript 编译成 JavaScript 脚本。</p>
<p>这是因为 TypeScript 团队认为，编译器的作用只是给出编译错误，至于怎么处理这些错误，那就是开发者自己的判断了。开发者更了解自己的代码，所以不管怎样，编译产物都会生成，让开发者决定下一步怎么处理。</p>
<p>如果希望一旦报错就停止编译，不生成编译产物，可以使用<code>--noEmitOnError</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --noEmitOnError app.ts</span><br></pre></td></tr></table></figure>

<p>上面命令在报错后，就不会生成<code>app.js</code>。</p>
<p>tsc 还有一个<code>--noEmit</code>参数，只检查类型是否正确，不生成 JavaScript 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --noEmit app.ts</span><br></pre></td></tr></table></figure>

<p>上面命令只检查是否有编译错误，不会生成<code>app.js</code>。</p>
<p>tsc 命令的更多参数，详见《tsc 编译器》一章。</p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>TypeScript 允许将<code>tsc</code>的编译参数，写在配置文件<code>tsconfig.json</code>。只要当前目录有这个文件，<code>tsc</code>就会自动读取，所以运行时可以不写参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc file1.ts file2.ts --outFile dist/app.js</span><br></pre></td></tr></table></figure>

<p>上面这个命令写成<code>tsconfig.json</code>，就是下面这样。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;file1.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;file2.ts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/app.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>有了这个配置文件，编译时直接调用<code>tsc</code>命令就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc</span><br></pre></td></tr></table></figure>

<p><code>tsconfig.json</code>的详细介绍，参见《tsconfig.json 配置文件》一章。</p>
<h2 id="ts-node-模块"><a href="#ts-node-模块" class="headerlink" title="ts-node 模块"></a>ts-node 模块</h2><p><a href="https://github.com/TypeStrong/ts-node">ts-node</a> 是一个非官方的 npm 模块，可以直接运行 TypeScript 代码。</p>
<p>使用时，可以先全局安装它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g ts-node</span><br></pre></td></tr></table></figure>

<p>安装后，就可以直接运行 TypeScript 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ts-node script.ts</span><br></pre></td></tr></table></figure>

<p>上面命令运行了 TypeScript 脚本<code>script.ts</code>，给出运行结果。</p>
<p>如果不安装 ts-node，也可以通过 npx 调用它来运行 TypeScript 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx ts-node script.ts</span><br></pre></td></tr></table></figure>

<p>上面命令中，<code>npx</code>会在线调用 ts-node，从而在不安装的情况下，运行<code>script.ts</code>。</p>
<p>如果执行 ts-node 命令不带有任何参数，它会提供一个 TypeScript 的命令行 REPL 运行环境，你可以在这个环境中输入 TypeScript 代码，逐行执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ts-node</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>上面示例中，单独运行<code>ts-node</code>命令，会给出一个大于号，这就是 TypeScript 的 REPL 运行环境，可以逐行输入代码运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ts-node</span><br><span class="line">&gt; const twice = (x:string) =&gt; x + x;</span><br><span class="line">&gt; twice(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span></span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>上面示例中，在 TypeScript 命令行 REPL 环境中，先输入一个函数<code>twice</code>，然后调用该函数，就会得到结果。</p>
<p>要退出这个 REPL 环境，可以按下 Ctrl + d，或者输入<code>.exit</code>。</p>
<p>如果只是想简单运行 TypeScript 代码看看结果，ts-node 不失为一个便捷的方法。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的 class 类型</title>
    <url>/2023/09/05/ts-class/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>类（class）是面向对象编程的基本构件，封装了属性和方法，TypeScript 给予了全面支持。</p>
<h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>类的属性可以在顶层声明，也可以在构造方法内部声明。</p>
<p>对于顶层声明的属性，可以在声明时同时给出类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面声明中，属性<code>x</code>和<code>y</code>的类型都是<code>number</code>。</p>
<p>如果不给出类型，TypeScript 会认为<code>x</code>和<code>y</code>的类型都是<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x;</span><br><span class="line">  y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>和<code>y</code>的类型都是<code>any</code>。</p>
<p>如果声明时给出初值，可以不写类型，TypeScript 会自行推断属性的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>和<code>y</code>的类型都会被推断为 number。</p>
<p>TypeScript 有一个配置项<code>strictPropertyInitialization</code>，只要打开（默认是打开的），就会检查属性是否设置了初值，如果没有就报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开 strictPropertyInitialization</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果类的顶层属性不赋值，就会报错。如果不希望出现报错，可以使用非空断言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!: <span class="built_in">number</span>;</span><br><span class="line">  y!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>和<code>y</code>没有初值，但是属性名后面添加了感叹号，表示这两个属性肯定不会为空，所以 TypeScript 就不报错了，详见《类型断言》一章。</p>
<h3 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h3><p>属性名前面加上 readonly 修饰符，就表示该属性是只读的。实例对象不能修改这个属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> id = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>id</code>属性前面有 readonly 修饰符，实例对象修改这个属性就会报错。</p>
<p>readonly 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法内部设置只读属性的初值，这是可以的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>:<span class="built_in">string</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法修改只读属性的值也是可以的。或者说，如果两个地方都设置了只读属性的值，以构造方法为准。在其他方法修改只读属性都会报错。</p>
<h3 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h3><p>类的方法就是普通函数，类型声明方式与函数一致。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">point:Point</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">x</span> + point.<span class="property">x</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">y</span> + point.<span class="property">y</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法<code>constructor()</code>和普通方法<code>add()</code>都注明了参数类型，但是省略了返回值类型，因为 TypeScript 可以自己推断出来。</p>
<p>类的方法跟普通函数一样，可以使用参数默认值，以及函数重载。</p>
<p>下面是参数默认值的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果新建实例时，不提供属性<code>x</code>和<code>y</code>的值，它们都等于默认值<code>0</code>。</p>
<p>下面是函数重载的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">s:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">xs:<span class="built_in">number</span>|<span class="built_in">string</span>, y?:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法可以接受一个参数，也可以接受两个参数，采用函数重载进行类型声明。</p>
<p>另外，构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>):<span class="built_in">object</span> &#123; <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法声明了返回值类型<code>object</code>，导致报错。</p>
<h3 id="存取器方法"><a href="#存取器方法" class="headerlink" title="存取器方法"></a>存取器方法</h3><p>存取器（accessor）是特殊的类方法，包括取值器（getter）和存值器（setter）两种方法。</p>
<p>它们用于读写某个属性，取值器用来读取属性，存值器用来写入属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>get name()</code>是取值器，其中<code>get</code>是关键词，<code>name</code>是属性名。外部读取<code>name</code>属性时，实例对象会自动调用这个方法，该方法的返回值就是<code>name</code>属性的值。</p>
<p><code>set name()</code>是存值器，其中<code>set</code>是关键词，<code>name</code>是属性名。外部写入<code>name</code>属性时，实例对象会自动调用这个方法，并将所赋的值作为函数参数传入。</p>
<p>TypeScript 对存取器有以下规则。</p>
<p>（1）如果某个属性只有<code>get</code>方法，没有<code>set</code>方法，那么该属性自动成为只读属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">name</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>name</code>属性没有<code>set</code>方法，对该属性赋值就会报错。</p>
<p>（2）TypeScript 5.1 版之前，<code>set</code>方法的参数类型，必须兼容<code>get</code>方法的返回值类型，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeScript 5.1 版之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>():<span class="built_in">string</span> &#123;  <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>get</code>方法的返回值类型是字符串，与<code>set</code>方法的参数类型<code>number</code>不兼容，导致报错。改成下面这样，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value:<span class="built_in">number</span>|<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>set</code>方法的参数类型（<code>number|string</code>）兼容<code>get</code>方法的返回值类型（<code>string</code>），这是允许的。</p>
<p>TypeScript 5.1 版做出了<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#unrelated-types-for-getters-and-setters">改变</a>，现在两者可以不兼容。</p>
<p>（3）<code>get</code>方法与<code>set</code>方法的可访问性必须一致，要么都为公开方法，要么都为私有方法。</p>
<h3 id="属性索引"><a href="#属性索引" class="headerlink" title="属性索引"></a>属性索引</h3><p>类允许定义属性索引。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span> |</span><br><span class="line">    (<span class="function">(<span class="params">s:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[s] <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[s:string]</code>表示所有属性名类型为字符串的属性，它们的属性值要么是布尔值，要么是返回布尔值的函数。</p>
<p>注意，由于类的方法是一种特殊属性（属性值为函数的属性），所以属性索引的类型定义也涵盖了方法。如果一个对象同时定义了属性索引和方法，那么前者必须包含后者的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性索引的类型里面不包括方法，导致后面的方法<code>f()</code>定义直接报错。正确的写法是下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span> | (<span class="function">() =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性存取器视同属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isInstance</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>inInstance</code>的读取器虽然是一个函数方法，但是视同属性，所以属性索引虽然没有涉及方法类型，但是不会报错。</p>
<h2 id="类的-interface-接口"><a href="#类的-interface-接口" class="headerlink" title="类的 interface 接口"></a>类的 interface 接口</h2><h3 id="implements-关键字"><a href="#implements-关键字" class="headerlink" title="implements 关键字"></a>implements 关键字</h3><p>interface 接口或 type 别名，可以用对象的形式，为 class 指定一组检查条件。然后，类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCountry</span> <span class="keyword">implements</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  capital = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>interface</code>或<code>type</code>都可以定义一个对象类型。类<code>MyCountry</code>使用<code>implements</code>关键字，表示该类的实例对象满足这个外部类型。</p>
<p>interface 只是指定检查条件，如果不满足这些条件就会报错。它并不能代替 class 自身的类型声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">name</span>:<span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s</span>) &#123; <span class="comment">// s 的类型是 any</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>B</code>实现了接口<code>A</code>，但是后者并不能代替<code>B</code>的类型声明。因此，<code>B</code>的<code>get()</code>方法的参数<code>s</code>的类型是<code>any</code>，而不是<code>string</code>。<code>B</code>类依然需要声明参数<code>s</code>的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">y</span> = <span class="number">10</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>A</code>有一个可选属性<code>y</code>，类<code>B</code>没有声明这个属性，所以可以通过类型检查。但是，如果给<code>B</code>的实例对象的属性<code>y</code>赋值，就会报错。所以，<code>B</code>类还是需要声明可选属性<code>y</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，类可以定义接口没有声明的方法和属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPoint</span> <span class="keyword">implements</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="attr">z</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>MyPoint</code>类实现了<code>Point</code>接口，但是内部还定义了一个额外的属性<code>z</code>，这是允许的，表示除了满足接口给出的条件，类还有额外的条件。</p>
<p><code>implements</code>关键字后面，不仅可以是接口，也可以是另一个类。这时，后面的类将被当作接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="attr">id</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">move</span>():<span class="built_in">void</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  id = <span class="number">2</span>; <span class="comment">// 不可省略</span></span><br><span class="line">  <span class="title function_">move</span>():<span class="built_in">void</span> &#123;&#125;;   <span class="comment">// 不可省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>implements</code>后面是类<code>Car</code>，这时 TypeScript 就把<code>Car</code>视为一个接口，要求<code>MyCar</code>实现<code>Car</code>里面的每一个属性和方法，否则就会报错。所以，这时不能因为<code>Car</code>类已经实现过一次，而在<code>MyCar</code>类省略属性或方法。</p>
<p>注意，interface 描述的是类的对外接口，也就是实例的公开属性和公开方法，不能定义私有的属性和方法。这是因为 TypeScript 设计者认为，私有属性是类的内部实现，接口作为模板，不应该涉及类的内部代码写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">member</span>:&#123;&#125;; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>Foo</code>有一个私有属性，结果就报错了。</p>
<h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><p>类可以实现多个接口（其实是接受多重限制），每个接口之间使用逗号分隔。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span>, <span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Car</code>类同时实现了<code>MotorVehicle</code>、<code>Flyable</code>、<code>Swimmable</code>三个接口。这意味着，它必须部署这三个接口声明的所有属性和方法，满足它们的所有条件。</p>
<p>但是，同时实现多个接口并不是一个好的写法，容易使得代码难以管理，可以使用两种方法替代。</p>
<p>第一种方法是类的继承。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecretCar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Car</code>类实现了<code>MotorVehicle</code>，而<code>SecretCar</code>类继承了<code>Car</code>类，然后再实现<code>Flyable</code>和<code>Swimmable</code>两个接口，相当于<code>SecretCar</code>类同时实现了三个接口。</p>
<p>第二种方法是接口的继承。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">b</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>B</code>继承了接口<code>A</code>，类只要实现接口<code>B</code>，就相当于实现<code>A</code>和<code>B</code>两个接口。</p>
<p>前一个例子可以用接口继承改写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SuperCar</span> <span class="keyword">extends</span> <span class="title class_">MotoVehicle</span>,<span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecretCar</span> <span class="keyword">implements</span> <span class="title class_">SuperCar</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>SecretCar</code>通过<code>SuperCar</code>接口，就间接实现了多个接口。</p>
<p>注意，发生多重实现时（即一个接口同时实现多个接口），不同接口不能有互相冲突的属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>foo</code>在两个接口里面的类型不同，如果同时实现这两个接口，就会报错。</p>
<h3 id="类与接口的合并"><a href="#类与接口的合并" class="headerlink" title="类与接口的合并"></a>类与接口的合并</h3><p>TypeScript 不允许两个同名的类，但是如果一个类和一个接口同名，那么接口会被合并进类。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 1</span></span><br><span class="line">a.<span class="property">y</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>与接口<code>A</code>同名，后者会被合并进前者的类型定义。</p>
<p>注意，合并进类的非空属性（上例的<code>y</code>），如果在赋值之前读取，会返回<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">y</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，根据类型定义，<code>y</code>应该是一个非空属性。但是合并后，<code>y</code>有可能是<code>undefined</code>。</p>
<h2 id="Class-类型"><a href="#Class-类型" class="headerlink" title="Class 类型"></a>Class 类型</h2><h3 id="实例类型"><a href="#实例类型" class="headerlink" title="实例类型"></a>实例类型</h3><p>TypeScript 的类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">green</span>:<span class="title class_">Color</span> = <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="string">&#x27;green&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，定义了一个类<code>Color</code>。它的类名就代表一种类型，实例对象<code>green</code>就属于该类型。</p>
<p>对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为 Interface，因为两者都代表实例对象的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c1</span>:<span class="title class_">Car</span> = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c2</span>:<span class="title class_">MotorVehicle</span> = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量的类型可以写成类<code>Car</code>，也可以写成接口<code>MotorVehicle</code>。它们的区别是，如果类<code>Car</code>有接口<code>MotoVehicle</code>没有的属性和方法，那么只有变量<code>c1</code>可以调用这些属性和方法。</p>
<p>作为类型使用时，类名只能表示实例的类型，不能表示类的自身类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass:Point,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>createPoint()</code>的第一个参数<code>PointClass</code>，需要传入 Point 这个类，但是如果把参数的类型写成<code>Point</code>就会报错，因为<code>Point</code>描述的是实例类型，而不是 Class 的自身类型。</p>
<p>由于类名作为类型使用，实际上代表一个对象，因此可以把类看作为对象类型起名。事实上，TypeScript 有三种方法可以为对象类型起名：type、interface 和 class。</p>
<h3 id="类的自身类型"><a href="#类的自身类型" class="headerlink" title="类的自身类型"></a>类的自身类型</h3><p>要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass:<span class="keyword">typeof</span> Point,</span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>createPoint()</code>的第一个参数<code>PointClass</code>是<code>Point</code>类自身，要声明这个参数的类型，简便的方法就是使用<code>typeof Point</code>。因为<code>Point</code>类是一个值，<code>typeof Point</code>返回这个值的类型。注意，<code>createPoint()</code>的返回值类型是<code>Point</code>，代表实例类型。</p>
<p>JavaScript 语言中，类只是构造函数的一种语法糖，本质上是构造函数的另一种写法。所以，类的自身类型可以写成构造函数的形式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: <span class="keyword">new</span> (x:<span class="built_in">number</span>, y:<span class="built_in">number</span>) =&gt; Point,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>PointClass</code>的类型写成了一个构造函数，这时就可以把<code>Point</code>类传入。</p>
<p>构造函数也可以写成对象形式，所以参数<code>PointClass</code>的类型还有另一种写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">new</span> (x:<span class="built_in">number</span>, y:<span class="built_in">number</span>): Point</span></span><br><span class="line"><span class="params">  &#125;,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的写法，可以把构造函数提取出来，单独定义一个接口（interface），这样可以大大提高代码的通用性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointConstructor</span> &#123;</span><br><span class="line">  <span class="title function_">new</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="title class_">Point</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: PointConstructor,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，类的自身类型就是一个构造函数，可以单独定义一个接口来表示。</p>
<h3 id="结构类型原则"><a href="#结构类型原则" class="headerlink" title="结构类型原则"></a>结构类型原则</h3><p>Class 也遵循“结构类型原则”。一个对象只要满足 Class 的实例结构，就跟该 Class 属于同一个类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  id!:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arg:Foo</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(bar); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>bar</code>满足类<code>Foo</code>的实例结构，只是多了一个属性<code>amount</code>。所以，它可以当作参数，传入函数<code>fn()</code>。</p>
<p>如果两个类的实例结构相同，那么这两个类就是兼容的，可以用在对方的使用场合。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person</code>和<code>Customer</code>是两个结构相同的类，TypeScript 将它们视为相同类型，因此<code>Person</code>可以用在类型为<code>Customer</code>的场合。</p>
<p>现在修改一下代码，<code>Person</code>类添加一个属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person</code>类添加了一个属性<code>age</code>，跟<code>Customer</code>类的结构不再相同。但是这种情况下，TypeScript 依然认为，<code>Person</code>属于<code>Customer</code>类型。</p>
<p>这是因为根据“结构类型原则”，只要<code>Person</code>类具有<code>name</code>属性，就满足<code>Customer</code>类型的实例结构，所以可以代替它。反过来就不行，如果<code>Customer</code>类多出一个属性，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person</code>类比<code>Customer</code>类少一个属性<code>age</code>，它就不满足<code>Customer</code>类型的实例结构，就报错了。因为在使用<code>Customer</code>类型的情况下，可能会用到它的<code>age</code>属性，而<code>Person</code>类就没有这个属性。</p>
<p>总之，只要 A 类具有 B 类的结构，哪怕还有额外的属性和方法，TypeScript 也认为 A 兼容 B 的类型。</p>
<p>不仅是类，如果某个对象跟某个 class 的实例结构相同，TypeScript 也认为两者的类型相同。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Person</span> = obj; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>obj</code>并不是<code>Person</code>的实例，但是赋值给变量<code>p</code>不会报错，TypeScript 认为<code>obj</code>也属于<code>Person</code>类型，因为它们的属性相同。</p>
<p>由于这种情况，运算符<code>instanceof</code>不适用于判断某个对象是否跟某个 class 属于同一类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，运算符<code>instanceof</code>确认变量<code>obj</code>不是 Person 的实例，但是两者的类型是相同的。</p>
<p>空类不包含任何成员，任何其他类都可以看作与空类结构相同。因此，凡是类型为空类的地方，所有类（包括对象）都可以使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:Empty</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">fn</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="title function_">fn</span>(fn);</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fn()</code>的参数是一个空类，这意味着任何对象都可以用作<code>fn()</code>的参数。</p>
<p>注意，确定两个类的兼容关系时，只检查实例成员，不考虑静态成员和构造方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">t</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:<span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Position</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Point</code>与<code>Position</code>的静态属性和构造方法都不一样，但因为<code>Point</code>的实例成员与<code>Position</code>相同，所以<code>Position</code>兼容<code>Point</code>。</p>
<p>如果类中存在私有成员（private）或保护成员（protected），那么确定兼容关系时，TypeScript 要求私有成员和保护成员来自同一个类，这意味着两个类需要存在继承关系。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>和<code>B</code>都有私有成员（或保护成员）<code>name</code>，这时只有在<code>B</code>继承<code>A</code>的情况下（<code>class B extends A</code>），<code>B</code>才兼容<code>A</code>。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>类（这里又称“子类”）可以使用 extends 关键字继承另一个类（这里又称“基类”）的所有属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">greet</span>() <span class="comment">// &quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>继承了基类<code>A</code>，因此就拥有了<code>greet()</code>方法，不需要再次在类的内部定义这个方法了。</p>
<p>根据结构类型原则，子类也可以用于类型为基类的场合。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = b;</span><br><span class="line">a.<span class="title function_">greet</span>()</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>的类型是基类，但是可以赋值为子类的实例。</p>
<p>子类可以覆盖基类的同名方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">greet</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>定义了一个方法<code>greet()</code>，覆盖了基类<code>A</code>的同名方法。其中，参数<code>name</code>省略时，就调用基类<code>A</code>的<code>greet()</code>方法，这里可以写成<code>super.greet()</code>，使用<code>super</code>关键字指代基类是常见做法。</p>
<p>但是，子类的同名方法不能与基类的类型定义相冲突。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>的<code>greet()</code>有一个<code>name</code>参数，跟基类<code>A</code>的<code>greet()</code>定义不兼容，因此就报错了。</p>
<p>如果基类包括保护成员（<code>protected</code>修饰符），子类可以将该成员的可访问性设置为公开（<code>public</code>修饰符），也可以保持保护成员不变，但是不能改用私有成员（<code>private</code>修饰符），详见后文。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">y</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">x</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">y</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>将基类<code>A</code>的受保护成员改成私有成员，就会报错。</p>
<p>注意，<code>extends</code>关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from A&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from B&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GreeterConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (): <span class="title class_">Greeter</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGreeterBase</span>(<span class="params"></span>):<span class="title class_">GreeterConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt;= <span class="number">0.5</span> ? A : B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">getGreeterBase</span>() &#123;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">greeting</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，例一和例二的<code>extends</code>关键字后面都是构造函数，例三的<code>extends</code>关键字后面是一个表达式，执行后得到的也是一个构造函数。</p>
<p>对于那些只设置了类型、没有初值的顶层属性，有一个细节需要注意。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Animal</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">animal:Animal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resident</span> = animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog:Dog</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>DogHouse</code>的顶层成员<code>resident</code>只设置了类型（<code>Dog</code>），没有设置初值。这段代码在不同的编译设置下，编译结果不一样。</p>
<p>如果编译设置的<code>target</code>设成大于等于<code>ES2022</code>，或者<code>useDefineForClassFields</code>设成<code>true</code>，那么下面代码的执行结果是不一样的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="string">&#x27;animal&#x27;</span>,</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="string">&#x27;dog&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dogHouse = <span class="keyword">new</span> <span class="title class_">DogHouse</span>(dog);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dogHouse.<span class="property">resident</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>DogHouse</code>实例的属性<code>resident</code>输出的是<code>undefined</code>，而不是预料的<code>dog</code>。原因在于 ES2022 标准的 Class Fields 部分，与早期的 TypeScript 实现不一致，导致子类的那些只设置类型、没有设置初值的顶层成员在基类中被赋值后，会在子类被重置为<code>undefined</code>，详细的解释参见《tsconfig.json》一章，以及官方 3.7 版本的<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier">发布说明</a>。</p>
<p>解决方法就是使用<code>declare</code>命令，去声明顶层成员的类型，告诉 TypeScript 这些成员的赋值由基类实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog:Dog</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>resident</code>属性的类型声明前面用了<code>declare</code>命令，这样就能确保在编译目标大于等于<code>ES2022</code>时（或者打开<code>useDefineForClassFields</code>时），代码行为正确。</p>
<h2 id="可访问性修饰符"><a href="#可访问性修饰符" class="headerlink" title="可访问性修饰符"></a>可访问性修饰符</h2><p>类的内部成员的外部可访问性，由三个可访问性修饰符（access modifiers）控制：<code>public</code>、<code>private</code>和<code>protected</code>。</p>
<p>这三个修饰符的位置，都写在属性或方法的最前面。</p>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p><code>public</code>修饰符表示这是公开成员，外部可以自由访问。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>greet()</code>方法前面的<code>public</code>修饰符，表示该方法可以在类的外部调用，即外部实例可以调用。</p>
<p><code>public</code>修饰符是默认修饰符，如果省略不写，实际上就带有该修饰符。因此，类的属性和方法默认都是外部可访问的。</p>
<p>正常情况下，除非为了醒目和代码可读性，<code>public</code>都是省略不写的。</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p><code>private</code>修饰符表示私有成员，只能用在当前类的内部，类的实例和子类都不能使用该成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">showX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>前面有<code>private</code>修饰符，表示这是私有成员。因此，实例对象和子类使用该成员，都会报错。</p>
<p>注意，子类不能定义父类私有成员的同名成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>类有一个私有属性<code>x</code>，子类<code>B</code>就不能定义自己的属性<code>x</code>了。</p>
<p>如果在类的内部，当前类的实例可以获取私有成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">f</span>(<span class="params">obj:A</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="title function_">f</span>(a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，在类<code>A</code>内部，<code>A</code>的实例对象可以获取私有成员<code>x</code>。</p>
<p>严格地说，<code>private</code>定义的私有成员，并不是真正意义的私有成员。一方面，编译成 JavaScript 后，<code>private</code>关键字就被剥离了，这时外部访问该成员就不会报错。另一方面，由于前一个原因，TypeScript 对于访问<code>private</code>成员没有严格禁止，使用方括号写法（<code>[]</code>）或者<code>in</code>运算符，实例对象就能访问该成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> a) &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>类的属性<code>x</code>是私有属性，但是实例使用方括号，就可以读取这个属性，或者使用<code>in</code>运算符检查这个属性是否存在，都可以正确执行。</p>
<p>由于<code>private</code>存在这些问题，加上它是 ES2022 标准发布前出台的，而 ES2022 引入了自己的私有成员写法<code>#propName</code>。因此建议不使用<code>private</code>，改用 ES2022 的写法，获得真正意义的私有成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  #x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，采用了 ES2022 的私有成员写法（属性名前加<code>#</code>），TypeScript 就正确识别了实例对象没有属性<code>x</code>，从而报错。</p>
<p>构造方法也可以是私有的，这就直接防止了使用<code>new</code>命令生成实例对象，只能在类的内部创建实例对象。</p>
<p>这时一般会有一个静态方法，充当工厂函数，强制所有实例都通过该方法生成。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> instance?: <span class="title class_">Singleton</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Singleton</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="title class_">Singleton</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Singleton</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例使用私有构造方法，实现了单例模式。想要获得 Singleton 的实例，不能使用<code>new</code>命令，只能使用<code>getInstance()</code>方法。</p>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p><code>protected</code>修饰符表示该成员是保护成员，只能在类的内部使用该成员，实例无法使用该成员，但是子类内部可以使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">getX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line">b.<span class="title function_">getX</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>的属性<code>x</code>是保护成员，直接从实例读取该属性（<code>a.x</code>）会报错，但是子类<code>B</code>内部可以读取该属性。</p>
<p>子类不仅可以拿到父类的保护成员，还可以定义同名成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类<code>B</code>定义了父类<code>A</code>的同名成员<code>x</code>，并且父类的<code>x</code>是保护成员，子类将其改成了公开成员。<code>B</code>类的<code>x</code>属性前面没有修饰符，等同于修饰符是<code>public</code>，外界可以读取这个属性。</p>
<p>在类的外部，实例对象不能读取保护成员，但是在类的内部可以。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">f</span>(<span class="params">obj:A</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line">a.<span class="title function_">f</span>(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>是类<code>A</code>的保护成员，在类的外部，实例对象<code>a</code>拿不到这个属性。但是，实例对象<code>a</code>传入类<code>A</code>的内部，就可以从<code>a</code>拿到<code>x</code>。</p>
<h3 id="实例属性的简写形式"><a href="#实例属性的简写形式" class="headerlink" title="实例属性的简写形式"></a>实例属性的简写形式</h3><p>实际开发中，很多实例属性的值，是通过构造方法传入的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面实例中，属性<code>x</code>和<code>y</code>的值是通过构造方法的参数传入的。</p>
<p>这样的写法等于对同一个属性要声明两次类型，一次在类的头部，另一次在构造方法的参数里面。这有些累赘，TypeScript 就提供了一种简写形式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">p.<span class="property">x</span> <span class="comment">// 10</span></span><br><span class="line">p.<span class="property">y</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法的参数<code>x</code>前面有<code>public</code>修饰符，这时 TypeScript 就会自动声明一个公开属性<code>x</code>，不必在构造方法里面写任何代码，同时还会设置<code>x</code>的值为构造方法的参数值。注意，这里的<code>public</code>不能省略。</p>
<p>除了<code>public</code>修饰符，构造方法的参数名只要有<code>private</code>、<code>protected</code>、<code>readonly</code>修饰符，都会自动声明对应修饰符的实例属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> a: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> b: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> c: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">readonly</span> d: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a;</span><br><span class="line">    b;</span><br><span class="line">    c;</span><br><span class="line">    d;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a, b, c, d</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">b</span> = b;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">c</span> = c;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">d</span> = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，从编译结果可以看到，构造方法的<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>会生成对应的实例属性。</p>
<p><code>readonly</code>还可以与其他三个可访问性修饰符，一起使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">readonly</span> x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> <span class="keyword">readonly</span> y:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> z:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>类的内部可以使用<code>static</code>关键字，定义静态成员。</p>
<p>静态成员是只能通过类本身使用的成员，不能通过实例对象使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span> <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>是静态属性，<code>printX()</code>是静态方法。它们都必须通过<code>MyClass</code>获取，而不能通过实例对象调用。</p>
<p><code>static</code>关键字前面可以使用 public、private、protected 修饰符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性<code>x</code>前面有<code>private</code>修饰符，表示只能在<code>MyClass</code>内部使用，如果在外部调用这个属性就会报错。</p>
<p>静态私有属性也可以用 ES6 语法的<code>#</code>前缀表示，上面示例可以改写如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>public</code>和<code>protected</code>的静态成员可以被继承。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getY</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> B.<span class="property">y</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">x</span> <span class="comment">// 1</span></span><br><span class="line">B.<span class="title function_">getY</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>的静态属性<code>x</code>和<code>y</code>都被<code>B</code>继承，公开成员<code>x</code>可以在<code>B</code>的外部获取，保护成员<code>y</code>只能在<code>B</code>的内部获取。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>类也可以写成泛型，使用类型参数。关于泛型的详细介绍，请看《泛型》一章。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value:Type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>Box</code>有类型参数<code>Type</code>，因此属于泛型类。新建实例时，变量的类型声明需要带有类型参数的值，不过本例等号左边的<code>Box&lt;string&gt;</code>可以省略不写，因为可以从等号右边推断得到。</p>
<p>注意，静态成员不能使用泛型的类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">defaultContents</span>: <span class="title class_">Type</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性<code>defaultContents</code>的类型写成类型参数<code>Type</code>会报错。因为这意味着调用时必须给出类型参数（即写成<code>Box&lt;string&gt;.defaultContents</code>），并且类型参数发生变化，这个属性也会跟着变，这并不是好的做法。</p>
<h2 id="抽象类，抽象成员"><a href="#抽象类，抽象成员" class="headerlink" title="抽象类，抽象成员"></a>抽象类，抽象成员</h2><p>TypeScript 允许在类的定义前面，加上关键字<code>abstract</code>，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做“抽象类”（abstract class）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，直接新建抽象类的实例，会报错。</p>
<p>抽象类只能当作基类使用，用来在它的基础上定义子类。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  amount = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"></span><br><span class="line">b.<span class="property">id</span> <span class="comment">// 1</span></span><br><span class="line">b.<span class="property">amount</span> <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>是一个抽象类，<code>B</code>是<code>A</code>的子类，继承了<code>A</code>的所有成员，并且可以定义自己的成员和实例化。</p>
<p>抽象类的子类也可以是抽象类，也就是说，抽象类可以继承其他抽象类。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="attr">bar</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类的内部可以有已经实现好的属性和方法，也可以有还未实现的属性和方法。后者就叫做“抽象成员”（abstract member），即属性名和方法名有<code>abstract</code>关键字，表示该方法需要子类实现。如果子类没有实现抽象成员，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">bar</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  foo = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，抽象类<code>A</code>定义了抽象属性<code>foo</code>，子类<code>B</code>必须实现这个属性，否则会报错。</p>
<p>下面是抽象方法的例子。如果抽象类的方法前面加上<code>abstract</code>，就表明子类必须给出该方法的实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">execute</span>():<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`B executed`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个注意点。</p>
<p>（1）抽象成员只能存在于抽象类，不能存在于普通类。</p>
<p>（2）抽象成员不能有具体实现的代码。也就是说，已经实现好的成员前面不能加<code>abstract</code>关键字。</p>
<p>（3）抽象成员前也不能有<code>private</code>修饰符，否则无法在子类中实现该成员。</p>
<p>（4）一个子类最多只能继承一个抽象类。</p>
<p>总之，抽象类的作用是，确保各种相关的子类都拥有跟基类相同的接口，可以看作是模板。其中的抽象成员都是必须由子类实现的成员，非抽象成员则表示基类已经实现的、由所有子类共享的成员。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>类的方法经常用到<code>this</code>关键字，它表示该方法当前所在的对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="title function_">getName</span>() <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: a.<span class="property">getName</span></span><br><span class="line">&#125;;</span><br><span class="line">b.<span class="title function_">getName</span>() <span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>b</code>的<code>getName()</code>是同一个方法，但是执行结果不一样，原因就是它们内部的<code>this</code>指向不一样的对象。如果<code>getName()</code>在变量<code>a</code>上运行，<code>this</code>指向<code>a</code>；如果在<code>b</code>上运行，<code>this</code>指向<code>b</code>。</p>
<p>有些场合需要给出<code>this</code>类型，但是 JavaScript 函数通常不带有<code>this</code>参数，这时 TypeScript 允许函数增加一个名为<code>this</code>的参数，放在参数列表的第一位，用来描述函数内部的<code>this</code>关键字的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: SomeType,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fn()</code>的第一个参数是<code>this</code>，用来声明函数内部的<code>this</code>的类型。编译时，TypeScript 一旦发现函数的第一个参数名为<code>this</code>，则会去除这个参数，即编译结果不会带有该参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"><span class="variable language_">this</span>: A</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="property">getName</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>的<code>getName()</code>添加了<code>this</code>参数，如果直接调用这个方法，<code>this</code>的类型就会跟声明的类型不一致，从而报错。</p>
<p><code>this</code>参数的类型可以声明为各种对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: &#123; name: <span class="built_in">string</span> &#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="number">123</span> &#125;); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>this</code>的类型是一个带有<code>name</code>属性的对象，不符合这个条件的<code>this</code>都会报错。</p>
<p>TypeScript 提供了一个<code>noImplicitThis</code>编译选项。如果打开了这个设置项，如果<code>this</code>的值推断为<code>any</code>类型，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// noImplicitThis 打开</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> width:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> height:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getAreaFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>; <span class="comment">// 报错</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getAreaFunction()</code>方法返回一个函数，这个函数里面用到了<code>this</code>，但是这个<code>this</code>跟<code>Rectangle</code>这个类没关系，它的类型推断为<code>any</code>，所以就报错了。</p>
<p>在类的内部，<code>this</code>本身也可以当作类型使用，表示当前类的实例对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">contents</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">value</span>:<span class="built_in">string</span>):<span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>set()</code>方法的返回值类型就是<code>this</code>，表示当前的实例对象。</p>
<p>注意，<code>this</code>类型不允许应用于静态成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">a</span>:<span class="variable language_">this</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性<code>a</code>的返回值类型是<code>this</code>，就报错了。原因是<code>this</code>类型表示实例对象，但是静态成员拿不到实例对象。</p>
<p>有些方法返回一个布尔值，表示当前的<code>this</code>是否属于某种类型。这时，这些方法的返回值类型可以写成<code>this is Type</code>的形式，其中用到了<code>is</code>运算符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemObject</span> &#123;</span><br><span class="line">  <span class="title function_">isFile</span>(): <span class="variable language_">this</span> is <span class="title class_">FileRep</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">FileRep</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isDirectory</span>(): <span class="variable language_">this</span> is <span class="title class_">Directory</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Directory</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两个方法的返回值类型都是布尔值，写成<code>this is Type</code>的形式，可以精确表示返回值。<code>is</code>运算符的介绍详见《类型断言》一章。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://fritzthecat-blog.blogspot.com/2018/06/typescript-constructor-in-interface.html">TypeScript Constructor in Interface</a></li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的注释指令</title>
    <url>/2023/09/05/ts-comment/</url>
    <content><![CDATA[<div id="readmore-container"><p>TypeScript 接受一些注释指令。</p>
<p>所谓“注释指令”，指的是采用 JS 双斜杠注释的形式，向编译器发出的命令。</p>
<h2 id="ts-nocheck"><a href="#ts-nocheck" class="headerlink" title="// @ts-nocheck"></a><code>// @ts-nocheck</code></h2><p><code>// @ts-nocheck</code>告诉编译器不对当前脚本进行类型检查，可以用于 TypeScript 脚本，也可以用于 JavaScript 脚本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @ts-nocheck</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>document.getElementById(123)</code>存在类型错误，但是编译器不对该脚本进行类型检查，所以不会报错。</p>
<h2 id="ts-check"><a href="#ts-check" class="headerlink" title="// @ts-check"></a><code>// @ts-check</code></h2><p>如果一个 JavaScript 脚本顶部添加了<code>// @ts-check</code>，那么编译器将对该脚本进行类型检查，不论是否启用了<code>checkJs</code>编译选项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"><span class="keyword">let</span> isChecked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isChceked); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例是一个 JavaScript 脚本，<code>// @ts-check</code>告诉 TypeScript 编译器对其进行类型检查，所以最后一行会报错，提示拼写错误。</p>
<h2 id="ts-ignore"><a href="#ts-ignore" class="headerlink" title="// @ts-ignore"></a><code>// @ts-ignore</code></h2><p><code>// @ts-ignore</code>告诉编译器不对下一行代码进行类型检查，可以用于 TypeScript 脚本，也可以用于 JavaScript 脚本。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行是类型错误，变量<code>x</code>的类型是<code>number</code>，不能等于布尔值。但是因为前面加上了<code>// @ts-ignore</code>，编译器会跳过这一行的类型检查，所以不会报错。</p>
<h2 id="ts-expect-error"><a href="#ts-expect-error" class="headerlink" title="// @ts-expect-error"></a><code>// @ts-expect-error</code></h2><p><code>// @ts-expect-error</code>主要用在测试用例，当下一行有类型错误时，它会压制 TypeScript 的报错信息（即不显示报错信息），把错误留给代码自己处理。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params">abc: <span class="built_in">string</span>, xyz: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="title function_">assert</span>(<span class="keyword">typeof</span> abc === <span class="string">&quot;string&quot;</span>);</span><br><span class="line">  <span class="title function_">assert</span>(<span class="keyword">typeof</span> xyz === <span class="string">&quot;string&quot;</span>);</span><br><span class="line">  <span class="comment">// do some stuff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line"><span class="title function_">expect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">doStuff</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">&#125;).<span class="title function_">toThrow</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例是一个测试用例，倒数第二行的<code>doStuff(123, 456)</code>的参数类型与定义不一致，TypeScript 引擎会报错。但是，测试用例本身测试的就是这个错误，已经有专门的处理代码，所以这里可以使用<code>// @ts-expect-error</code>，不显示引擎的报错信息。</p>
<p>如果下一行没有类型错误，<code>// @ts-expect-error</code>则会显示一行提示。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 输出 Unused &#x27;@ts-expect-error&#x27; directive.</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第二行是正确代码，这时系统会给出一个提示，表示<code>@ts-expect-error</code>没有用到。</p>
<h2 id="JSDoc"><a href="#JSDoc" class="headerlink" title="JSDoc"></a>JSDoc</h2><p>TypeScript 直接处理 JS 文件时，如果无法推断出类型，会使用 JS 脚本里面的 JSDoc 注释。</p>
<p>使用 JSDoc 时，有两个基本要求。</p>
<p>（1）JSDoc 注释必须以<code>/**</code>开始，其中星号（<code>*</code>）的数量必须为两个。若使用其他形式的多行注释，则 JSDoc 会忽略该条注释。</p>
<p>（2）JSDoc 注释必须与它描述的代码处于相邻的位置，并且注释在上，代码在下。</p>
<p>下面是 JSDoc 的一个简单例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">somebody</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">somebody</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello &#x27;</span> + somebody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，注释里面的<code>@param</code>是一个 JSDoc 声明，表示下面的函数<code>sayHello()</code>的参数<code>somebody</code>类型为<code>string</code>。</p>
<p>TypeScript 编译器支持大部分的 JSDoc 声明，下面介绍其中的一些。</p>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="@typedef"></a>@typedef</h3><p><code>@typedef</code>命令创建自定义类型，等同于 TypeScript 里面的类型别名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">(number | string)</span>&#125; <span class="variable">NumberLike</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，定义了一个名为<code>NumberLike</code>的新类型，它是由<code>number</code>和<code>string</code>构成的联合类型，等同于 TypeScript 的如下语句。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NumberLike</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><p><code>@type</code>命令定义变量的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>@type</code>定义了变量<code>a</code>的类型为<code>string</code>。</p>
<p>在<code>@type</code>命令中可以使用由<code>@typedef</code>命令创建的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">(number | string)</span>&#125; <span class="variable">NumberLike</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">NumberLike</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>@type</code>命令中允许使用 TypeScript 类型及其语法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**<span class="doctag">@type</span> &#123;<span class="type">true | false</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">number[]</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">Array&lt;number&gt;</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">&#123; readonly x: number, y?: string </span>&#125;&#125; */</span></span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">(s: string, b: boolean) =&gt; number</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> e;</span><br></pre></td></tr></table></figure>

<h3 id="param"><a href="#param" class="headerlink" title="@param"></a>@param</h3><p><code>@param</code>命令用于定义函数参数的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125;  <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果是可选参数，需要将参数名放在方括号<code>[]</code>里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125;  [x]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>方括号里面，还可以指定参数默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; [x=&quot;bar&quot;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>x</code>的默认值是字符串<code>bar</code>。</p>
<h3 id="return，-returns"><a href="#return，-returns" class="headerlink" title="@return，@returns"></a>@return，@returns</h3><p><code>@return</code>和<code>@returns</code>命令的作用相同，指定函数返回值的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="extends-和类型修饰符"><a href="#extends-和类型修饰符" class="headerlink" title="@extends 和类型修饰符"></a>@extends 和类型修饰符</h3><p><code>@extends</code>命令用于定义继承的基类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@extends</span> &#123;<span class="type">Base</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@public</code>、<code>@protected</code>、<code>@private</code>分别指定类的公开成员、保护成员和私有成员。</p>
<p><code>@readonly</code>指定只读成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@public</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@readonly</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>d.ts 类型声明文件</title>
    <url>/2023/09/05/ts-d.ts/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单独使用的模块，一般会同时提供一个单独的类型声明文件（declaration file），把本模块的外部接口的所有类型都写在这个文件里面，便于模块使用者了解接口，也便于编译器检查使用者的用法是否正确。</p>
<p>类型声明文件里面只有类型代码，没有具体的代码实现。它的文件名一般为<code>[模块名].d.ts</code>的形式，其中的<code>d</code>表示 declaration（声明）。</p>
<p>举例来说，有一个模块的代码如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> maxInterval = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  getArrayLength,</span><br><span class="line">  maxInterval,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的类型声明文件可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">maxInterval</span>: <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>类型声明文件也可以使用<code>export =</code>命令，输出对外接口。下面是 moment 模块的类型声明文件的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">moment</span>(<span class="params"></span>): <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">export</span> = moment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，模块<code>moment</code>内部有一个函数<code>moment()</code>，而<code>export =</code>表示<code>module.exports</code>输出的就是这个函数。</p>
<p>除了使用<code>export =</code>，模块输出在类型声明文件中，也可以使用<code>export default</code>表示。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块输出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="number">3.142</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型输出文件</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">pi</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">pi</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span>= pi;</span><br></pre></td></tr></table></figure>

<p>上面示例中，模块输出的是一个整数，那么可以用<code>export default</code>或<code>export =</code>表示输出这个值。</p>
<p>下面是一个如何使用类型声明文件的简单例子。有一个类型声明文件<code>types.d.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">  catchphrase?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，就可以在 TypeScript 脚本里面导入该文件声明的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Character</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">character</span>:<span class="title class_">Character</span> = &#123;</span><br><span class="line">  <span class="attr">catchphrase</span>: <span class="string">&quot;Yee-haw!&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sandy Cheeks&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类型声明文件也可以包括在项目的 tsconfig.json 文件里面，这样的话，编译器打包项目时，会自动将类型声明文件加入编译，而不必在每个脚本里面加载类型声明文件。比如，moment 模块的类型声明文件是<code>moment.d.ts</code>，使用 moment 模块的项目可以将其加入项目的 tsconfig.json 文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src/index.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typings/moment.d.ts&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型声明文件的来源"><a href="#类型声明文件的来源" class="headerlink" title="类型声明文件的来源"></a>类型声明文件的来源</h2><p>类型声明文件主要有以下三种来源。</p>
<ul>
<li>TypeScript 编译器自动生成。</li>
<li>TypeScript 内置类型文件。</li>
<li>外部模块的类型声明文件，需要自己安装。</li>
</ul>
<h3 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h3><p>只要使用编译选项<code>declaration</code>，编译器就会在编译时自动生成单独的类型声明文件。</p>
<p>下面是在<code>tsconfig.json</code>文件里面，打开这个选项。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以在命令行打开这个选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --declaration</span><br></pre></td></tr></table></figure>

<h3 id="内置声明文件"><a href="#内置声明文件" class="headerlink" title="内置声明文件"></a>内置声明文件</h3><p>安装 TypeScript 语言时，会同时安装一些内置的类型声明文件，主要是内置的全局对象（JavaScript 语言接口和运行环境 API）的类型声明。</p>
<p>这些内置声明文件位于 TypeScript 语言安装目录的<code>lib</code>文件夹内，数量大概有几十个，下面是其中一些主要文件。</p>
<ul>
<li>lib.d.ts</li>
<li>lib.dom.d.ts</li>
<li>lib.es2015.d.ts</li>
<li>lib.es2016.d.ts</li>
<li>lib.es2017.d.ts</li>
<li>lib.es2018.d.ts</li>
<li>lib.es2019.d.ts</li>
<li>lib.es2020.d.ts</li>
<li>lib.es5.d.ts</li>
<li>lib.es6.d.ts</li>
</ul>
<p>这些内置声明文件的文件名统一为“lib.[description].d.ts”的形式，其中<code>description</code>部分描述了文件内容。比如，<code>lib.dom.d.ts</code>这个文件就描述了 DOM 结构的类型。</p>
<p>如果开发者想了解全局对象的类型接口（比如 ES6 全局对象的类型），那么就可以去查看这些内置声明文件。</p>
<p>TypeScript 编译器会自动根据编译目标<code>target</code>的值，加载对应的内置声明文件，所以不需要特别的配置。但是，可以使用编译选项<code>lib</code>，指定加载哪些内置声明文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;dom&quot;</span>, <span class="string">&quot;es2021&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>lib</code>选项指定加载<code>dom</code>和<code>es2021</code>这两个内置类型声明文件。</p>
<p>编译选项<code>noLib</code>会禁止加载任何内置声明文件。</p>
<h3 id="外部类型声明文件"><a href="#外部类型声明文件" class="headerlink" title="外部类型声明文件"></a>外部类型声明文件</h3><p>如果项目中使用了外部的某个第三方代码库，那么就需要这个库的类型声明文件。</p>
<p>这时又分成三种情况。</p>
<p>（1）这个库自带了类型声明文件。</p>
<p>一般来说，如果这个库的源码包含了<code>[vendor].d.ts</code>文件，那么就自带了类型声明文件。其中的<code>vendor</code>表示这个库的名字，比如<code>moment</code>这个库就自带<code>moment.d.ts</code>。使用这个库可能需要单独加载它的类型声明文件。</p>
<p>（2）这个库没有自带，但是可以找到社区制作的类型声明文件。</p>
<p>第三方库如果没有提供类型声明文件，社区往往会提供。TypeScript 社区主要使用 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped 仓库</a>，各种类型声明文件都会提交到那里，已经包含了几千个第三方库。</p>
<p>这些声明文件都会作为一个单独的库，发布到 npm 的<code>@types</code>名称空间之下。比如，jQuery 的类型声明文件就发布成<code>@types/jquery</code>这个库，使用时安装这个库就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure>

<p>执行上面的命令，<code>@types/jquery</code>这个库就安装到项目的<code>node_modules/@types/jquery</code>目录，里面的<code>index.d.ts</code>文件就是 jQuery 的类型声明文件。如果类型声明文件不是<code>index.d.ts</code>，那么就需要在<code>package.json</code>的<code>types</code>或<code>typings</code>字段，指定类型声明文件的文件名。</p>
<p>TypeScript 会自动加载<code>node_modules/@types</code>目录下的模块，但可以使用编译选项<code>typeRoots</code>改变这种行为。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [<span class="string">&quot;./typings&quot;</span>, <span class="string">&quot;./vendor/types&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例表示，TypeScript 不再去<code>node_modules/@types</code>目录，而是去跟当前<code>tsconfig.json</code>同级的<code>typings</code>和<code>vendor/types</code>子目录，加载类型模块了。</p>
<p>默认情况下，TypeScript 会自动加载<code>typeRoots</code>目录里的所有模块，编译选项<code>types</code>可以指定加载哪些模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;types&quot;</span> : [<span class="string">&quot;jquery&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面设置中，<code>types</code>属性是一个数组，成员是所要加载的类型模块，要加载几个模块，这个数组就有几个成员，每个类型模块在<code>typeRoots</code>目录下都有一个自己的子目录。这样的话，TypeScript 就会自动去<code>jquery</code>子目录，加载 jQuery 的类型声明文件。</p>
<p>（3）找不到类型声明文件，需要自己写。</p>
<p>有时实在没有第三方库的类型声明文件，又很难完整给出该库的类型描述，这时你可以告诉 TypeScript 相关对象的类型是<code>any</code>。比如，使用 jQuery 的脚本可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">$</span>:<span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">JQuery</span> = <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">$</span>:<span class="title class_">JQuery</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，jQuery 的<code>$</code>对象是外部引入的，类型是<code>any</code>，也就是 TypeScript 不用对它进行类型检查。</p>
<p>也可以采用下面的写法，将整个外部模块的类型设为<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;模块名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>有了上面的命令，指定模块的所有接口都将视为<code>any</code>类型。</p>
<h2 id="declare-关键字"><a href="#declare-关键字" class="headerlink" title="declare 关键字"></a>declare 关键字</h2><p>类型声明文件只包含类型描述，不包含具体实现，所以非常适合使用 declare 语句来描述类型。declare 关键字的具体用法，详见《declare 关键字》一章，这里讲解如何在类型声明文件里面使用它。</p>
<p>类型声明文件里面，变量的类型描述必须使用<code>declare</code>命令，否则会报错，因为变量声明语句是值相关代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>interface 类型有没有<code>declare</code>都可以，因为 interface 是完全的类型代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;&#125; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;&#125; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>类型声明文件里面，顶层可以使用<code>export</code>命令，也可以不用，除非使用者脚本会显式使用<code>export</code>命令输入类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是类型声明文件的一些例子。先看 moment 模块的类型描述文件<code>moment.d.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Moment</span> &#123;</span><br><span class="line">    <span class="title function_">format</span>(<span class="attr">format</span>:<span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">add</span>(</span><br><span class="line">      <span class="attr">amount</span>: <span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">unit</span>: <span class="string">&#x27;days&#x27;</span> | <span class="string">&#x27;months&#x27;</span> | <span class="string">&#x27;years&#x27;</span></span><br><span class="line">    ): <span class="title class_">Moment</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">subtract</span>(</span><br><span class="line">      <span class="attr">amount</span>:<span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">unit</span>:<span class="string">&#x27;days&#x27;</span> | <span class="string">&#x27;months&#x27;</span> | <span class="string">&#x27;years&#x27;</span></span><br><span class="line">    ): <span class="title class_">Moment</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">moment</span>(<span class="params"></span></span><br><span class="line"><span class="params">    input?: <span class="built_in">string</span> | <span class="built_in">Date</span></span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Moment</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> moment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，可以注意一下默认接口<code>moment()</code>的写法。</p>
<p>下面是 D3 库的类型声明文件<code>D3.d.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> D3 &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Selectors</span> &#123;</span><br><span class="line">    <span class="attr">select</span>: &#123;</span><br><span class="line">      (<span class="attr">selector</span>: <span class="built_in">string</span>): <span class="title class_">Selection</span>;</span><br><span class="line">      (<span class="attr">element</span>: <span class="title class_">EventTarget</span>): <span class="title class_">Selection</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Base</span> <span class="keyword">extends</span> <span class="title class_">Selectors</span> &#123;</span><br><span class="line">    <span class="attr">event</span>: <span class="title class_">Event</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">d3</span>: <span class="variable constant_">D3</span>.<span class="property">Base</span>;</span><br></pre></td></tr></table></figure>

<h2 id="模块发布"><a href="#模块发布" class="headerlink" title="模块发布"></a>模块发布</h2><p>当前模块如果包含自己的类型声明文件，可以在 package.json 文件里面添加一个<code>types</code>字段或<code>typings</code>字段，指明类型声明文件的位置。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;awesome&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vandelay Industries&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./lib/main.d.ts&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>types</code>字段给出了类型声明文件的位置。</p>
<p>注意，如果类型声明文件名为<code>index.d.ts</code>，且在项目的根目录中，那就不需要在<code>package.json</code>里面注明了。</p>
<p>有时，类型声明文件会单独发布成一个 npm 模块，这时用户就必须同时加载该模块。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;browserify-typescript-extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vandelay Industries&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./lib/main.d.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;browserify&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/browserify&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescript&quot;</span>: <span class="string">&quot;next&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是一个模块的 package.json 文件，该模块需要 browserify 模块。由于后者的类型声明文件是一个单独的模块<code>@types/browserify</code>，所以还需要加载那个模块。</p>
<h2 id="三斜杠命令"><a href="#三斜杠命令" class="headerlink" title="三斜杠命令"></a>三斜杠命令</h2><p>如果类型声明文件的内容非常多，可以拆分成多个文件，然后入口文件使用三斜杠命令，加载其他拆分后的文件。</p>
<p>举例来说，入口文件是<code>main.d.ts</code>，里面的接口定义在<code>interfaces.d.ts</code>，函数定义在<code>functions.d.ts</code>。那么，<code>main.d.ts</code>里面可以用三斜杠命令，加载后面两个文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;./interfaces.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;./functions.d.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>三斜杠命令（<code>///</code>）是一个 TypeScript 编译器命令，用来指定编译器行为。它只能用在文件的头部，如果用在其他地方，会被当作普通的注释。另外，若一个文件中使用了三斜线命令，那么在三斜线命令之前只允许使用单行注释、多行注释和其他三斜线命令，否则三斜杠命令也会被当作普通的注释。</p>
<p>除了拆分类型声明文件，三斜杠命令也可以用于普通脚本加载类型声明文件。</p>
<p>三斜杠命令主要包含三个参数，代表三种不同的命令。</p>
<ul>
<li>path</li>
<li>types</li>
<li>lib</li>
</ul>
<p>下面依次进行讲解。</p>
<h3 id="lt-reference-path-quot-quot-gt"><a href="#lt-reference-path-quot-quot-gt" class="headerlink" title="/// &lt;reference path=&quot;&quot; /&gt;"></a><code>/// &lt;reference path=&quot;&quot; /&gt;</code></h3><p><code>/// &lt;reference path=&quot;&quot; /&gt;</code>是最常见的三斜杠命令，告诉编译器在编译时需要包括的文件，常用来声明当前脚本依赖的类型文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;./lib.ts&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例表示，当前脚本依赖于<code>./lib.ts</code>，里面是<code>add()</code>的定义。编译当前脚本时，还会同时编译<code>./lib.ts</code>。编译产物会有两个 JS 文件，一个当前脚本，另一个就是<code>./lib.js</code>。</p>
<p>下面的例子是当前脚本依赖于 Node.js 类型声明文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">URL</span> <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = <span class="variable constant_">URL</span>.<span class="title function_">parse</span>(<span class="string">&quot;https://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会在预处理阶段，找出所有三斜杠引用的文件，将其添加到编译列表中，然后一起编译。</p>
<p><code>path</code>参数指定了所引入文件的路径。如果该路径是一个相对路径，则基于当前脚本的路径进行计算。</p>
<p>使用该命令时，有以下两个注意事项。</p>
<ul>
<li><code>path</code>参数必须指向一个存在的文件，若文件不存在会报错。</li>
<li><code>path</code>参数不允许指向当前文件。</li>
</ul>
<p>默认情况下，每个三斜杠命令引入的脚本，都会编译成单独的 JS 文件。如果希望编译后只产出一个合并文件，可以使用编译选项<code>outFile</code>。但是，<code>outFile</code>编译选项不支持合并 CommonJS 模块和 ES 模块，只有当编译参数<code>module</code>的值设为 None、System 或 AMD 时，才能编译成一个文件。</p>
<p>如果打开了编译参数<code>noResolve</code>，则忽略三斜杠指令。将其当作一般的注释，原样保留在编译产物中。</p>
<h3 id="lt-reference-types-quot-quot-gt"><a href="#lt-reference-types-quot-quot-gt" class="headerlink" title="/// &lt;reference types=&quot;&quot; /&gt;"></a><code>/// &lt;reference types=&quot;&quot; /&gt;</code></h3><p>types 参数用来告诉编译器当前脚本依赖某个 DefinitelyTyped 类型库，通常安装在<code>node_modules/@types</code>目录。</p>
<p>types 参数的值是类型库的名称，也就是安装到<code>node_modules/@types</code>目录中的子目录的名字。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;node&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，这个三斜杠命令表示编译时添加 Node.js 的类型库，实际添加的脚本是<code>node_modules</code>目录里面的<code>@types/node/index.d.ts</code>。</p>
<p>可以看到，这个命令的作用类似于<code>import</code>命令。</p>
<p>注意，这个命令只在你自己手写类型声明文件（<code>.d.ts</code>文件）时，才有必要用到，也就是说，只应该用在<code>.d.ts</code>文件中，普通的<code>.ts</code>脚本文件不需要写这个命令。如果是普通的<code>.ts</code>脚本，可以使用<code>tsconfig.json</code>文件的<code>types</code>属性指定依赖的类型库。</p>
<h3 id="lt-reference-lib-quot-quot-gt"><a href="#lt-reference-lib-quot-quot-gt" class="headerlink" title="/// &lt;reference lib=&quot;&quot; /&gt;"></a><code>/// &lt;reference lib=&quot;&quot; /&gt;</code></h3><p><code>/// &lt;reference lib=&quot;...&quot; /&gt;</code>命令允许脚本文件显式包含内置 lib 库，等同于在<code>tsconfig.json</code>文件里面使用<code>lib</code>属性指定 lib 库。</p>
<p>前文说过，安装 TypeScript 软件包时，会同时安装一些内置的类型声明文件，即内置的 lib 库。这些库文件位于 TypeScript 安装目录的<code>lib</code>文件夹中，它们描述了 JavaScript 语言和引擎的标准 API。</p>
<p>库文件并不是固定的，会随着 TypeScript 版本的升级而更新。库文件统一使用“lib.[description].d.ts”的命名方式，而<code>/// &lt;reference lib=&quot;&quot; /&gt;</code>里面的<code>lib</code>属性的值就是库文件名的<code>description</code>部分，比如<code>lib=&quot;es2015&quot;</code>就表示加载库文件<code>lib.es2015.d.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference lib=&quot;es2017.string&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>es2017.string</code>对应的库文件就是<code>lib.es2017.string.d.ts</code>。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>declare 关键字</title>
    <url>/2023/09/05/ts-declare/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>declare 关键字用来告诉编译器，某个类型是存在的，可以在当前文件中使用。</p>
<p>它的主要作用，就是让当前文件可以使用其他文件声明的类型。举例来说，自己的脚本使用外部库定义的函数，编译器会因为不知道外部函数的类型定义而报错，这时就可以在自己的脚本里面使用<code>declare</code>关键字，告诉编译器外部函数的类型。这样的话，编译单个脚本就不会因为使用了外部类型而报错。</p>
<p>declare 关键字可以描述以下类型。</p>
<ul>
<li>变量（const、let、var 命令声明）</li>
<li>type 或者 interface 命令声明的类型</li>
<li>class</li>
<li>enum</li>
<li>函数（function）</li>
<li>模块（module）</li>
<li>命名空间（namespace）</li>
</ul>
<p>declare 关键字的重要特点是，它只是通知编译器某个类型是存在的，不用给出具体实现。比如，只描述函数的类型，不给出函数的实现，如果不使用<code>declare</code>，这是做不到的。</p>
<p>declare 只能用来描述已经存在的变量和数据结构，不能用来声明新的变量和数据结构。另外，所有 declare 语句都不会出现在编译后的文件里面。</p>
<h2 id="declare-variable"><a href="#declare-variable" class="headerlink" title="declare variable"></a>declare variable</h2><p>declare 关键字可以给出外部变量的类型描述。</p>
<p>举例来说，当前脚本使用了其他脚本定义的全局变量<code>x</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">x = <span class="number">123</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>是其他脚本定义的，当前脚本不知道它的类型，编译器就会报错。</p>
<p>这时使用 declare 命令给出它的类型，就不会报错了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果 declare 关键字没有给出变量的具体类型，那么变量类型就是<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> x;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型为<code>any</code>。</p>
<p>下面的例子是脚本使用浏览器全局对象<code>document</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="variable language_">document</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 告诉编译器，变量<code>document</code>的类型是外部定义的（具体定义在 TypeScript 内置文件<code>lib.d.ts</code>）。</p>
<p>如果 TypeScript 没有找到<code>document</code>的外部定义，这里就会假定它的类型是<code>any</code>。</p>
<p>注意，declare 关键字只用来给出类型描述，是纯的类型代码，不允许设置变量的初始值，即不能涉及值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 设置了变量的初始值，结果就报错了。</p>
<h2 id="declare-function"><a href="#declare-function" class="headerlink" title="declare function"></a>declare function</h2><p>declare 关键字可以给出外部函数的类型描述。</p>
<p>下面是一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 命令给出了<code>sayHello()</code>的类型描述，因此可以直接使用它。</p>
<p>注意，这种单独的函数类型声明语句，只能用于<code>declare</code>命令后面。一方面，TypeScript 不支持单独的函数类型声明语句；另一方面，declare 关键字后面也不能带有函数的具体实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;你好，&#x27;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，单独写函数的类型声明就会报错。</p>
<h2 id="declare-class"><a href="#declare-class" class="headerlink" title="declare class"></a>declare class</h2><p>declare 给出 class 类型描述的写法如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">eat</span>():<span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">sleep</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个复杂一点的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="comment">// 静态成员</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">s0</span>():<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">s1</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">b</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">arg:<span class="built_in">number</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="title function_">m</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存取器</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">c</span>():<span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">c</span>(<span class="params">value:<span class="built_in">number</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 索引签名</span></span><br><span class="line">  [<span class="attr">index</span>:<span class="built_in">string</span>]:<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，declare 后面不能给出 Class 的具体实现或初始值。</p>
<h2 id="declare-module，declare-namespace"><a href="#declare-module，declare-namespace" class="headerlink" title="declare module，declare namespace"></a>declare module，declare namespace</h2><p>如果想把变量、函数、类组织在一起，可以将 declare 与 module 或 namespace 一起使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">AnimalLib</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">eat</span>():<span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">sleep</span>():<span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="string">&#x27;Fish&#x27;</span> | <span class="string">&#x27;Dog&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="title class_">AnimalLib</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">eat</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">sleep</span>(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="string">&#x27;Fish&#x27;</span> | <span class="string">&#x27;Dog&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 关键字给出了 module 或 namespace 的类型描述。</p>
<p>declare module 和 declare namespace 里面，加不加 export 关键字都可以。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">a</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;io&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">filename:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，namespace 和 module 里面使用了 export 关键字。</p>
<p>下面的例子是当前脚本使用了<code>myLib</code>这个外部库，它有方法<code>makeGreeting()</code>和属性<code>numberOfGreetings</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = myLib.<span class="title function_">makeGreeting</span>(<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;欢迎词：&#x27;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = myLib.<span class="property">numberOfGreetings</span>;</span><br></pre></td></tr></table></figure>

<p><code>myLib</code>的类型描述就可以这样写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">makeGreeting</span>(<span class="params">s:<span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">numberOfGreetings</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>declare 关键字的另一个用途，是为外部模块添加属性和方法时，给出新增部分的类型描述。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Foo</span> <span class="keyword">as</span> <span class="title class_">Bar</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moduleA&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="attr">custom</span>: &#123;</span><br><span class="line">      <span class="attr">prop1</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，从模块<code>moduleA</code>导入了<code>Foo</code>接口，将其重命名为<code>Bar</code>，并用 declare 关键字为<code>Bar</code>增加一个属性<code>custom</code>。</p>
<p>下面是另一个例子。一个项目有多个模块，可以在一个模块中，对另一个模块的接口进行类型扩展。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;./a&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，脚本<code>a.ts</code>定义了一个接口<code>A</code>，脚本<code>b.ts</code>为这个接口添加了属性<code>y</code>。<code>declare module &#39;./a&#39; &#123;&#125;</code>表示对<code>a.ts</code>里面的模块，进行类型声明，而同名 interface 会自动合并，所以等同于扩展类型。</p>
<p>使用这种语法进行模块的类型扩展时，有两点需要注意：</p>
<p>（1）<code>declare module NAME</code>语法里面的模块名<code>NAME</code>，跟 import 和 export 的模块名规则是一样的，且必须跟当前文件加载该模块的语句写法（上例<code>import &#123; A &#125; from &#39;./a&#39;</code>）保持一致。</p>
<p>（2）不能创建新的顶层类型。也就是说，只能对<code>a.ts</code>模块中已经存在的类型进行扩展，不允许增加新的顶层类型，比如新定义一个接口<code>B</code>。</p>
<p>（3）不能对默认的<code>default</code>接口进行扩展，只能对 export 命令输出的命名接口进行扩充。这是因为在进行类型扩展时，需要依赖输出的接口名。</p>
<p>某些第三方模块，原始作者没有提供接口类型，这时可以在自己的脚本顶部加上下面一行命令。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;模块名&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;hot-new-module&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>加上上面的命令以后，外部模块即使没有类型声明，也可以通过编译。但是，从该模块输入的所有接口都将为<code>any</code>类型。</p>
<p>declare module 描述的模块名可以使用通配符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;my-plugin-*&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">PluginOptions</span> &#123;</span><br><span class="line">    <span class="attr">enabled</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">priority</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params">options: PluginOptions</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="keyword">export</span> = initialize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，模块名<code>my-plugin-*</code>表示适配所有以<code>my-plugin-</code>开头的模块名（比如<code>my-plugin-logger</code>）。</p>
<h2 id="declare-global"><a href="#declare-global" class="headerlink" title="declare global"></a>declare global</h2><p>如果要为 JavaScript 引擎的原生对象添加属性和方法，可以使用<code>declare global &#123;&#125;</code>语法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">toSmallString</span>(): <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toSmallString</span> = ():<span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 具体实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，为 JavaScript 原生的<code>String</code>对象添加了<code>toSmallString()</code>方法。declare global 给出这个新增方法的类型描述。</p>
<p>这个示例第一行的空导出语句<code>export &#123;&#125;</code>，作用是强制编译器将这个脚本当作模块处理。这是因为<code>declare global</code>必须用在模块里面。</p>
<p>下面的示例是为 window 对象添加一个属性<code>myAppConfig</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> window &#123;</span><br><span class="line">    <span class="attr">myAppConfig</span>:<span class="built_in">object</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="variable language_">window</span>.<span class="property">myAppConfig</span>;</span><br></pre></td></tr></table></figure>

<p>declare global 只能扩充现有对象的类型描述，不能增加新的顶层类型。</p>
<h2 id="declare-enum"><a href="#declare-enum" class="headerlink" title="declare enum"></a>declare enum</h2><p>declare 关键字给出 enum 类型描述的例子如下，下面的写法都是允许的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="variable constant_">E1</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="variable constant_">E2</span> &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">E3</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">E4</span> &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="declare-module-用于类型声明文件"><a href="#declare-module-用于类型声明文件" class="headerlink" title="declare module 用于类型声明文件"></a>declare module 用于类型声明文件</h2><p>我们可以为每个模块脚本，定义一个<code>.d.ts</code>文件，把该脚本用到的类型定义都放在这个文件里面。但是，更方便的做法是为整个项目，定义一个大的<code>.d.ts</code>文件，在这个文件里面使用<code>declare module</code>定义每个模块脚本的类型。</p>
<p>下面的示例是<code>node.d.ts</code>文件的一部分。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;url&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">    protocol?: <span class="built_in">string</span>;</span><br><span class="line">    hostname?: <span class="built_in">string</span>;</span><br><span class="line">    pathname?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params"></span></span><br><span class="line"><span class="params">    urlStr: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    parseQueryString?,</span></span><br><span class="line"><span class="params">    slashesDenoteHost?</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Url</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;path&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">sep</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>url</code>和<code>path</code>都是单独的模块脚本，但是它们的类型都定义在<code>node.d.ts</code>这个文件里面。</p>
<p>使用时，自己的脚本使用三斜杠命令，加载这个类型声明文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果没有上面这一行命令，自己的脚本使用外部模块时，就需要在脚本里面使用 declare 命令单独给出外部模块的类型。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://timmousk.com/blog/typescript-declare/">How Does The Declare Keyword Work In TypeScript?</a>, Tim Mouskhelichvili</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的 Enum 类型</title>
    <url>/2023/09/05/ts-enum/</url>
    <content><![CDATA[<div id="readmore-container"><p>Enum 是 TypeScript 新增的一种数据结构和类型，中文译为“枚举”。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>实际开发中，经常需要定义一组相关的常量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RED</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">GREEN</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BLUE</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> color = <span class="title function_">userInput</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (color === <span class="variable constant_">RED</span>) &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (color === <span class="variable constant_">GREEN</span>) &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (color === <span class="variable constant_">BLUE</span>) &#123;<span class="comment">/* */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong color&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，常量<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>是相关的，意为变量<code>color</code>的三个可能的取值。它们具体等于什么值其实并不重要，只要不相等就可以了。</p>
<p>TypeScript 就设计了 Enum 结构，用来将相关常量放在一个容器里面，方便使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,     <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span>,   <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Blue</span>     <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个 Enum 结构<code>Color</code>，里面包含三个成员<code>Red</code>、<code>Green</code>和<code>Blue</code>。第一个成员的值默认为整数<code>0</code>，第二个为<code>1</code>，第三个为<code>2</code>，以此类推。</p>
<p>使用时，调用 Enum 的某个成员，与调用对象属性的写法一样，可以使用点运算符，也可以使用方括号运算符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Color</span>[<span class="string">&#x27;Green&#x27;</span>]; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>Enum 结构本身也是一种类型。比如，上例的变量<code>c</code>等于<code>1</code>，它的类型可以是 Color，也可以是<code>number</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:<span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:<span class="built_in">number</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>c</code>的类型写成<code>Color</code>或<code>number</code>都可以。但是，<code>Color</code>类型的语义更好。</p>
<p>Enum 结构的特别之处在于，它既是一种类型，也是一个值。绝大多数 TypeScript 语法都是类型语法，编译后会全部去除，但是 Enum 结构是一个值，编译后会变成 JavaScript 对象，留在代码中。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,     <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span>,   <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Blue</span>     <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Color</span> = &#123;</span><br><span class="line">  <span class="title class_">Red</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Blue</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例是 Enum 结构编译前后的对比。</p>
<p>由于 TypeScript 的定位是 JavaScript 语言的类型增强，所以官方建议谨慎使用 Enum 结构，因为它不仅仅是类型，还会为编译后的代码加入一个对象。</p>
<p>Enum 结构比较适合的场景是，成员的值不重要，名字更重要，从而增加代码的可读性和可维护性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">  <span class="variable constant_">ADD</span>,</span><br><span class="line">  <span class="variable constant_">DIV</span>,</span><br><span class="line">  <span class="variable constant_">MUL</span>,</span><br><span class="line">  <span class="variable constant_">SUB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compute</span>(<span class="params"></span></span><br><span class="line"><span class="params">  op:Operator,</span></span><br><span class="line"><span class="params">  a:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  b:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">ADD</span>:</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">DIV</span>:</span><br><span class="line">      <span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">MUL</span>:</span><br><span class="line">      <span class="keyword">return</span> a * b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">SUB</span>:</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong operator&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">compute</span>(<span class="title class_">Operator</span>.<span class="property">ADD</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 结构<code>Operator</code>的四个成员表示四则运算“加减乘除”。代码根本不需要用到这四个成员的值，只用成员名就够了。</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#enum-overhaul">TypeScript 5.0</a> 之前，Enum 有一个 Bug，就是 Enum 类型的变量可以赋值为任何数值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Bool</span> &#123;</span><br><span class="line">  <span class="title class_">No</span>,</span><br><span class="line">  <span class="title class_">Yes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">noYes:Bool</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">33</span>);  <span class="comment">// TypeScript 5.0 之前不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>foo</code>的参数<code>noYes</code>是 Enum 类型，只有两个可用的值。但是，TypeScript 5.0 之前，任何数值作为函数<code>foo</code>的参数，编译都不会报错，TypeScript 5.0 纠正了这个问题。</p>
<p>另外，由于 Enum 结构编译后是一个对象，所以不能有与它同名的变量（包括对象、函数、类等）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Color</span> = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例，Enum 结构与变量同名，导致报错。</p>
<p>很大程度上，Enum 结构可以被对象的<code>as const</code>断言替代。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">A</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">B</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">C</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x === <span class="title class_">Foo</span>.<span class="property">A</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="title class_">Bar</span>.<span class="property">A</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>Bar</code>使用了<code>as const</code>断言，作用就是使得它的属性无法修改。这样的话，<code>Foo</code>和<code>Bar</code>的行为就很类似了，前者完全可以用后者替代，而且后者还是 JavaScript 的原生数据结构。</p>
<h2 id="Enum-成员的值"><a href="#Enum-成员的值" class="headerlink" title="Enum 成员的值"></a>Enum 成员的值</h2><p>Enum 成员默认不必赋值，系统会从零开始逐一递增，按照顺序为每个成员赋值，比如0、1、2……</p>
<p>但是，也可以为 Enum 成员显式赋值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 每个成员的值都是显式赋值。</p>
<p>成员的值可以是任意数值，但不能是大整数（Bigint）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">90</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">0.5</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">7n</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 成员的值可以是小数，但不能是 Bigint。</p>
<p>成员的值甚至可以相同。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只设定第一个成员的值，后面成员的值就会从这个值开始递增。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">Green</span>,  <span class="comment">// 8</span></span><br><span class="line">  <span class="title class_">Blue</span>   <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>, <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">Blue</span> <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum 成员的值也可以使用计算式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Permission</span> &#123;</span><br><span class="line">  <span class="title class_">UserRead</span>     = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">  <span class="title class_">UserWrite</span>    = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">UserExecute</span>  = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">  <span class="title class_">GroupRead</span>    = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  <span class="title class_">GroupWrite</span>   = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">  <span class="title class_">GroupExecute</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  <span class="title class_">AllRead</span>      = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">AllWrite</span>     = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">AllExecute</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Bool</span> &#123;</span><br><span class="line">  <span class="title class_">No</span> = <span class="number">123</span>,</span><br><span class="line">  <span class="title class_">Yes</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 成员的值等于一个计算式，或者等于函数的返回值，都是正确的。</p>
<p>Enum 成员值都是只读的，不能重新赋值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Color</span>.<span class="property">Red</span> = <span class="number">4</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，重新为 Enum 成员赋值就会报错。</p>
<p>为了让这一点更醒目，通常会在 enum 关键字前面加上<code>const</code>修饰，表示这是常量，不能再次赋值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上<code>const</code>还有一个好处，就是编译为 JavaScript 代码后，代码中 Enum 成员会被替换成对应的值，这样能提高性能表现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="title class_">Color</span>.<span class="property">Blue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">0</span> <span class="comment">/* Color.Red */</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">1</span> <span class="comment">/* Color.Green */</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="number">2</span> <span class="comment">/* Color.Blue */</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于 Enum 结构前面加了<code>const</code>关键字，所以编译产物里面就没有生成对应的对象，而是把所有 Enum 成员出现的场合，都替换成对应的常量。</p>
<p>如果希望加上<code>const</code>关键词后，运行时还能访问 Enum 结构（即编译后依然将 Enum 转成对象），需要在编译时打开<code>preserveConstEnums</code>编译选项。</p>
<h2 id="同名-Enum-的合并"><a href="#同名-Enum-的合并" class="headerlink" title="同名 Enum 的合并"></a>同名 Enum 的合并</h2><p>多个同名的 Enum 结构会自动合并。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  C = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B = <span class="number">1</span>，</span><br><span class="line">  C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Foo</code>分成三段定义，系统会自动把它们合并。</p>
<p>Enum 结构合并时，只允许其中一个的首成员省略初始值，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  B, <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Foo</code>的两段定义的第一个成员，都没有设置初始值，导致报错。</p>
<p>同名 Enum 合并时，不能有同名成员，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  B = <span class="number">1</span>, <span class="comment">// 报错</span></span><br><span class="line">  C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Foo</code>的两段定义有一个同名成员<code>B</code>，导致报错。</p>
<p>同名 Enum 合并的另一个限制是，所有定义必须同为 const 枚举或者非 const 枚举，不允许混合使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> E &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> E &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> E &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同名 Enum 的合并，最大用处就是补充外部定义的 Enum 结构。</p>
<h2 id="字符串-Enum"><a href="#字符串-Enum" class="headerlink" title="字符串 Enum"></a>字符串 Enum</h2><p>Enum 成员的值除了设为数值，还可以设为字符串。也就是说，Enum 也可以用作一组相关字符串的集合。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&#x27;RIGHT&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Direction</code>就是字符串枚举，每个成员的值都是字符串。</p>
<p>注意，字符串枚举的所有成员值，都必须显式设置。如果没有设置，成员值默认为数值，且位置必须在字符串成员之前。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A, <span class="comment">// 0</span></span><br><span class="line">  B = <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  C <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>之前没有其他成员，所以可以不设置初始值，默认等于<code>0</code>；<code>C</code>之前有一个字符串成员，所以<code>C</code>必须有初始值，不赋值就报错了。</p>
<p>Enum 成员可以是字符串和数值混合赋值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">  <span class="title class_">Three</span> = <span class="number">3</span>,</span><br><span class="line">  <span class="title class_">Four</span> = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了数值和字符串，Enum 成员不允许使用其他值（比如 Symbol 值）。</p>
<p>变量类型如果是字符串 Enum，就不能再赋值为字符串，这跟数值 Enum 不一样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">MyEnum</span>.<span class="property">One</span>;</span><br><span class="line">s = <span class="string">&#x27;One&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s</code>的类型是<code>MyEnum</code>，再赋值为字符串就报错。</p>
<p>由于这个原因，如果函数的参数类型是字符串 Enum，传参时就不能直接传入字符串，而要传入 Enum 成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg:MyEnum</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;arg is &#x27;</span> + arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;One&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数类型是<code>MyEnum</code>，直接传入字符串会报错。</p>
<p>所以，字符串 Enum 作为一种类型，有限定函数参数的作用。</p>
<p>前面说过，数值 Enum 的成员值往往不重要。但是有些场合，开发者可能希望 Enum 成员值可以保存一些有用的信息，所以 TypeScript 才设计了字符串 Enum。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">MediaTypes</span> &#123;</span><br><span class="line">  <span class="title class_">JSON</span> = <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">XML</span> = <span class="string">&#x27;application/xml&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="title class_">Accept</span>: <span class="title class_">MediaTypes</span>.<span class="property">JSON</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fetch()</code>的参数对象的属性<code>Accept</code>，只能接受一些指定的字符串。这时就很适合把字符串放进一个 Enum 结构，通过成员值来引用这些字符串。</p>
<p>字符串 Enum 可以使用联合类型（union）代替。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"></span></span><br><span class="line"><span class="params">  where:<span class="string">&#x27;Up&#x27;</span>|<span class="string">&#x27;Down&#x27;</span>|<span class="string">&#x27;Left&#x27;</span>|<span class="string">&#x27;Right&#x27;</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数参数<code>where</code>属于联合类型，效果跟指定为字符串 Enum 是一样的。</p>
<p>注意，字符串 Enum 的成员值，不能使用表达式赋值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">  B = [<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，成员<code>B</code>的值是一个字符串表达式，导致报错。</p>
<h2 id="keyof-运算符"><a href="#keyof-运算符" class="headerlink" title="keyof 运算符"></a>keyof 运算符</h2><p>keyof 运算符可以取出 Enum 结构的所有成员名，作为联合类型返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;A&#x27;|&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="keyword">typeof</span> <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>keyof typeof MyEnum</code>可以取出<code>MyEnum</code>的所有成员名，所以类型<code>Foo</code>等同于联合类型<code>&#39;A&#39;|&#39;B&#39;</code>。</p>
<p>注意，这里的<code>typeof</code>是必需的，否则<code>keyof MyEnum</code>相当于<code>keyof number</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="title class_">MyEnum</span>;</span><br><span class="line"><span class="comment">// &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; |</span></span><br><span class="line"><span class="comment">// &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Foo</code>等于类型<code>number</code>的所有原生属性名组成的联合类型。</p>
<p>这是因为 Enum 作为类型，本质上属于<code>number</code>或<code>string</code>的一种变体，而<code>typeof MyEnum</code>会将<code>MyEnum</code>当作一个值处理，从而先其转为对象类型，就可以再用<code>keyof</code>运算符返回该对象的所有属性名。</p>
<p>如果要返回 Enum 所有的成员值，可以使用<code>in</code>运算符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; a: any, b: any &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123; [key <span class="keyword">in</span> <span class="title class_">MyEnum</span>]: <span class="built_in">any</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，采用属性索引可以取出<code>MyEnum</code>的所有成员值。</p>
<h2 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h2><p>数值 Enum 存在反向映射，即可以通过成员值获得成员名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekdays</span> &#123;</span><br><span class="line">  <span class="title class_">Monday</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Tuesday</span>,</span><br><span class="line">  <span class="title class_">Wednesday</span>,</span><br><span class="line">  <span class="title class_">Thursday</span>,</span><br><span class="line">  <span class="title class_">Friday</span>,</span><br><span class="line">  <span class="title class_">Saturday</span>,</span><br><span class="line">  <span class="title class_">Sunday</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Weekdays</span>[<span class="number">3</span>]) <span class="comment">// Wednesday</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，Enum 成员<code>Wednesday</code>的值等于3，从而可以从成员值<code>3</code>取到对应的成员名<code>Wednesday</code>，这就叫反向映射。</p>
<p>这是因为 TypeScript 会将上面的 Enum 结构，编译成下面的 JavaScript 代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Weekdays</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Weekdays</span>) &#123;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Tuesday&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Wednesday&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Thursday&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Friday&quot;</span>] = <span class="number">5</span>] = <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Saturday&quot;</span>] = <span class="number">6</span>] = <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Sunday&quot;</span>] = <span class="number">7</span>] = <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Weekdays</span> || (<span class="title class_">Weekdays</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>上面代码中，实际进行了两组赋值，以第一个成员为例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Weekdays</span>[</span><br><span class="line">  <span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span></span><br><span class="line">] = <span class="string">&quot;Monday&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码有两个赋值运算符（<code>=</code>），实际上等同于下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Weekdays</span>[<span class="number">1</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这种情况只发生在数值 Enum，对于字符串 Enum，不存在反向映射。这是因为字符串 Enum 编译后只有一组赋值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyEnum</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">MyEnum</span>) &#123;</span><br><span class="line">    <span class="title class_">MyEnum</span>[<span class="string">&quot;A&quot;</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="title class_">MyEnum</span>[<span class="string">&quot;B&quot;</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">MyEnum</span> || (<span class="title class_">MyEnum</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 装饰器</title>
    <url>/2023/09/05/ts-decorator/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>装饰器（Decorator）是一种语法结构，用来在定义时修改类（class）的行为。</p>
<p>在语法上，装饰器有如下几个特征。</p>
<p>（1）第一个字符（或者说前缀）是<code>@</code>，后面是一个表达式。</p>
<p>（2）<code>@</code>后面的表达式，必须是一个函数（或者执行后可以得到一个函数）。</p>
<p>（3）这个函数接受所修饰对象的一些相关值作为参数。</p>
<p>（4）这个函数要么不返回值，要么返回一个新对象取代所修饰的目标对象。</p>
<p>举例来说，有一个函数<code>Injectable()</code>当作装饰器使用，那么需要写成<code>@Injectable</code>，然后放在某个类的前面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Injectable</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于有了装饰器<code>@Injectable</code>，类<code>A</code>的行为在运行时就会发生改变。</p>
<p>下面就是一个最简单的装饰器。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simpleDecorator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@simpleDecorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125; <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>simpleDecorator()</code>用作装饰器，附加在类<code>A</code>之上，后者在代码解析时就会打印一行日志。</p>
<p>编译上面的代码会报错，提示没有用到装饰器的参数。现在就为装饰器加上参数，让它更像正式运行的代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simpleDecorator</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  context:<span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hi, this is <span class="subst">$&#123;context.kind&#125;</span> <span class="subst">$&#123;context.name&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@simpleDecorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125; <span class="comment">// &quot;hi, this is class A&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码就可以顺利通过编译了，代码含义这里先不解释。大家只要理解，类<code>A</code>在执行前会先执行装饰器<code>simpleDecorator()</code>，并且会向装饰器自动传入参数就可以了。</p>
<p>装饰器有多种形式，基本上只要在<code>@</code>符号后面添加表达式都是可以的。下面都是合法的装饰器。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@myFunc</span></span><br><span class="line"><span class="meta">@myFuncFactory</span>(arg1, arg2)</span><br><span class="line"></span><br><span class="line"><span class="meta">@libraryModule</span>.<span class="property">prop</span></span><br><span class="line"><span class="meta">@someObj</span>.<span class="title function_">method</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">@(<span class="title function_">wrap</span>(dict[<span class="string">&#x27;prop&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>注意，<code>@</code>后面的表达式，最终执行后得到的应该是一个函数。</p>
<p>相比使用子类改变父类，装饰器更加简洁优雅，缺点是不那么直观，功能也受到一些限制。所以，装饰器一般只用来为类添加某种特定行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@frozen <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  @<span class="title function_">enumerable</span>(<span class="literal">true</span>)</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">throttle</span>(<span class="number">500</span>)</span><br><span class="line">  <span class="title function_">expensiveMethod</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，一共有四个装饰器，一个用在类本身（<code>@frozen</code>），另外三个用在类的方法（<code>@configurable</code>、<code>@enumerable</code>、<code>@throttle</code>）。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。</p>
<h2 id="装饰器的版本"><a href="#装饰器的版本" class="headerlink" title="装饰器的版本"></a>装饰器的版本</h2><p>TypeScript 从早期开始，就支持装饰器。但是，装饰器的语法后来发生了变化。ECMAScript 标准委员会最终通过的语法标准，与 TypeScript 早期使用的语法有很大差异。</p>
<p>目前，TypeScript 5.0 同时支持两种装饰器语法。标准语法可以直接使用，传统语法需要打开<code>--experimentalDecorators</code>编译参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure>

<p>本章介绍装饰器的标准语法，下一章介绍传统语法。</p>
<h2 id="装饰器的结构"><a href="#装饰器的结构" class="headerlink" title="装饰器的结构"></a>装饰器的结构</h2><p>装饰器函数的类型定义如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Decorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: DecoratedValue,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="built_in">string</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer?(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      get?(): <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      set?(value: <span class="built_in">unknown</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span> | <span class="title class_">ReplacementValue</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Decorator</code>是装饰器的类型定义。它是一个函数，使用时会接收到<code>value</code>和<code>context</code>两个参数。</p>
<ul>
<li><code>value</code>：所装饰的对象。</li>
<li><code>context</code>：上下文对象，TypeScript 提供一个原生接口<code>ClassMethodDecoratorContext</code>，描述这个对象。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decorator</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  context:ClassMethodDecoratorContext</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个装饰器函数，其中第二个参数<code>context</code>的类型就可以写成<code>ClassMethodDecoratorContext</code>。</p>
<p><code>context</code>对象的属性，根据所装饰对象的不同而不同，其中只有两个属性（<code>kind</code>和<code>name</code>）是必有的，其他都是可选的。</p>
<p>（1）<code>kind</code>：字符串，表示所装饰对象的类型，可能取以下的值。</p>
<ul>
<li>‘class’</li>
<li>‘method’</li>
<li>‘getter’</li>
<li>‘setter’</li>
<li>‘field’</li>
<li>‘accessor’</li>
</ul>
<p>这表示一共有六种类型的装饰器。</p>
<p>（2）<code>name</code>：字符串或者 Symbol 值，所装饰对象的名字，比如类名、属性名等。</p>
<p>（3）<code>addInitializer()</code>：函数，用来添加类的初始化逻辑。以前，这些逻辑通常放在构造函数里面，对方法进行初始化，现在改成以函数形式传入<code>addInitializer()</code>方法。注意，<code>addInitializer()</code>没有返回值。</p>
<p>（4）<code>private</code>：布尔值，表示所装饰的对象是否为类的私有成员。</p>
<p>（5）<code>static</code>：布尔值，表示所装饰的对象是否为类的静态成员。</p>
<p>（6）<code>access</code>：一个对象，包含了某个值的 get 和 set 方法。</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>类装饰器的类型描述如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;class&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>类装饰器接受两个参数：<code>value</code>（当前类本身）和<code>context</code>（上下文对象）。其中，<code>context</code>对象的<code>kind</code>属性固定为字符串<code>class</code>。</p>
<p>类装饰器一般用来对类进行操作，可以不返回任何值，请看下面的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    value.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> u = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">u.<span class="title function_">greet</span>(); <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类装饰器<code>@Greeter</code>在类<code>User</code>的原型对象上，添加了一个<code>greet()</code>方法，实例就可以直接使用该方法。</p>
<p>类装饰器可以返回一个函数，替代当前类的构造方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value:<span class="built_in">any</span>, context:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="keyword">function</span> (<span class="params">...args:<span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    instanceCount++;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    instance.<span class="property">count</span> = instanceCount;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line">  wrapper.<span class="property"><span class="keyword">prototype</span></span> = value.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// A</span></span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span> <span class="comment">// true</span></span><br><span class="line">inst1.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类装饰器<code>@countInstances</code>返回一个函数，替换了类<code>MyClass</code>的构造方法。新的构造方法实现了实例的计数，每新建一个实例，计数器就会加一，并且对实例添加<code>count</code>属性，表示当前实例的编号。</p>
<p>注意，上例为了确保新构造方法继承定义在<code>MyClass</code>的原型之上的成员，特别加入<code>A</code>行，确保两者的原型对象是一致的。否则，新的构造函数<code>wrapper</code>的原型对象，与<code>MyClass</code>不同，通不过<code>instanceof</code>运算符。</p>
<p>类装饰器也可以返回一个新的类，替代原来所装饰的类。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value:<span class="built_in">any</span>, context:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> value &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">...args:<span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(...args);</span><br><span class="line">      instanceCount++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = instanceCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span> <span class="comment">// true</span></span><br><span class="line">inst1.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>@countInstances</code>返回一个<code>MyClass</code>的子类。</p>
<p>下面的例子是通过类装饰器，禁止使用<code>new</code>命令新建类的实例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionCallable</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value <span class="keyword">as</span> <span class="built_in">any</span>, &#123;kind&#125; <span class="keyword">as</span> <span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;This function can’t be new-invoked&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@functionCallable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> robin = <span class="title class_">Person</span>(<span class="string">&#x27;Robin&#x27;</span>);</span><br><span class="line">robin.<span class="property">name</span> <span class="comment">// &#x27;Robin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类装饰器<code>@functionCallable</code>返回一个新的构造方法，里面判断<code>new.target</code>是否不为空，如果是的，就表示通过<code>new</code>命令调用，从而报错。</p>
<p>类装饰器的上下文对象<code>context</code>的<code>addInitializer()</code>方法，用来定义一个类的初始化函数，在类完全定义结束后执行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">customElement</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;<span class="title class_">Input</span> <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    value: Input,</span></span></span><br><span class="line"><span class="params"><span class="function">    context: ClassDecoratorContext</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> &#123;</span><br><span class="line">    context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      customElements.<span class="title function_">define</span>(name, value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@customElement</span>(<span class="string">&quot;hello-world&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;h1&gt;Hello World&lt;/h1&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>MyComponent</code>定义完成后，会自动执行类装饰器<code>@customElement()</code>给出的初始化函数，该函数会将当前类注册为指定名称（本例为<code>&lt;hello-world&gt;</code>）的自定义 HTML 元素。</p>
<h2 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h2><p>方法装饰器用来装饰类的方法（method）。它的类型描述如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassMethodDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;method&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>根据上面的类型，方法装饰器是一个函数，接受两个参数：<code>value</code>和<code>context</code>。</p>
<p>参数<code>value</code>是方法本身，参数<code>context</code>是上下文对象，有以下属性。</p>
<ul>
<li><code>kind</code>：值固定为字符串<code>method</code>，表示当前为方法装饰器。</li>
<li><code>name</code>：所装饰的方法名，类型为字符串或 Symbol 值。</li>
<li><code>static</code>：布尔值，表示是否为静态方法。该属性为只读属性。</li>
<li><code>private</code>：布尔值，表示是否为私有方法。该属性为只读属性。</li>
<li><code>access</code>：对象，包含了方法的存取器，但是只有<code>get()</code>方法用来取值，没有<code>set()</code>方法进行赋值。</li>
<li><code>addInitializer()</code>：为方法增加初始化函数。</li>
</ul>
<p>方法装饰器会改写类的原始方法，实质等同于下面的操作。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trace</span>(<span class="params">decoratedMethod</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@trace</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `@trace` 等同于</span></span><br><span class="line"><span class="comment">// C.prototype.toString = trace(C.prototype.toString);</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>@trace</code>是方法<code>toString()</code>的装饰器，它的效果等同于最后一行对<code>toString()</code>的改写。</p>
<p>如果方法装饰器返回一个新的函数，就会替代所装饰的原始函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`How are you, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>?`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@replaceMethod</span></span><br><span class="line">  <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> robin = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Robin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">robin.<span class="title function_">hello</span>() <span class="comment">// &#x27;How are you, Robin?&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器<code>@replaceMethod</code>返回的函数，就成为了新的<code>hello()</code>方法。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">originalMethod:<span class="built_in">any</span>, context:ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> methodName = <span class="title class_">String</span>(context.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">replacementMethod</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`LOG: Entering method &#x27;<span class="subst">$&#123;methodName&#125;</span>&#x27;.`</span>)</span><br><span class="line">    <span class="keyword">const</span> result = originalMethod.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`LOG: Exiting method &#x27;<span class="subst">$&#123;methodName&#125;</span>&#x27;.`</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> replacementMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">person.<span class="title function_">greet</span>()</span><br><span class="line"><span class="comment">// &quot;LOG: Entering method &#x27;greet&#x27;.&quot;</span></span><br><span class="line"><span class="comment">// &quot;Hello, my name is 张三.&quot;</span></span><br><span class="line"><span class="comment">// &quot;LOG: Exiting method &#x27;greet&#x27;.&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器<code>@log</code>的返回值是一个函数<code>replacementMethod</code>，替代了原始方法<code>greet()</code>。在<code>replacementMethod()</code>内部，通过执行<code>originalMethod.call()</code>完成了对原始方法的调用。</p>
<p>利用方法装饰器，可以将类的方法变成延迟执行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">milliseconds: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">value, context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&quot;method&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          value.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, milliseconds);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="meta">@delay</span>(<span class="number">1000</span>)</span><br><span class="line">  <span class="title function_">log</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logger = <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">logger.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，方法装饰器<code>@delay(1000)</code>将方法<code>log()</code>的执行推迟了1秒（1000毫秒）。这里真正的方法装饰器，是<code>delay()</code>执行后返回的函数，<code>delay()</code>的作用是接收参数，用来设置推迟执行的时间。这种通过高阶函数返回装饰器的做法，称为“工厂模式”，即可以像工厂那样生产出一个模子的装饰器。</p>
<p>方法装饰器的参数<code>context</code>对象里面，有一个<code>addInitializer()</code>方法。它是一个钩子方法，用来在类的初始化阶段，添加回调函数。这个回调函数就是作为<code>addInitializer()</code>的参数传入的，它会在构造方法执行期间执行，早于属性（field）的初始化。</p>
<p>下面是<code>addInitializer()</code>方法的一个例子。我们知道，类的方法往往需要在构造方法里面，进行<code>this</code>的绑定。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// greet() 绑定 this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greet</span> = <span class="variable language_">this</span>.<span class="property">greet</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>).<span class="property">greet</span>;</span><br><span class="line"><span class="title function_">g</span>() <span class="comment">// &quot;Hello, my name is 张三.&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，类<code>Person</code>的构造方法内部，将<code>this</code>与<code>greet()</code>方法进行了绑定。如果没有这一行，将<code>greet()</code>赋值给变量<code>g</code>进行调用，就会报错了。</p>
<p><code>this</code>的绑定必须放在构造方法里面，因为这必须在类的初始化阶段完成。现在，它可以移到方法装饰器的<code>addInitializer()</code>里面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params"></span></span><br><span class="line"><span class="params">  originalMethod:<span class="built_in">any</span>, context:ClassMethodDecoratorContext</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> methodName = context.<span class="property">name</span>;</span><br><span class="line">  <span class="keyword">if</span> (context.<span class="property">private</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`不能绑定私有方法 <span class="subst">$&#123;methodName <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[methodName] = <span class="variable language_">this</span>[methodName].<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，绑定<code>this</code>转移到了<code>addInitializer()</code>方法里面。</p>
<p>下面再看一个例子，通过<code>addInitializer()</code>将选定的方法名，放入一个集合。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">collect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value,</span></span><br><span class="line"><span class="params">  &#123;name, addInitializer&#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span>.<span class="title function_">add</span>(name);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@collect</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@collect</span></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">collectedMethodKeys</span> <span class="comment">// new Set([&#x27;toString&#x27;, Symbol.iterator])</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，方法装饰器<code>@collect</code>会将所装饰的成员名字，加入一个 Set 集合<code>collectedMethodKeys</code>。</p>
<h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><p>属性装饰器用来装饰定义在类顶部的属性（field）。它的类型描述如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassFieldDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;field&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span>, set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="function">(<span class="params">initialValue: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>注意，装饰器的第一个参数<code>value</code>的类型是<code>undefined</code>，这意味着这个参数实际上没用的，装饰器不能从<code>value</code>获取所装饰属性的值。另外，第二个参数<code>context</code>对象的<code>kind</code>属性的值为字符串<code>field</code>，而不是“property”或“attribute”，这一点是需要注意的。</p>
<p>属性装饰器要么不返回值，要么返回一个函数，该函数会自动执行，用来对所装饰属性进行初始化。该函数的参数是所装饰属性的初始值，该函数的返回值是该属性的最终值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logged</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, name &#125; = context;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;field&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">initialValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`initializing <span class="subst">$&#123;name&#125;</span> with value <span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> initialValue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="meta">@logged</span> name = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"><span class="comment">// &quot;initializing name with value green&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性装饰器<code>@logged</code>装饰属性<code>name</code>。<code>@logged</code>的返回值是一个函数，该函数用来对属性<code>name</code>进行初始化，它的参数<code>initialValue</code>就是属性<code>name</code>的初始值<code>green</code>。新建实例对象<code>color</code>时，该函数会自动执行。</p>
<p>属性装饰器的返回值函数，可以用来更改属性的初始值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">twice</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">initialValue</span> =&gt;</span> initialValue * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@twice</span></span><br><span class="line">  field = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">field</span> <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性装饰器<code>@twice</code>返回一个函数，该函数的返回值是属性<code>field</code>的初始值乘以2，所以属性<code>field</code>的最终值是6。</p>
<p>属性装饰器的上下文对象<code>context</code>的<code>access</code>属性，提供所装饰属性的存取器，请看下面的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> acc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">exposeAccess</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value, &#123;access&#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  acc = access;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="meta">@exposeAccess</span></span><br><span class="line">  name = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> green = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">green.<span class="property">name</span> <span class="comment">// &#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line">acc.<span class="title function_">get</span>(green) <span class="comment">// &#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line">acc.<span class="title function_">set</span>(green, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">green.<span class="property">name</span> <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>access</code>包含了属性<code>name</code>的存取器，可以对该属性进行取值和赋值。</p>
<h2 id="getter-装饰器，setter-装饰器"><a href="#getter-装饰器，setter-装饰器" class="headerlink" title="getter 装饰器，setter 装饰器"></a>getter 装饰器，setter 装饰器</h2><p>getter 装饰器和 setter 装饰器，是分别针对类的取值器（getter）和存值器（setter）的装饰器。它们的类型描述如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassGetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;getter&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClassSetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;setter&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>注意，getter 装饰器的上下文对象<code>context</code>的<code>access</code>属性，只包含<code>get()</code>方法；setter 装饰器的<code>access</code>属性，只包含<code>set()</code>方法。</p>
<p>这两个装饰器要么不返回值，要么返回一个函数，取代原来的取值器或存值器。</p>
<p>下面的例子是将取值器的结果，保存为一个属性，加快后面的读取。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@lazy</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在计算……&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;开销大的计算结果&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  &#123;kind, name&#125;:<span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;getter&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = value.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">        <span class="variable language_">this</span>, name,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">value</span>: result,</span><br><span class="line">          <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">value</span></span><br><span class="line"><span class="comment">// 正在计算……</span></span><br><span class="line"><span class="comment">// &#x27;开销大的计算结果&#x27;</span></span><br><span class="line">inst.<span class="property">value</span></span><br><span class="line"><span class="comment">// &#x27;开销大的计算结果&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第一次读取<code>inst.value</code>，会进行计算，然后装饰器<code>@lazy</code>将结果存入只读属性<code>value</code>，后面再读取这个属性，就不会进行计算了。</p>
<h2 id="accessor-装饰器"><a href="#accessor-装饰器" class="headerlink" title="accessor 装饰器"></a>accessor 装饰器</h2><p>装饰器语法引入了一个新的属性修饰符<code>accessor</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  accessor x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>accessor</code>修饰符等同于为属性<code>x</code>自动生成取值器和存值器，它们作用于私有属性<code>x</code>。也就是说，上面的代码等同于下面的代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">x</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">x</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#x = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>accessor</code>也可以与静态属性和私有属性一起使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> accessor x = <span class="number">1</span>;</span><br><span class="line">  accessor #y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>accessor 装饰器的类型如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassAutoAccessorDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    get: () =&gt; <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;accessor&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get(): <span class="built_in">unknown</span>, set(value: <span class="built_in">unknown</span>): <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  get?: <span class="function">() =&gt;</span> <span class="built_in">unknown</span>;</span><br><span class="line">  set?: <span class="function">(<span class="params">value: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  init?: <span class="function">(<span class="params">initialValue: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span>;</span><br><span class="line">&#125; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>accessor 装饰器的<code>value</code>参数，是一个包含<code>get()</code>方法和<code>set()</code>方法的对象。该装饰器可以不返回值，或者返回一个新的对象，用来取代原来的<code>get()</code>方法和<code>set()</code>方法。此外，装饰器返回的对象还可以包括一个<code>init()</code>方法，用来改变私有属性的初始值。</p>
<p>下面是一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@logged</span> accessor x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logged</span>(<span class="params">value, &#123; kind, name &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;accessor&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; get, set &#125; = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> get.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;name&#125;</span> to <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> set.<span class="title function_">call</span>(<span class="variable language_">this</span>, val);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="title function_">init</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`initializing <span class="subst">$&#123;name&#125;</span> with value <span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> initialValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="property">x</span>;</span><br><span class="line"><span class="comment">// getting x</span></span><br><span class="line"></span><br><span class="line">c.<span class="property">x</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setting x to 123</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器<code>@logged</code>为属性<code>x</code>的存值器和取值器，加上了日志输出。</p>
<h2 id="装饰器的执行顺序"><a href="#装饰器的执行顺序" class="headerlink" title="装饰器的执行顺序"></a>装饰器的执行顺序</h2><p>装饰器的执行分为两个阶段。</p>
<p>（1）评估（evaluation）：计算<code>@</code>符号后面的表达式的值，得到的应该是函数。</p>
<p>（2）应用（application）：将评估装饰器后得到的函数，应用于所装饰对象。</p>
<p>也就是说，装饰器的执行顺序是，先评估所有装饰器表达式的值，再将其应用于当前类。</p>
<p>应用装饰器时，顺序依次为方法装饰器和属性装饰器，然后是类装饰器。</p>
<p>请看下面的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">d</span>(<span class="params">str:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`评估 @d(): <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    value:<span class="built_in">any</span>, context:<span class="built_in">any</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`应用 @d(): <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">str:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@d</span>(<span class="string">&#x27;类装饰器&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">  <span class="meta">@d</span>(<span class="string">&#x27;静态属性装饰器&#x27;</span>)</span><br><span class="line">  <span class="keyword">static</span> staticField = <span class="title function_">log</span>(<span class="string">&#x27;静态属性值&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@d</span>(<span class="string">&#x27;原型方法&#x27;</span>)</span><br><span class="line">  [<span class="title function_">log</span>(<span class="string">&#x27;计算方法名&#x27;</span>)]() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@d</span>(<span class="string">&#x27;实例属性&#x27;</span>)</span><br><span class="line">  instanceField = <span class="title function_">log</span>(<span class="string">&#x27;实例属性值&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>T</code>有四种装饰器：类装饰器、静态属性装饰器、方法装饰器、属性装饰器。</p>
<p>它的运行结果如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;评估 @d(): 类装饰器&quot;</span></span><br><span class="line"><span class="comment">// &quot;评估 @d(): 静态属性装饰器&quot;</span></span><br><span class="line"><span class="comment">// &quot;评估 @d(): 原型方法&quot;</span></span><br><span class="line"><span class="comment">// &quot;计算方法名&quot;</span></span><br><span class="line"><span class="comment">// &quot;评估 @d(): 实例属性&quot;</span></span><br><span class="line"><span class="comment">// &quot;应用 @d(): 原型方法&quot;</span></span><br><span class="line"><span class="comment">// &quot;应用 @d(): 静态属性装饰器&quot;</span></span><br><span class="line"><span class="comment">// &quot;应用 @d(): 实例属性&quot;</span></span><br><span class="line"><span class="comment">// &quot;应用 @d(): 类装饰器&quot;</span></span><br><span class="line"><span class="comment">// &quot;静态属性值&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，类载入的时候，代码按照以下顺序执行。</p>
<p>（1）装饰器评估：这一步计算装饰器的值，首先是类装饰器，然后是类内部的装饰器，按照它们出现的顺序。</p>
<p>注意，如果属性名或方法名是计算值（本例是“计算方法名”），则它们在对应的装饰器评估之后，也会进行自身的评估。</p>
<p>（2）装饰器应用：实际执行装饰器函数，将它们与对应的方法和属性进行结合。</p>
<p>原型方法的装饰器首先应用，然后是静态属性和静态方法装饰器，接下来是实例属性装饰器，最后是类装饰器。</p>
<p>注意，“实例属性值”在类初始化的阶段并不执行，直到类实例化时才会执行。</p>
<p>如果一个方法或属性有多个装饰器，则内层的装饰器先执行，外层的装饰器后执行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@bound</span></span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>greet()</code>有两个装饰器，内层的<code>@log</code>先执行，外层的<code>@bound</code>针对得到的结果再执行。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://2ality.com/2022/10/javascript-decorators.html">JavaScript metaprogramming with the 2022-03 decorators API</a></li>
<li><a href="https://plainenglish.io/blog/ts-5-0-beta-new-decorators-are-here">TS 5.0 Beta: New Decorators Are Here!</a>, Bytefer</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>装饰器（旧语法）</title>
    <url>/2023/09/05/ts-decorator-legacy/</url>
    <content><![CDATA[<div id="readmore-container"><p>上一章介绍了装饰器的标准语法，那是在2022年通过成为标准的。但是在此之前，TypeScript 早在2014年就支持装饰器，不过使用的是旧语法。</p>
<p>装饰器的旧语法与标准语法，有相当大的差异。旧语法以后会被淘汰，但是目前大量现有项目依然在使用它，本章就介绍旧语法下的装饰器。</p>
<h2 id="experimentalDecorators-编译选项"><a href="#experimentalDecorators-编译选项" class="headerlink" title="experimentalDecorators 编译选项"></a>experimentalDecorators 编译选项</h2><p>使用装饰器的旧语法，需要打开<code>--experimentalDecorators</code>编译选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure>

<p>此外，还有另外一个编译选项<code>--emitDecoratorMetadata</code>，用来产生一些装饰器的元数据，供其他工具或某些模块（比如 reflect-metadata ）使用。</p>
<p>这两个编译选项可以在命令行设置，也可以在<code>tsconfig.json</code>文件里面进行设置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰器的种类"><a href="#装饰器的种类" class="headerlink" title="装饰器的种类"></a>装饰器的种类</h2><p>按照所装饰的不同对象，装饰器可以分成五类。</p>
<blockquote>
<ul>
<li>类装饰器（Class Decorators）：用于类。</li>
<li>属性装饰器（Property Decorators）：用于属性。</li>
<li>方法装饰器（Method Decorators）：用于方法。</li>
<li>存取器装饰器（Accessor Decorators）：用于类的 set 或 get 方法。</li>
<li>参数装饰器（Parameter Decorators）：用于方法的参数。</li>
</ul>
</blockquote>
<p>下面是这五种装饰器一起使用的一个示例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ClassDecorator</span>() <span class="comment">// （A）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PropertyDecorator</span>() <span class="comment">// （B）</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MethodDecorator</span>() <span class="comment">//（C）</span></span><br><span class="line">  <span class="title function_">fly</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@ParameterDecorator</span>() <span class="comment">// （D）</span></span></span><br><span class="line"><span class="params">    meters: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AccessorDecorator</span>() <span class="comment">// （E）</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">egg</span>() &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">egg</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，A 是类装饰器，B 是属性装饰器，C 是方法装饰器，D 是参数装饰器，E 是存取器装饰器。</p>
<p>注意，构造方法没有方法装饰器，只有参数装饰器。类装饰器其实就是在装饰构造方法。</p>
<p>另外，装饰器只能用于类，要么应用于类的整体，要么应用于类的内部成员，不能用于独立的函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Decorator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;In Decorator&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorator</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decorated</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;in decorated&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器用于一个普通函数，这是无效的，结果报错。</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>类装饰器应用于类（class），但实际上是应用于类的构造方法。</p>
<p>类装饰器有唯一参数，就是构造方法，可以在装饰器内部，对构造方法进行各种改造。如果类装饰器有返回值，就会替换掉原来的构造方法。</p>
<p>类装饰器的类型定义如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = &lt;<span class="title class_">TFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span>&gt;</span><br><span class="line">  <span class="function">(<span class="params">target: TFunction</span>) =&gt;</span> <span class="title class_">TFunction</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>上面定义中，类型参数<code>TFunction</code>必须是函数，实际上就是构造方法。类装饰器的返回值，要么是返回处理后的原始构造方法，要么返回一个新的构造方法。</p>
<p>下面就是一个示例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;apply decorator&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@f</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 输出：apply decorator</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，使用了装饰器<code>@f</code>，因此类<code>A</code>的构造方法会自动传入<code>f</code>。</p>
<p>类<code>A</code>不需要新建实例，装饰器也会执行。装饰器会在代码加载阶段执行，而不是在运行时执行，而且只会执行一次。</p>
<p>由于 TypeScript 存在编译阶段，所以装饰器对类的行为的改变，实际上发生在编译阶段。这意味着，TypeScript 装饰器能在编译阶段运行代码，也就是说，它本质就是编译时执行的函数。</p>
<p>下面再看一个示例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@sealed</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BugReport</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">&quot;report&quot;</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">t:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sealed</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器<code>@sealed()</code>会锁定<code>BugReport</code>这个类，使得它无法新增或删除静态成员和实例成员。</p>
<p>如果除了构造方法，类装饰器还需要其他参数，可以采取“工厂模式”，即把装饰器写在一个函数里面，该函数可以接受其他参数，执行后返回装饰器。但是，这样就需要调用装饰器的时候，先执行一次工厂函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factory</span>(<span class="params">info:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;received: &#x27;</span>, info);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;apply decorator&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@factory</span>(<span class="string">&#x27;log something&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>factory()</code>的返回值才是装饰器，所以加载装饰器的时候，要先执行一次<code>@factory(&#39;log something&#39;)</code>，才能得到装饰器。这样做的好处是，可以加入额外的参数，本例是参数<code>info</code>。</p>
<p>总之，<code>@</code>后面要么是一个函数名，要么是函数表达式，甚至可以写出下面这样的代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">@(<span class="function">(<span class="params">constructor: <span class="built_in">Function</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;log something&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InlineDecoratorExample</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>@</code>后面是一个箭头函数，这也是合法的。</p>
<p>类装饰器可以没有返回值，如果有返回值，就会替代所装饰的类的构造函数。由于 JavaScript 的类等同于构造函数的语法糖，所以装饰器通常返回一个新的类，对原有的类进行修改或扩展。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decorator</span>(<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> target &#123;</span><br><span class="line">    value = <span class="number">123</span>;  </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  value = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">value</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器<code>decorator</code>返回一个新的类，替代了原来的类。</p>
<p>上例的装饰器参数<code>target</code>类型是<code>any</code>，可以改成构造方法，这样就更准确了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Constructor</span> = &#123;</span><br><span class="line">  <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> decorator&lt;T <span class="keyword">extends</span> <span class="title class_">Constructor</span>&gt; (</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> target &#123;</span><br><span class="line">    value = <span class="number">123</span>;  </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，装饰器的行为就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">A = <span class="title function_">decorator</span>(A) || A;</span><br></pre></td></tr></table></figure>

<p>上面代码中，装饰器要么返回一个新的类<code>A</code>，要么不返回任何值，<code>A</code>保持装饰器处理后的状态。</p>
<h2 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h2><p>方法装饰器用来装饰类的方法，它的类型定义如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MethodDecorator</span> = &lt;T&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>方法装饰器一共可以接受三个参数。</p>
<ul>
<li>target：（对于类的静态方法）类的构造函数，或者（对于类的实例方法）类的原型。</li>
<li>propertyKey：所装饰方法的方法名，类型为<code>string|symbol</code>。</li>
<li>descriptor：所装饰方法的描述对象。</li>
</ul>
<p>方法装饰器的返回值（如果有的话），就是修改后的该方法的描述对象，可以覆盖原始方法的描述对象。</p>
<p>下面是一个示例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enumerable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    descriptor.<span class="property">enumerable</span> = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@enumerable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，方法装饰器<code>@enumerable()</code>装饰 Greeter 类的<code>greet()</code>方法，作用是修改该方法的描述对象的可遍历性属性<code>enumerable</code>。<code>@enumerable(false)</code>表示将该方法修改成不可遍历。</p>
<p>下面再看一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logger</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  propertyKey: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> original = descriptor.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;params: &#x27;</span>, ...args);</span><br><span class="line">    <span class="keyword">const</span> result = original.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@logger</span></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span> </span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title function_">C</span>()).<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// params:  1 2</span></span><br><span class="line"><span class="comment">// result:  3</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，方法装饰器<code>@logger</code>用来装饰<code>add()</code>方法，它的作用是让该方法输出日志。每当<code>add()</code>调用一次，控制台就会打印出参数和运行结果。</p>
<h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><p>属性装饰器用来装饰属性，类型定义如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropertyDecorator</span> =</span><br><span class="line">  <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>属性装饰器函数接受两个参数。</p>
<ul>
<li>target：（对于实例属性）类的原型对象（prototype），或者（对于静态属性）类的构造函数。</li>
<li>propertyKey：所装饰属性的属性名，注意类型有可能是字符串，也有可能是 Symbol 值。</li>
</ul>
<p>属性装饰器不需要返回值，如果有的话，也会被忽略。</p>
<p>下面是一个示例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ValidRange</span>(<span class="params">min:<span class="built_in">number</span>, max:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target:<span class="built_in">Object</span>, key:<span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">      <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">v:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; min || v &gt; max) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Not allowed value <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 Installing ValidRange on year</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="meta">@ValidRange</span>(<span class="number">1920</span>, <span class="number">2020</span>)</span><br><span class="line">  year!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stud = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 Not allowed value 2022 </span></span><br><span class="line">stud.<span class="property">year</span> = <span class="number">2022</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器<code>ValidRange</code>对属性<code>year</code>设立了一个上下限检查器，只要该属性赋值时，超过了上下限，就会报错。</p>
<p>注意，属性装饰器的第一个参数，对于实例属性是类的原型对象，而不是实例对象（即不是<code>this</code>对象）。这是因为装饰器执行时，类还没有新建实例，所以实例对象不存在。</p>
<p>由于拿不到<code>this</code>，所以属性装饰器无法获得实例属性的值。这也是它没有在参数里面提供属性描述对象的原因。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProperty</span>(<span class="params">target: <span class="built_in">Object</span>, member: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prop = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, member);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Property <span class="subst">$&#123;member&#125;</span> <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyExample</span> &#123;</span><br><span class="line">  <span class="meta">@logProperty</span></span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span> = <span class="string">&#x27;Foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 Property name undefined</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性装饰器<code>@logProperty</code>内部想要获取实例属性<code>name</code>的属性描述对象，结果拿到的是<code>undefined</code>。因为上例的<code>target</code>是类的原型对象，不是实例对象，所以拿不到<code>name</code>属性，也就是说<code>target.name</code>是不存在的，所以拿到的是<code>undefined</code>。只有通过<code>this.name</code>才能拿到<code>name</code>属性，但是这时<code>this</code>还不存在。</p>
<p>属性装饰器不仅无法获得实例属性的值，也不能初始化或修改实例属性，而且它的返回值也会被忽略。因此，它的作用很有限。</p>
<p>不过，如果属性装饰器设置了当前属性的存取器（getter&#x2F;setter），然后在构造函数里面就可以对实例属性进行读写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Min</span>(<span class="params">limit:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    propertyKey: <span class="built_in">string</span></span></span><br><span class="line"><span class="params">  </span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> setter = <span class="keyword">function</span>(<span class="params">newVal:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(newVal.<span class="property">length</span> &lt; limit) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Your password should be bigger than <span class="subst">$&#123;limit&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, propertyKey, &#123;</span><br><span class="line">      <span class="attr">get</span>: getter,</span><br><span class="line">      <span class="attr">set</span>: setter</span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Min</span>(<span class="number">8</span>)</span><br><span class="line">  <span class="attr">password</span>: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">username: <span class="built_in">string</span>, password: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">username</span> = username;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">password</span> = password;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> u = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;Foo&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>); </span><br><span class="line"><span class="comment">// 报错 Your password should be bigger than 8 </span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性装饰器<code>@Min</code>通过设置存取器，拿到了实例属性的值。</p>
<h2 id="存取器装饰器"><a href="#存取器装饰器" class="headerlink" title="存取器装饰器"></a>存取器装饰器</h2><p>存取器装饰器用来装饰类的存取器（accessor）。所谓“存取器”指的是某个属性的取值器（getter）和存值器（setter）。</p>
<p>存取器装饰器的类型定义，与方法装饰器一致。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AccessorDecorator</span> = &lt;T&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>存取器装饰器有三个参数。</p>
<ul>
<li>target：（对于静态属性的存取器）类的构造函数，或者（对于实例属性的存取器）类的原型。</li>
<li>propertyKey：存取器的属性名。</li>
<li>descriptor：存取器的属性描述对象。</li>
</ul>
<p>存取器装饰器的返回值（如果有的话），会作为该属性新的描述对象。</p>
<p>下面是一个示例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">configurable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    descriptor.<span class="property">configurable</span> = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">x</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_x</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">y</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_y</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器<code>@configurable(false)</code>关闭了所装饰属性（<code>x</code>和<code>y</code>）的属性描述对象的<code>configurable</code>键（即关闭了属性的可配置性）。</p>
<p>下面的示例是将装饰器用来验证属性值，如果赋值不满足条件就报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">validator</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  propertyKey: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> originalGet = descriptor.<span class="property">get</span>;</span><br><span class="line">  <span class="keyword">const</span> originalSet = descriptor.<span class="property">set</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (originalSet) &#123;</span><br><span class="line">    descriptor.<span class="property">set</span> = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid value for <span class="subst">$&#123;propertyKey&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      originalSet.<span class="title function_">call</span>(<span class="variable language_">this</span>, val);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #foo!: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@validator</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#foo = v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">foo</span> = <span class="number">150</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器用自己定义的存值器，取代了原来的存值器，加入了验证条件。</p>
<p>TypeScript 不允许对同一个属性的存取器（getter 和 setter）使用同一个装饰器，也就是说只能装饰两个存取器里面的一个，且必须是排在前面的那一个，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Decorator</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">n:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Decorator</span> <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>@Decorator</code>同时装饰<code>name</code>属性的存值器和取值器，所以报错。</p>
<p>但是，下面的写法不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Decorator</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">n:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>@Decorator</code>只装饰它后面第一个出现的存值器（<code>set name()</code>），并不装饰取值器（<code>get name()</code>），所以不报错。</p>
<p>装饰器之所以不能同时用于同一个属性的存值器和取值器，原因是装饰器可以从属性描述对象上面，同时拿到取值器和存值器，因此只调用一次就够了。</p>
<h2 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h2><p>参数装饰器用来装饰构造方法或者其他方法的参数。它的类型定义如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ParameterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parameterIndex: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>参数装饰器接受三个参数。</p>
<ul>
<li>target：（对于静态方法）类的构造函数，或者（对于类的实例方法）类的原型对象。</li>
<li>propertyKey：所装饰的方法的名字，类型为<code>string|symbol</code>。</li>
<li>parameterIndex：当前参数在方法的参数序列的位置（从0开始）。</li>
</ul>
<p>该装饰器不需要返回值，如果有的话会被忽略。</p>
<p>下面是一个示例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">  parameterIndex: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">String</span>(propertyKey)&#125;</span> NO.<span class="subst">$&#123;parameterIndex&#125;</span> Parameter`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="title function_">member</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@log</span> x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="meta">@log</span> y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`member Parameters: <span class="subst">$&#123;x&#125;</span> <span class="subst">$&#123;y&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="title function_">member</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// member NO.1 Parameter</span></span><br><span class="line"><span class="comment">// member NO.0 Parameter </span></span><br><span class="line"><span class="comment">// member Parameters: 5 5 </span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数装饰器会输出参数的位置序号。注意，后面的参数会先输出。</p>
<p>跟其他装饰器不同，参数装饰器主要用于输出信息，没有办法修改类的行为。</p>
<h2 id="装饰器的执行顺序"><a href="#装饰器的执行顺序" class="headerlink" title="装饰器的执行顺序"></a>装饰器的执行顺序</h2><p>前面说过，装饰器只会执行一次，就是在代码解析时执行，哪怕根本没有调用类新建实例，也会执行，而且从此就不再执行了。</p>
<p>执行装饰器时，按照如下顺序执行。</p>
<ol>
<li>实例相关的装饰器。</li>
<li>静态相关的装饰器。</li>
<li>构造方法的参数装饰器。</li>
<li>类装饰器。</li>
</ol>
<p>请看下面的示例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key:<span class="built_in">string</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行：&#x27;</span>, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@f</span>(<span class="string">&#x27;类装饰器&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;实例方法&#x27;</span>)</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="meta">@f</span>(<span class="string">&#x27;构造方法参数&#x27;</span>) foo:<span class="built_in">any</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载上面的示例，输出如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">执行： 实例方法</span><br><span class="line">执行： 静态方法</span><br><span class="line">执行： 构造方法参数</span><br><span class="line">执行： 类装饰器</span><br></pre></td></tr></table></figure>

<p>同一级装饰器的执行顺序，是按照它们的代码顺序。但是，参数装饰器的执行总是早于方法装饰器。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key:<span class="built_in">string</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行：&#x27;</span>, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;方法1&#x27;</span>)</span><br><span class="line">  <span class="title function_">m1</span>(<span class="params"><span class="meta">@f</span>(<span class="string">&#x27;参数1&#x27;</span>) foo:<span class="built_in">any</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;属性1&#x27;</span>)</span><br><span class="line">  <span class="attr">p1</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;方法2&#x27;</span>)</span><br><span class="line">  <span class="title function_">m2</span>(<span class="params"><span class="meta">@f</span>(<span class="string">&#x27;参数2&#x27;</span>) foo:<span class="built_in">any</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;属性2&#x27;</span>)</span><br><span class="line">  <span class="attr">p2</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载上面的示例，输出如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">执行： 参数<span class="number">1</span></span><br><span class="line">执行： 方法<span class="number">1</span></span><br><span class="line">执行： 属性<span class="number">1</span></span><br><span class="line">执行： 参数<span class="number">2</span></span><br><span class="line">执行： 方法<span class="number">2</span></span><br><span class="line">执行： 属性<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，实例装饰器的执行顺序，完全是按照代码顺序的。但是，同一个方法的参数装饰器，总是早于该方法的方法装饰器执行。</p>
<p>如果同一个方法或属性有多个装饰器，那么装饰器将顺序加载、逆序执行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key:<span class="built_in">string</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加载：&#x27;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行：&#x27;</span>, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">  <span class="title function_">m1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载： A</span></span><br><span class="line"><span class="comment">// 加载： B</span></span><br><span class="line"><span class="comment">// 加载： C</span></span><br><span class="line"><span class="comment">// 执行： C</span></span><br><span class="line"><span class="comment">// 执行： B</span></span><br><span class="line"><span class="comment">// 执行： A</span></span><br></pre></td></tr></table></figure>

<p>如果同一个方法有多个参数，那么参数也是顺序加载、逆序执行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key:<span class="built_in">string</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加载：&#x27;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行：&#x27;</span>, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@f</span>(<span class="string">&#x27;A&#x27;</span>) a:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    <span class="meta">@f</span>(<span class="string">&#x27;B&#x27;</span>) b:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    <span class="meta">@f</span>(<span class="string">&#x27;C&#x27;</span>) c:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载： A</span></span><br><span class="line"><span class="comment">// 加载： B</span></span><br><span class="line"><span class="comment">// 加载： C</span></span><br><span class="line"><span class="comment">// 执行： C</span></span><br><span class="line"><span class="comment">// 执行： B</span></span><br><span class="line"><span class="comment">// 执行： A</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么装饰器不能用于函数？"><a href="#为什么装饰器不能用于函数？" class="headerlink" title="为什么装饰器不能用于函数？"></a>为什么装饰器不能用于函数？</h2><p>装饰器只能用于类和类的方法，不能用于函数，主要原因是存在函数提升。</p>
<p>JavaScript 的函数不管在代码的什么位置，都会提升到代码顶部。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addOne</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addOne</span>(<span class="params">n:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>addOne()</code>不会因为在定义之前执行而报错，原因就是函数存在提升，会自动提升到代码顶部。</p>
<p>如果允许装饰器可以用于普通函数，那么就有可能导致意想不到的情况。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@add</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，本来的意图是装饰器<code>@add</code>每使用一次，变量<code>counter</code>就加<code>1</code>，但是实际上会报错，因为函数提升的存在，使得实际执行的代码是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@add <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span> (<span class="params">target:any</span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>@add</code>还没有定义就调用了，从而报错。</p>
<p>总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p>
<p>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行，没必要写成装饰器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loggingDecorator</span>(<span class="params">wrapped</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Starting&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = wrapped.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finished&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = <span class="title function_">loggingDecorator</span>(doSomething);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>loggingDecorator()</code>是一个装饰器，只要把原始函数传入它执行，就能起到装饰器的效果。</p>
<h2 id="多个装饰器的合成"><a href="#多个装饰器的合成" class="headerlink" title="多个装饰器的合成"></a>多个装饰器的合成</h2><p>多个装饰器可以应用于同一个目标对象，可以写在一行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@f</span> <span class="meta">@g</span> x</span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器<code>@f</code>和<code>@g</code>同时装饰目标对象<code>x</code>。</p>
<p>多个装饰器也可以写成多行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@f</span></span><br><span class="line"><span class="meta">@g</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<p>多个装饰器的效果，类似于函数的合成，按照从里到外的顺序执行。对于上例来说，就是执行<code>f(g(x))</code>。</p>
<p>前面也说过，如果<code>f</code>和<code>g</code>是表达式，那么需要先从外到里求值。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/">A Complete Guide to TypeScript Decorators</a>, by Saul Mirone</li>
<li><a href="https://techsparx.com/nodejs/typescript/decorators/introduction.html">Deep introduction to using and implementing TypeScript decorators</a>, by David Herron</li>
<li><a href="https://techsparx.com/nodejs/typescript/decorators/properties.html">Deep introduction to property decorators in TypeScript</a>, by David Herron</li>
<li><a href="https://techsparx.com/nodejs/typescript/decorators/accessors.html">Deep introduction to accessor decorators in TypeScript</a>, by David Herron</li>
<li><a href="https://dev.to/danywalls/using-property-decorators-in-typescript-with-a-real-example-44e">Using Property Decorators in Typescript with a real example</a>, by Dany Paredes</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的 ES6 类型</title>
    <url>/2023/09/05/ts-es6/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="Map-lt-K-V-gt"><a href="#Map-lt-K-V-gt" class="headerlink" title="Map&lt;K, V&gt;"></a><code>Map&lt;K, V&gt;</code></h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// Key any, value any</span></span><br><span class="line"><span class="keyword">let</span> map3 = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(); <span class="comment">// Key string, value number</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 使用 Map 类型，描述 Map 结构。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">myMap</span>: <span class="title class_">Map</span>&lt;<span class="built_in">boolean</span>,<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">false</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>Map 是一个泛型，使用时，比如给出类型变量。</p>
<p>由于存在类型推断，也可以省略类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">false</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="Set-lt-T-gt"><a href="#Set-lt-T-gt" class="headerlink" title="Set&lt;T&gt;"></a><code>Set&lt;T&gt;</code></h2><h2 id="Promise-lt-T-gt"><a href="#Promise-lt-T-gt" class="headerlink" title="Promise&lt;T&gt;"></a><code>Promise&lt;T&gt;</code></h2><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p>async 函数的的返回值是一个 Promise 对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; = <span class="comment">/* ... */</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="keyword">await</span> p;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Iterable-lt-T-gt"><a href="#Iterable-lt-T-gt" class="headerlink" title="Iterable&lt;T&gt;"></a><code>Iterable&lt;T&gt;</code></h2><p>对象只要部署了 Iterator 接口，就可以用<code>for...of</code>循环遍历。Generator 函数（生成器）返回的就是一个具有 Iterator 接口的对象。</p>
<p>TypeScript 使用泛型<code>Iterable&lt;T&gt;</code>表示具有 Iterator 接口的对象，其中<code>T</code>表示 Iterator 接口包含的值类型（每一轮遍历获得的值）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>](): <span class="title class_">Iterator</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是<code>Iterable&lt;T&gt;</code>接口的定义，表示一个具有<code>Symbol.iterator</code>属性的对象，该属性是一个函数，调用后返回的是一个 Iterator 对象。</p>
<p>Iterator 对象必须具有<code>next()</code>方法，另外还具有两个可选方法<code>return()</code>和<code>throw()</code>，类型表述如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">next</span>(value?: <span class="built_in">any</span>): <span class="title class_">IteratorResult</span>&lt;T&gt;;</span><br><span class="line">  <span class="keyword">return</span>?(value?: <span class="built_in">any</span>): <span class="title class_">IteratorResult</span>&lt;T&gt;;</span><br><span class="line">  <span class="keyword">throw</span>?(e?: <span class="built_in">any</span>): <span class="title class_">IteratorResult</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的类型定义中，可以看到<code>next()</code>、<code>return()</code>、<code>throw()</code>这三个方法的返回值是一个部署了<code>IteratorResult&lt;T&gt;</code>接口的对象。</p>
<p><code>IteratorResult&lt;T&gt;</code>接口的定义如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IteratorResult</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">done</span>: <span class="built_in">boolean</span>; <span class="comment">//表示遍历是否结束</span></span><br><span class="line">  <span class="attr">value</span>: T; <span class="comment">// 当前遍历得到的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的类型定义表示，Iterator 对象的<code>next()</code>等方法的返回值，具有<code>done</code>和<code>value</code>两个属性。</p>
<p>下面的例子是 Generator 函数返回一个具有 Iterator 接口的对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>():<span class="title class_">Iterable</span>&lt;<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">otherStringGenerator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，生成器<code>g()</code>返回的类型是<code>Iterable&lt;string&gt;</code>，其中<code>string</code>表示 Iterator 接口包含的是字符串。</p>
<p>这个例子的类型声明可以省略，因为 TypeScript 可以自己推断出来 Iterator 接口的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;&quot;</span>; <span class="comment">// infer string</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">otherStringGenerator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，扩展运算符（<code>...</code>）后面的值必须具有 Iterator 接口，下面是一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> toArray&lt;X&gt;(<span class="attr">xs</span>: <span class="title class_">Iterable</span>&lt;X&gt;):X[] &#123;</span><br><span class="line">  <span class="keyword">return</span> [...xs]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p>Generator 函数返回一个同时具有 Iterable 接口（具有<code>[Symbol.iterator]</code>属性）和 Iterator 接口（具有<code>next()</code>方法）的对象，因此 TypeScript 提供了一个泛型<code>IterableIterator&lt;T&gt;</code>，表示同时满足<code>Iterable&lt;T&gt;</code>和<code>Iterator&lt;T&gt;</code>两个接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IterableIterator</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>](): <span class="title class_">IterableIterator</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面类型定义中，<code>IterableIterator&lt;T&gt;</code>接口就是在<code>Iterator&lt;T&gt;</code>接口的基础上，加上<code>[Symbol.iterator]</code>属性。</p>
<p>下面是一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">createNumbers</span>(): <span class="title class_">IterableIterator</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = <span class="title function_">createNumbers</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">numbers.<span class="title function_">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">numbers.<span class="title function_">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">numbers.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>createNumbers()</code>返回的对象<code>numbers</code>即具有<code>next()</code>方法，也具有<code>[Symbol.iterator]</code>属性，所以满足<code>IterableIterator&lt;T&gt;</code>接口。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.geekabyte.io/2019/06/typing-iterables-and-iterators-with.html">Typing Iterables and Iterators with TypeScript</a></li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 泛型</title>
    <url>/2023/09/05/ts-generics/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有些时候，函数返回值的类型与参数类型是相关的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFirst</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>getFirst()</code>总是返回参数数组的第一个成员。参数数组是什么类型，返回值就是什么类型。</p>
<p>这个函数的类型声明只能写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的类型声明，就反映不出参数与返回值之间的类型关系。</p>
<p>为了解决这个问题，TypeScript 就引入了“泛型”（generics）。泛型的特点就是带有“类型参数”（type parameter）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getFirst&lt;T&gt;(<span class="attr">arr</span>:T[]):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>getFirst()</code>的函数名后面尖括号的部分<code>&lt;T&gt;</code>，就是类型参数，参数要放在一对尖括号（<code>&lt;&gt;</code>）里面。本例只有一个类型参数<code>T</code>，可以将其理解为类型声明需要的变量，需要在调用时传入具体的参数类型。</p>
<p>上例的函数<code>getFirst()</code>的参数类型是<code>T[]</code>，返回值类型是<code>T</code>，就清楚地表示了两者之间的关系。比如，输入的参数类型是<code>number[]</code>，那么 T 的值就是<code>number</code>，因此返回值类型也是<code>number</code>。</p>
<p>函数调用时，需要提供类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">getFirst&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>上面示例中，调用函数<code>getFirst()</code>时，需要在函数名后面使用尖括号，给出类型参数<code>T</code>的值，本例是<code>&lt;number&gt;</code>。</p>
<p>不过为了方便，函数调用时，往往省略不写类型参数的值，让 TypeScript 自己推断。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getFirst</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>上面示例中，TypeScript 会从实际参数<code>[1, 2, 3]</code>，推断出类型参数 T 的值为<code>number</code>。</p>
<p>有些复杂的使用场景，TypeScript 可能推断不出类型参数的值，这时就必须显式给出了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> comb&lt;T&gt;(<span class="attr">arr1</span>:T[], <span class="attr">arr2</span>:T[]):T[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两个参数<code>arr1</code>、<code>arr2</code>和返回值都是同一个类型。如果不给出类型参数的值，下面的调用会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">comb</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例会报错，TypeScript 认为两个参数不是同一个类型。但是，如果类型参数是一个联合类型，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">comb&lt;<span class="built_in">number</span>|<span class="built_in">string</span>&gt;([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数是一个联合类型，使得两个参数都符合类型参数，就不报错了。这种情况下，类型参数是不能省略不写的。</p>
<p>类型参数的名字，可以随便取，但是必须为合法的标识符。习惯上，类型参数的第一个字符往往采用大写字母。一般会使用<code>T</code>（type 的第一个字母）作为类型参数的名字。如果有多个类型参数，则使用 T 后面的 U、V 等字母命名，各个参数之间使用逗号（“,”）分隔。</p>
<p>下面是多个类型参数的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> map&lt;T, U&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[],</span><br><span class="line">  <span class="attr">f</span>:<span class="function">(<span class="params">arg:T</span>) =&gt;</span> U</span><br><span class="line">):U[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法实例</span></span><br><span class="line">map&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>],</span><br><span class="line">  <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">parseInt</span>(n)</span><br><span class="line">); <span class="comment">// 返回 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面示例将数组的实例方法<code>map()</code>改写成全局函数，它有两个类型参数<code>T</code>和<code>U</code>。含义是，原始数组的类型为<code>T[]</code>，对该数组的每个成员执行一个处理函数<code>f</code>，将类型<code>T</code>转成类型<code>U</code>，那么就会得到一个类型为<code>U[]</code>的数组。</p>
<p>总之，泛型可以理解成一段类型逻辑，需要类型参数来表达。有了类型参数以后，可以在输入类型与输出类型之间，建立一一对应关系。</p>
<h2 id="泛型的写法"><a href="#泛型的写法" class="headerlink" title="泛型的写法"></a>泛型的写法</h2><p>泛型主要用在四个场合：函数、接口、类和别名。</p>
<h3 id="函数的泛型写法"><a href="#函数的泛型写法" class="headerlink" title="函数的泛型写法"></a>函数的泛型写法</h3><p>上一节提到，<code>function</code>关键字定义的泛型函数，类型参数放在尖括号中，写在函数名后面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;T&gt;(<span class="attr">arg</span>:T):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么对于变量形式定义的函数，泛型有下面两种写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:&lt;T&gt;<span class="function">(<span class="params">arg:T</span>) =&gt;</span> T = id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:&#123; &lt;T&gt;(<span class="attr">arg</span>:T): T &#125; = id;</span><br></pre></td></tr></table></figure>

<h3 id="接口的泛型写法"><a href="#接口的泛型写法" class="headerlink" title="接口的泛型写法"></a>接口的泛型写法</h3><p>interface 也可以采用泛型的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">box</span>:<span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，使用泛型接口时，需要给出类型参数的值（本例是<code>string</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">compareTo</span>(<span class="attr">value</span>:T): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;<span class="title class_">Rectangle</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">compareTo</span>(<span class="attr">value</span>:<span class="title class_">Rectangle</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，先定义了一个泛型接口，然后将这个接口用于一个类。</p>
<p>泛型接口还有第二种写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">  &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>:<span class="title class_">Type</span>): <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>:<span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:<span class="title class_">Fn</span> = id;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Fn</code>的类型参数<code>Type</code>的具体类型，需要函数<code>id</code>在使用时提供。所以，最后一行的赋值语句不需要给出<code>Type</code>的具体类型。</p>
<p>此外，第二种写法还有一个差异之处。那就是它的类型参数定义在某个方法之中，其他属性和方法不能使用该类型参数。前面的第一种写法，类型参数定义在整个接口，接口内部的所有属性和方法都可以使用该类型参数。</p>
<h3 id="类的泛型写法"><a href="#类的泛型写法" class="headerlink" title="类的泛型写法"></a>类的泛型写法</h3><p>泛型类的类型参数写在类名后面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;K, V&gt; &#123;</span><br><span class="line">  <span class="attr">key</span>: K;</span><br><span class="line">  <span class="attr">value</span>: V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是继承泛型类的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>有一个类型参数<code>T</code>，使用时必须给出<code>T</code>的类型，所以类<code>B</code>继承时要写成<code>A&lt;any&gt;</code>。</p>
<p>泛型也可以用在类表达式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Container</span> = <span class="keyword">class</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> data:T</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，新建实例时，需要同时给出类型参数<code>T</code>和类参数<code>data</code>的值。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="title class_">NumType</span>&gt; &#123;</span><br><span class="line">  value!: <span class="title class_">NumType</span>;</span><br><span class="line">  add!: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> C&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">foo.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">foo.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，先新建类<code>C</code>的实例<code>foo</code>，然后再定义实例的<code>value</code>属性和<code>add()</code>方法。类的定义中，属性和方法后面的感叹号是非空断言，告诉 TypeScript 它们都是非空的，后面会赋值。</p>
<p>JavaScript 的类本质上是一个构造函数，因此也可以把泛型类写成构造函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyClass</span>&lt;T&gt; = <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法实例</span></span><br><span class="line"><span class="keyword">function</span> createInstance&lt;T&gt;(</span><br><span class="line">  <span class="title class_">AnyClass</span>: <span class="title class_">MyClass</span>&lt;T&gt;,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">):T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnyClass</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>createInstance()</code>的第一个参数<code>AnyClass</code>是构造函数（也可以是一个类），它的类型是<code>MyClass&lt;T&gt;</code>，这里的<code>T</code>是<code>createInstance()</code>的类型参数，在该函数调用时再指定具体类型。</p>
<p>注意，泛型类描述的是类的实例，不包括静态属性和静态方法，因为这两者定义在类的本身。因此，它们不能引用类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">data</span>: T;  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> value:T</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性<code>data</code>引用了类型参数<code>T</code>，这是不可以的，因为类型参数只能用于实例属性和实例方法，所以报错了。</p>
<h3 id="类型别名的泛型写法"><a href="#类型别名的泛型写法" class="headerlink" title="类型别名的泛型写法"></a>类型别名的泛型写法</h3><p>type 命令定义的类型别名，也可以使用泛型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Nullable</span>&lt;T&gt; = T | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Nullable&lt;T&gt;</code>是一个泛型，只要传入一个类型，就可以得到这个类型与<code>undefined</code>和<code>null</code>的一个联合类型。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="title class_">Container</span>&lt;<span class="built_in">number</span>&gt; = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Container</span>&lt;<span class="built_in">string</span>&gt; = &#123; <span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>下面是定义树形结构的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型别名<code>Tree</code>内部递归引用了<code>Tree</code>自身。</p>
<h2 id="类型参数的默认值"><a href="#类型参数的默认值" class="headerlink" title="类型参数的默认值"></a>类型参数的默认值</h2><p>类型参数可以设置默认值。使用时，如果没有给出类型参数的值，就会使用默认值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getFirst&lt;T = <span class="built_in">string</span>&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[]</span><br><span class="line">):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>T = string</code>表示类型参数的默认值是<code>string</code>。调用<code>getFirst()</code>时，如果不给出<code>T</code>的值，TypeScript 就认为<code>T</code>等于<code>string</code>。</p>
<p>但是，因为 TypeScript 会从实际参数推断出<code>T</code>的值，从而覆盖掉默认值，所以下面的代码不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getFirst</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，实际参数是<code>[1, 2, 3]</code>，TypeScript 推断 T 等于<code>number</code>，从而覆盖掉默认值<code>string</code>。</p>
<p>类型参数的默认值，往往用在类中。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T = <span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="attr">list</span>:T[] = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">t:T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>Generic</code>有一个类型参数<code>T</code>，默认值为<code>string</code>。这意味着，属性<code>list</code>默认是一个字符串数组，方法<code>add()</code>的默认参数是一个字符串。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Generic</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">add</span>(<span class="number">4</span>) <span class="comment">// 报错</span></span><br><span class="line">g.<span class="title function_">add</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，新建<code>Generic</code>的实例<code>g</code>时，没有给出类型参数<code>T</code>的值，所以<code>T</code>就等于<code>string</code>。因此，向<code>add()</code>方法传入一个数值会报错，传入字符串就不会。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">add</span>(<span class="number">4</span>) <span class="comment">// 正确</span></span><br><span class="line">g.<span class="title function_">add</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，新建实例<code>g</code>时，给出了类型参数<code>T</code>的值是<code>number</code>，因此<code>add()</code>方法传入数值不会报错，传入字符串会报错。</p>
<p>一旦类型参数有默认值，就表示它是可选参数。如果有多个类型参数，可选参数必须在必选参数之后。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;T = <span class="built_in">boolean</span>, U&gt; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">&lt;T, U = <span class="built_in">boolean</span>&gt; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，依次有两个类型参数<code>T</code>和<code>U</code>。如果<code>T</code>是可选参数，<code>U</code>不是，就会报错。</p>
<h2 id="数组的泛型表示"><a href="#数组的泛型表示" class="headerlink" title="数组的泛型表示"></a>数组的泛型表示</h2><p>《数组》一章提到过，数组类型有一种表示方法是<code>Array&lt;T&gt;</code>。这就是泛型的写法，<code>Array</code>是 TypeScript 原生的一个类型接口，<code>T</code>是它的类型参数。声明数组时，需要提供<code>T</code>的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面的示例中，<code>Array&lt;number&gt;</code>就是一个泛型，类型参数的值是<code>number</code>，表示该数组的全部成员都是数值。</p>
<p>同样的，如果数组成员都是字符串，那么类型就写成<code>Array&lt;string&gt;</code>。事实上，在 TypeScript 内部，数组类型的另一种写法<code>number[]</code>、<code>string[]</code>，只是<code>Array&lt;number&gt;</code>、<code>Array&lt;string&gt;</code>的简写形式。</p>
<p>在 TypeScript 内部，<code>Array</code>是一个泛型接口，类型定义基本是下面的样子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pop</span>(): <span class="title class_">Type</span>|<span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">push</span>(...<span class="attr">items</span>:<span class="title class_">Type</span>[]): <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>push()</code>方法的参数<code>item</code>的类型是<code>Type[]</code>，跟<code>Array()</code>的参数类型<code>Type</code>保持一致，表示只能添加同类型的成员。调用<code>push()</code>的时候，TypeScript 就会检查两者是否一致。</p>
<p>其他的 TypeScript 内部数据结构，比如<code>Map</code>、<code>Set</code>和<code>Promise</code>，其实也是泛型接口，完整的写法是<code>Map&lt;K, V&gt;</code>、<code>Set&lt;T&gt;</code>和<code>Promise&lt;T&gt;</code>。</p>
<p>TypeScript 默认还提供一个<code>ReadonlyArray&lt;T&gt;</code>接口，表示只读数组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params"></span></span><br><span class="line"><span class="params">  values:ReadonlyArray&lt;<span class="built_in">string</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  values.<span class="title function_">push</span>(<span class="string">&#x27;hello!&#x27;</span>);  <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>values</code>的类型是<code>ReadonlyArray&lt;string&gt;</code>，表示不能修改这个数组，所以函数体内部新增数组成员就会报错。因此，如果不希望函数内部改动参数数组，就可以将该参数数组声明为<code>ReadonlyArray&lt;T&gt;</code>类型。</p>
<h2 id="类型参数的约束条件"><a href="#类型参数的约束条件" class="headerlink" title="类型参数的约束条件"></a>类型参数的约束条件</h2><p>很多类型参数并不是无限制的，对于传入的类型存在约束条件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;<span class="title class_">Type</span>&gt;(<span class="attr">a</span>:<span class="title class_">Type</span>, <span class="attr">b</span>:<span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数 Type 有一个隐藏的约束条件：它必须存在<code>length</code>属性。如果不满足这个条件，就会报错。</p>
<p>TypeScript 提供了一种语法，允许在类型参数上面写明约束条件，如果不满足条件，编译时就会报错。这样也可以有良好的语义，对类型参数进行说明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(</span><br><span class="line">  <span class="attr">a</span>: T,</span><br><span class="line">  <span class="attr">b</span>: T</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>T extends &#123; length: number &#125;</code>就是约束条件，表示类型参数 T 必须满足<code>&#123; length: number &#125;</code>，否则就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">comp</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">comp</span>(<span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>) <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">comp</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，只要传入的参数类型不满足约束条件，就会报错。</p>
<p>类型参数的约束条件采用下面的形式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">TypeParameter</span> <span class="keyword">extends</span> <span class="title class_">ConstraintType</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上面语法中，<code>TypeParameter</code>表示类型参数，<code>extends</code>是关键字，这是必须的，<code>ConstraintType</code>表示类型参数要满足的条件，即类型参数应该是<code>ConstraintType</code>的子类型。</p>
<p>类型参数可以同时设置约束条件和默认值，前提是默认值必须满足约束条件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span>&lt;A <span class="keyword">extends</span> <span class="built_in">string</span>, B <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&#x27;world&#x27;</span>&gt;</span><br><span class="line">  =  [A, B];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Fn</span>&lt;<span class="string">&#x27;hello&#x27;</span>&gt; <span class="comment">// [&quot;hello&quot;, &quot;world&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数<code>A</code>和<code>B</code>都有约束条件，并且<code>B</code>还有默认值。所以，调用<code>Fn</code>的时候，可以只给出<code>A</code>的值，不给出<code>B</code>的值。</p>
<p>另外，上例也可以看出，泛型本质上是一个类型函数，通过输入参数，获得结果，两者是一一对应关系。</p>
<p>如果有多个类型参数，一个类型参数的约束条件，可以引用其他参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;T, U <span class="keyword">extends</span> T&gt;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">&lt;T <span class="keyword">extends</span> U, U&gt;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>U</code>的约束条件引用<code>T</code>，或者<code>T</code>的约束条件引用<code>U</code>，都是正确的。</p>
<p>但是，约束条件不能引用类型参数自身。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> T&gt;               <span class="comment">// 报错</span></span><br><span class="line">&lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> T&gt;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>T</code>的约束条件不能是<code>T</code>自身。同理，多个类型参数也不能互相约束（即<code>T</code>的约束条件是<code>U</code>、<code>U</code>的约束条件是<code>T</code>），因为互相约束就意味着约束条件就是类型参数自身。</p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>泛型有一些使用注意点。</p>
<p><strong>（1）尽量少用泛型。</strong></p>
<p>泛型虽然灵活，但是会加大代码的复杂性，使其变得难读难写。一般来说，只要使用了泛型，类型声明通常都不太易读，容易写得很复杂。因此，可以不用泛型就不要用。</p>
<p><strong>（2）类型参数越少越好。</strong></p>
<p>多一个类型参数，多一道替换步骤，加大复杂性。因此，类型参数越少越好。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> filter&lt;</span><br><span class="line">  T,</span><br><span class="line">  <span class="title class_">Fn</span> <span class="keyword">extends</span> (<span class="attr">arg</span>:T) =&gt; <span class="built_in">boolean</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[],</span><br><span class="line">  <span class="attr">func</span>:<span class="title class_">Fn</span></span><br><span class="line">): T[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例有两个类型参数，但是第二个类型参数<code>Fn</code>是不必要的，完全可以直接写在函数参数的类型声明里面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> filter&lt;T&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[],</span><br><span class="line">  <span class="attr">func</span>:<span class="function">(<span class="params">arg:T</span>) =&gt;</span> <span class="built_in">boolean</span></span><br><span class="line">): T[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数简化成了一个，效果与前一个示例是一样的。</p>
<p><strong>（3）类型参数需要出现两次。</strong></p>
<p>如果类型参数在定义后只出现一次，那么很可能是不必要的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> greet&lt;<span class="title class_">Str</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(</span><br><span class="line">  <span class="attr">s</span>:<span class="title class_">Str</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数<code>Str</code>只在函数声明中出现一次（除了它的定义部分），这往往表明这个类型参数是不必要。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例把前面的类型参数省略了，效果与前一个示例是一样的。</p>
<p>也就是说，只有当类型参数用到两次或两次以上，才是泛型的适用场合。</p>
<p><strong>（4）泛型可以嵌套。</strong></p>
<p>类型参数可以是另一个泛型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span>|<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span>|<span class="title class_">Type</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">OrNull</span>&lt;<span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行的泛型<code>OrNull</code>的类型参数，就是另一个泛型<code>OneOrMany</code>。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的函数类型</title>
    <url>/2023/09/05/ts-function/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>函数的类型声明，需要在声明函数时，给出参数的类型和返回值的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span></span><br><span class="line"><span class="params">  txt:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>hello()</code>在声明时，需要给出参数<code>txt</code>的类型（string），以及返回值的类型（<code>void</code>），后者写在参数列表的圆括号后面。<code>void</code>类型表示没有返回值，详见后文。</p>
<p>如果不指定参数类型（比如上例不写<code>txt</code>的类型），TypeScript 就会推断参数类型，如果缺乏足够信息，就会推断该参数的类型为<code>any</code>。</p>
<p>返回值的类型通常可以不写，因为 TypeScript 自己会推断出来。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于没有<code>return</code>语句，TypeScript 会推断出函数<code>hello()</code>没有返回值。</p>
<p>不过，有时候出于文档目的，或者为了防止不小心改掉返回值，还是会写返回值的类型。</p>
<p>如果变量被赋值为一个函数，变量的类型有两种写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span> (<span class="params">txt:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>:</span><br><span class="line">  <span class="function">(<span class="params">txt:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">= <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>hello</code>被赋值为一个函数，它的类型有两种写法。写法一是通过等号右边的函数类型，推断出变量<code>hello</code>的类型；写法二则是使用箭头函数的形式，为变量<code>hello</code>指定类型，参数的类型写在箭头左侧，返回值的类型写在箭头右侧。</p>
<p>写法二有两个地方需要注意。</p>
<p>首先，函数的参数要放在圆括号里面，不放会报错。</p>
<p>其次，类型里面的参数名（本例是<code>txt</code>）是必须的。有的语言的函数类型可以不写参数名（比如 C 语言），但是 TypeScript 不行。如果写成<code>(string) =&gt; void</code>，TypeScript 会理解成函数有一个名叫 string 的参数，并且这个<code>string</code>参数的类型是<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyFunc</span> = <span class="function">(<span class="params"><span class="built_in">string</span>, <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// (string: any, number: any) =&gt; number</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数类型没写参数名，导致 TypeScript 认为参数类型都是<code>any</code>。</p>
<p>函数类型里面的参数名与实际参数名，可以不一致。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">f</span>:<span class="function">(<span class="params">x:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"> </span><br><span class="line">f = <span class="keyword">function</span> (<span class="params">y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数类型里面的参数名为<code>x</code>，实际的函数定义里面，参数名为<code>y</code>，两者并不相同。</p>
<p>如果函数的类型定义很冗长，或者多个函数使用同一种类型，写法二用起来就很麻烦。因此，往往用<code>type</code>命令为函数类型定义一个别名，便于指定给其他变量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyFunc</span> = <span class="function">(<span class="params">txt:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>:<span class="title class_">MyFunc</span> = <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>type</code>命令为函数类型定义了一个别名<code>MyFunc</code>，后面使用就很方便，变量可以指定为这个类型。</p>
<p>函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即 TypeScript 允许省略参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>:</span><br><span class="line">  <span class="function">(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">myFunc = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">myFunc = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a:<span class="built_in">number</span>, b:<span class="built_in">number</span>, c:<span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> a + b + c; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>myFunc</code>的类型只能接受两个参数，如果被赋值为只有一个参数的函数，并不报错。但是，被赋值为有三个参数的函数，就会报错。</p>
<p>这是因为 JavaScript 函数在声明时往往有多余的参数，实际使用时可以只传入一部分参数。比如，数组的<code>forEach()</code>方法的参数是一个函数，该函数默认有三个参数<code>(item, index, array) =&gt; void</code>，实际上往往只使用第一个参数<code>(item) =&gt; void</code>。因此，TypeScript 允许函数传入的参数不足。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">x</span> = (<span class="params">a:<span class="built_in">number</span></span>) =&gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">y</span> = (<span class="params">b:<span class="built_in">number</span>, s:<span class="built_in">string</span></span>) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 正确</span></span><br><span class="line">x = y; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>x</code>只有一个参数，函数<code>y</code>有两个参数，<code>x</code>可以赋值给<code>y</code>，反过来就不行。</p>
<p>如果一个变量要套用另一个函数类型，有一个小技巧，就是使用<code>typeof</code>运算符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>:<span class="keyword">typeof</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>myAdd()</code>的类型与函数<code>add()</code>是一样的，那么就可以定义成<code>typeof add</code>。因为函数名<code>add</code>本身不是类型，而是一个值，所以要用<code>typeof</code>运算符返回它的类型。</p>
<p>这是一个很有用的技巧，任何需要类型的地方，都可以使用<code>typeof</code>运算符从一个值获取类型。</p>
<p>函数类型还可以采用对象的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">add</span>:&#123;</span><br><span class="line">  (<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>add</code>的类型就写成了一个对象。</p>
<p>函数类型的对象写法如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  (参数列表): 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这种写法的函数参数与返回值之间，间隔符是冒号<code>:</code>，而不是正常写法的箭头<code>=&gt;</code>，因为这里采用的是对象类型的写法，对象的属性名与属性值之间使用的是冒号。</p>
<p>这种写法平时很少用，但是非常合适用在一个场合：函数本身存在属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="property">version</span> = <span class="string">&#x27;1.0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>本身还有一个属性<code>version</code>。这时，<code>f</code>完全就是一个对象，类型就要使用对象的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: &#123;</span><br><span class="line">  (<span class="attr">x</span>:<span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span></span><br><span class="line">&#125; = f;</span><br></pre></td></tr></table></figure>

<p>函数类型也可以使用 Interface 来声明，这种写法就是对象写法的翻版，详见《Interface》一章。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myfn &#123;</span><br><span class="line">  (<span class="attr">a</span>:<span class="built_in">number</span>, <span class="attr">b</span>:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">add</span>:myfn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>

<p>上面示例中，interface 命令定义了接口<code>myfn</code>，这个接口的类型就是一个用对象表示的函数。</p>
<h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>TypeScript 提供 Function 类型表示函数，任何函数都属于这个类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">f:<span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>f</code>的类型就是<code>Function</code>，代表这是一个函数。</p>
<p>Function 类型的值都可以直接执行。</p>
<p>Function 类型的函数可以接受任意数量的参数，每个参数的类型都是<code>any</code>，返回值的类型也是<code>any</code>，代表没有任何约束，所以不建议使用这个类型，给出函数详细的类型声明会更好。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数是普通函数的一种简化写法，它的类型写法与普通函数类似。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> repeat = (</span><br><span class="line">  <span class="attr">str</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">times</span>:<span class="built_in">number</span></span><br><span class="line">):<span class="function"><span class="params">string</span> =&gt;</span> str.<span class="title function_">repeat</span>(times);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>repeat</code>被赋值为一个箭头函数，类型声明写在箭头函数的定义里面。其中，参数的类型写在参数名后面，返回值类型写在参数列表的圆括号后面。</p>
<p>注意，类型写在箭头函数的定义里面，与使用箭头函数表示函数类型，写法有所不同。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span></span><br><span class="line"><span class="params">  fn:(a:<span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="title function_">fn</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>greet()</code>的参数<code>fn</code>是一个函数，类型就用箭头函数表示。这时，<code>fn</code>的返回值类型要写在箭头右侧，而不是写在参数列表的圆括号后面。</p>
<p>下面再看一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;jan&#x27;</span>].<span class="title function_">map</span>(</span><br><span class="line">  (name):<span class="function"><span class="params">Person</span> =&gt;</span> (&#123;name&#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person</code>是一个类型别名，代表一个对象，该对象有属性<code>name</code>。变量<code>people</code>是数组的<code>map()</code>方法的返回值。</p>
<p><code>map()</code>方法的参数是一个箭头函数<code>(name):Person =&gt; (&#123;name&#125;)</code>，该箭头函数的参数<code>name</code>的类型省略了，因为可以从<code>map()</code>的类型定义推断出来，箭头函数的返回值类型为<code>Person</code>。相应地，变量<code>people</code>的类型是<code>Person[]</code>。</p>
<p>至于箭头后面的<code>(&#123;name&#125;)</code>，表示返回一个对象，该对象有一个属性<code>name</code>，它的属性值为变量<code>name</code>的值。这里的圆括号是必须的，否则<code>(name):Person =&gt; &#123;name&#125;</code>的大括号表示函数体，即函数体内有一行语句<code>name</code>，同时由于没有<code>return</code>语句，这个函数不会返回任何值。</p>
<p>注意，下面两种写法都是不对的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">(<span class="attr">name</span>:<span class="title class_">Person</span>) =&gt; (&#123;name&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="attr">name</span>:<span class="function"><span class="params">Person</span> =&gt;</span> (&#123;name&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的两种写法在本例中都是错的。第一种写法表示，箭头函数的参数<code>name</code>的类型是<code>Person</code>，同时没写函数返回值的类型，让 TypeScript 自己去推断。第二种写法中，函数参数缺少圆括号。</p>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>如果函数的某个参数可以省略，则在参数名后面加问号表示。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>x</code>后面有问号，表示该参数可以省略。</p>
<p>参数名带有问号，表示该参数的类型实际上是<code>原始类型|undefined</code>，它有可能为<code>undefined</code>。比如，上例的<code>x</code>虽然类型声明为<code>number</code>，但是实际上是<code>number|undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>x</code>是可选的，等同于说<code>x</code>可以赋值为<code>undefined</code>。</p>
<p>但是，反过来就不成立，类型显式设为<code>undefined</code>的参数，就不能省略。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">number</span>|<span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>x</code>的类型是<code>number|undefined</code>，表示要么传入一个数值，要么传入<code>undefined</code>，如果省略这个参数，就会报错。</p>
<p>函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>:</span><br><span class="line">  <span class="function">(<span class="params">a?:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，可选参数在必选参数前面，就报错了。</p>
<p>如果前部参数有可能为空，这时只能显式注明该参数类型可能为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>:</span><br><span class="line">  <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    a:<span class="built_in">number</span>|<span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    b:<span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>a</code>有可能为空，就只能显式注明类型包括<code>undefined</code>，传参时也要显式传入<code>undefined</code>。</p>
<p>函数体内部用到可选参数时，需要判断该参数是否为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>:</span><br><span class="line">  <span class="function">(<span class="params">a:<span class="built_in">number</span>, b?:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>; </span><br><span class="line"></span><br><span class="line">myFunc = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于函数的第二个参数为可选参数，所以函数体内部需要判断一下，该参数是否为空。</p>
<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>TypeScript 函数的参数默认值写法，与 JavaScript 一致。</p>
<p>设置了默认值的参数，就是可选的。如果不传入该参数，它就会等于默认值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span> = <span class="number">0</span></span></span><br><span class="line"><span class="params"></span>):[<span class="built_in">number</span>, <span class="built_in">number</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createPoint</span>() <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>x</code>和<code>y</code>的默认值都是<code>0</code>，调用<code>createPoint()</code>时，这两个参数都是可以省略的。这里其实可以省略<code>x</code>和<code>y</code>的类型声明，因为可以从默认值推断出来。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x = <span class="number">0</span>, y = <span class="number">0</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选参数与默认值不能同时使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>是可选参数，还设置了默认值，结果就报错了。</p>
<p>设有默认值的参数，如果传入<code>undefined</code>，也会触发默认值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">456</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f2</span>(<span class="literal">undefined</span>) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p>具有默认值的参数如果不位于参数列表的末尾，调用时不能省略，如果要触发默认值，必须显式传入<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">add</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><p>函数参数如果存在变量解构，类型写法如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span></span><br><span class="line"><span class="params">  [x, y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span></span><br><span class="line"><span class="params">  &#123; a, b, c &#125;: &#123;</span></span><br><span class="line"><span class="params">     a: <span class="built_in">number</span>;</span></span><br><span class="line"><span class="params">     b: <span class="built_in">number</span>;</span></span><br><span class="line"><span class="params">     c: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数解构可以结合类型别名（type 命令）一起使用，代码会看起来简洁一些。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">ABC</span> = &#123; <span class="attr">a</span>:<span class="built_in">number</span>; <span class="attr">b</span>:<span class="built_in">number</span>; <span class="attr">c</span>:<span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;:ABC</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><p>rest 参数表示函数剩余的所有参数，它可以是数组（剩余参数类型相同），也可能是元组（剩余参数类型不同）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rest 参数为数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">joinNumbers</span>(<span class="params">...nums:<span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 参数为元组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args:[<span class="built_in">boolean</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，元组需要声明每一个剩余参数的类型。如果元组里面的参数是可选的，则要使用可选参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span></span><br><span class="line"><span class="params">  ...args: [<span class="built_in">boolean</span>, <span class="built_in">string</span>?]</span></span><br><span class="line"><span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个 rest 参数的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">n:<span class="built_in">number</span>, ...m:<span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>m</code>就是 rest 类型，它的类型是一个数组。</p>
<p>rest 参数甚至可以嵌套。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args:[<span class="built_in">boolean</span>, ...<span class="built_in">string</span>[]]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rest 参数可以与变量解构结合使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params"></span></span><br><span class="line"><span class="params">  ...[str, times]: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span></span><br><span class="line"><span class="params"></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">repeat</span>(times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params"></span></span><br><span class="line"><span class="params">  str: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  times: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">repeat</span>(times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="readonly-只读参数"><a href="#readonly-只读参数" class="headerlink" title="readonly 只读参数"></a>readonly 只读参数</h2><p>如果函数内部不能修改某个参数，可以在函数定义时，在参数类型前面加上<code>readonly</code>关键字，表示这是只读参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraySum</span>(<span class="params"></span></span><br><span class="line"><span class="params">  arr:<span class="keyword">readonly</span> <span class="built_in">number</span>[]</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>arr</code>的类型是<code>readonly number[]</code>，表示为只读参数。如果函数体内部修改这个数组，就会报错。</p>
<h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h2><p>void 类型表示函数没有返回值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f</code>没有返回值，类型就要写成<code>void</code>。</p>
<p>如果返回其他值，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>的返回值类型是<code>void</code>，但是实际返回了一个数值，编译时就报错了。</p>
<p>void 类型允许返回<code>undefined</code>或<code>null</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果打开了<code>strictNullChecks</code>编译选项，那么 void 类型只允许返回<code>undefined</code>。如果返回<code>null</code>，就会报错。这是因为 JavaScript 规定，如果函数没有返回值，就等同于返回<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开编译选项 strictNullChecks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，如果变量、对象方法、函数参数是一个返回值为 void 类型的函数，那么并不代表不能赋值为有返回值的函数。恰恰相反，该变量、对象方法和函数参数可以接受返回任意值的函数，这时并不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f</span>:voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>f</code>的类型是<code>voidFunc</code>，是一个没有返回值的函数。但是实际上，<code>f</code>的值可以是一个有返回值的函数（返回<code>123</code>），编译时不会报错。</p>
<p>这是因为，这时 TypeScript 认为，这里的 void 类型只是表示该函数的返回值没有利用价值，或者说不应该使用该函数的返回值。只要不用到这里的返回值，就不会报错。</p>
<p>这样设计是有现实意义的。举例来说，数组方法<code>Array.prototype.forEach(fn)</code>的参数<code>fn</code>是一个函数，而且这个函数应该没有返回值，即返回值类型是<code>void</code>。</p>
<p>但是，实际应用中，很多时候传入的函数是有返回值，但是它的返回值不重要，或者不产生作用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> src = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> ret = [];</span><br><span class="line"></span><br><span class="line">src.<span class="title function_">forEach</span>(<span class="function"><span class="params">el</span> =&gt;</span> ret.<span class="title function_">push</span>(el));</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>push()</code>有返回值，表示新插入的元素在数组里面的位置。但是，对于<code>forEach()</code>方法来说，这个返回值是没有作用的，根本用不到，所以 TypeScript 不会报错。</p>
<p>如果后面使用了这个函数的返回值，就违反了约定，则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">f</span>:voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() * <span class="number">2</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错了，因为根据类型声明，<code>f()</code>没有返回值，但是却用到了它的返回值，因此报错了。</p>
<p>注意，这种情况仅限于变量、对象方法和函数参数，函数字面量如果声明了返回值是 void 类型，还是不能有返回值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> f3 = <span class="keyword">function</span> (<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数字面量声明了返回<code>void</code>类型，这时只要有返回值（除了<code>undefined</code>和<code>null</code>）就会报错。</p>
<p>函数的运行结果如果是抛出错误，也允许将返回值写成<code>void</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throwErr</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;something wrong&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>throwErr()</code>会抛出错误，返回值类型写成<code>void</code>是允许的。</p>
<p>除了函数，其他变量声明为<code>void</code>类型没有多大意义，因为这时只能赋值为<code>undefined</code>或者<code>null</code>（假定没有打开<code>strictNullChecks</code>) 。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有打开 strictNullChecks 的情况下</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:<span class="built_in">void</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><p><code>never</code>类型表示肯定不会出现的值。它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束。</p>
<p>它主要有以下两种情况。</p>
<p>（1）抛出错误的函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params">msg:<span class="built_in">string</span></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fail()</code>会抛出错误，不会正常退出，所以返回值类型是<code>never</code>。</p>
<p>注意，只有抛出错误，才是 never 类型。如果显式用<code>return</code>语句返回一个 Error 对象，返回值就不是 never 类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>):<span class="title class_">Error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fail()</code>返回一个 Error 对象，所以返回值类型是 Error。</p>
<p>另外，由于抛出错误的情况属于<code>never</code>类型或<code>void</code>类型，所以无法从返回值类型中获知，抛出的是哪一种错误。</p>
<p>（2）无限执行的函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sing = <span class="keyword">function</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>sing()</code>会永远执行，不会返回，所以返回值类型是<code>never</code>。</p>
<p>注意，<code>never</code>类型不同于<code>void</code>类型。前者表示函数没有执行结束，不可能有返回值；后者表示函数正常执行结束，但是不返回值，或者说返回<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sing</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sing</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>sing()</code>虽然没有<code>return</code>语句，但实际上是省略了<code>return undefined</code>这行语句，真实的返回值是<code>undefined</code>。所以，它的返回值类型要写成<code>void</code>，而不是<code>never</code>，写成<code>never</code>会报错。</p>
<p>如果一个函数抛出了异常或者陷入了死循环，那么该函数无法正常返回一个值，因此该函数的返回值类型就是<code>never</code>。如果程序中调用了一个返回值类型为<code>never</code>的函数，那么就意味着程序会在该函数的调用位置终止，永远不会继续执行后续的代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">neverReturns</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">string</span>|<span class="literal">undefined</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title function_">neverReturns</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x; <span class="comment">// 推断为 string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>的参数<code>x</code>的类型为<code>string|undefined</code>。但是，<code>x</code>类型为<code>undefined</code>时，调用了<code>neverReturns()</code>。这个函数不会返回，因此 TypeScript 可以推断出，判断语句后面的那个<code>x</code>，类型一定是<code>string</code>。</p>
<p>一个函数如果某些条件下有正常返回值，另一些条件下抛出错误，这时它的返回值类型可以省略<code>never</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sometimesThrow</span>(<span class="params"></span>):<span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">sometimesThrow</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>sometimesThrow()</code>的返回值其实是<code>number|never</code>，但是一般都写成<code>number</code>，包括最后一行的变量<code>result</code>的类型，也是被推断为<code>number</code>。</p>
<p>原因是前面章节提到过，<code>never</code>是 TypeScript 的唯一一个底层类型，所有其他类型都包括了<code>never</code>。从集合论的角度看，<code>number|never</code>等同于<code>number</code>。这也提示我们，函数的返回值无论是什么类型，都可能包含了抛出错误的情况。</p>
<h2 id="局部类型"><a href="#局部类型" class="headerlink" title="局部类型"></a>局部类型</h2><p>函数内部允许声明其他类型，该类型只在函数内部有效，称为局部类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">type</span> message = <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">newTxt</span>:message = <span class="string">&#x27;hello &#x27;</span> + txt;</span><br><span class="line">  <span class="keyword">return</span> newTxt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">newTxt</span>:message = <span class="title function_">hello</span>(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>message</code>是在函数<code>hello()</code>内部定义的，只能在函数内部使用。在函数外部使用，就会报错。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>一个函数的返回值还是一个函数，那么前一个函数就称为高阶函数（higher-order function）。</p>
<p>下面就是一个例子，箭头函数返回的还是一个箭头函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="attr">someValue</span>: <span class="built_in">number</span>) =&gt; <span class="function">(<span class="params">multiplier: <span class="built_in">number</span></span>) =&gt;</span> someValue * multiplier;</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载（function overload）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">reverse</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &#x27;cba&#x27;</span></span><br><span class="line"><span class="title function_">reverse</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>reverse()</code>可以将参数颠倒输出。参数可以是字符串，也可以是数组。</p>
<p>这意味着，该函数内部有处理字符串和数组的两套逻辑，根据参数类型的不同，分别执行对应的逻辑。这就叫“函数重载”。</p>
<p>TypeScript 对于“函数重载”的类型声明方法是，逐一定义每一种情况的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">str:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">any</span>[];</span><br></pre></td></tr></table></figure>

<p>上面示例中，分别对函数<code>reverse()</code>的两种参数情况，给予了类型声明。但是，到这里还没有结束，后面还必须对函数<code>reverse()</code>给予完整的类型声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">str:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">any</span>[];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params"></span></span><br><span class="line"><span class="params">  stringOrArray:<span class="built_in">string</span>|<span class="built_in">any</span>[]</span></span><br><span class="line"><span class="params"></span>):<span class="built_in">string</span>|<span class="built_in">any</span>[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> stringOrArray === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> stringOrArray.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> stringOrArray.<span class="title function_">slice</span>().<span class="title function_">reverse</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，前两行类型声明列举了重载的各种情况。第三行是函数本身的类型声明，它必须与前面已有的重载声明兼容。</p>
<p>有一些编程语言允许不同的函数参数，对应不同的函数实现。但是，JavaScript 函数只能有一个实现，必须在这个实现当中，处理不同的参数。因此，函数体内部就需要判断参数的类型及个数，并根据判断结果执行不同的操作。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">any</span>[],</span></span><br><span class="line"><span class="params">  y:<span class="built_in">any</span>[]</span></span><br><span class="line"><span class="params"></span>):<span class="built_in">any</span>[];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span>|<span class="built_in">any</span>[],</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span>|<span class="built_in">any</span>[]</span></span><br><span class="line"><span class="params"></span>):<span class="built_in">number</span>|<span class="built_in">any</span>[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(x) &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(y)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...x, ...y];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong parameters&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>add()</code>内部使用<code>if</code>代码块，分别处理参数的两种情况。</p>
<p>注意，重载的各个类型描述与函数的具体实现之间，不能有其他代码，否则报错。</p>
<p>另外，虽然函数的具体实现里面，有完整的类型声明。但是，函数实际调用的类型，以前面的类型声明为准。比如，上例的函数实现，参数类型和返回值类型都是<code>number|any[]</code>，但不意味着参数类型为<code>number</code>时返回值类型为<code>any[]</code>。</p>
<p>函数重载的每个类型声明之间，以及类型声明与函数实现的类型之间，不能有冲突。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">boolean</span></span>):<span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span></span>):<span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">number</span>|<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数重载的类型声明与函数实现是冲突的，导致报错。</p>
<p>重载声明的排序很重要，因为 TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型最宽的声明应该放在最后面，防止覆盖其他类型声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">any</span></span>):<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">string</span></span>): <span class="number">0</span>|<span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">any</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="number">0</span>|<span class="number">1</span> = <span class="title function_">f</span>(<span class="string">&#x27;hi&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面声明中，第一行类型声明<code>x:any</code>范围最宽，导致函数<code>f()</code>的调用都会匹配这行声明，无法匹配第二行类型声明，所以最后一行调用就报错了，因为等号两侧类型不匹配，左侧类型是<code>0|1</code>，右侧类型是<code>number</code>。这个函数重载的正确顺序是，第二行类型声明放到第一行的位置。</p>
<p>对象的方法也可以使用重载。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringBuilder</span> &#123;</span><br><span class="line">  #data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">num</span>:<span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">bool</span>:<span class="built_in">boolean</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">str</span>:<span class="built_in">string</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">value</span>:<span class="built_in">any</span>): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#data += <span class="title class_">String</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，方法<code>add()</code>也使用了函数重载。</p>
<p>函数重载也可以用来精确描述函数参数与返回值之间的对应关系。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag:<span class="string">&#x27;a&#x27;</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">HTMLAnchorElement</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag:<span class="string">&#x27;canvas&#x27;</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag:<span class="string">&#x27;table&#x27;</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">HTMLTableElement</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">HTMLElement</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数重载精确描述了参数<code>tag</code>的三个值，所对应的不同的函数返回值。</p>
<p>这个示例的函数重载，也可以用对象表示。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CreateElement</span> = &#123;</span><br><span class="line">  (<span class="attr">tag</span>:<span class="string">&#x27;a&#x27;</span>): <span class="title class_">HTMLAnchorElement</span>;</span><br><span class="line">  (<span class="attr">tag</span>:<span class="string">&#x27;canvas&#x27;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">  (<span class="attr">tag</span>:<span class="string">&#x27;table&#x27;</span>): <span class="title class_">HTMLTableElement</span>;</span><br><span class="line">  (<span class="attr">tag</span>:<span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该优先使用联合类型替代函数重载。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">s:<span class="built_in">string</span></span>):<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x:<span class="built_in">any</span></span>):<span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x:<span class="built_in">any</span>[]|<span class="built_in">string</span></span>):<span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，写法二使用联合类型，要比写法一的函数重载简单很多。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>JavaScript 语言使用构造函数，生成对象的实例。</p>
<p>构造函数的最大特点，就是必须使用<code>new</code>命令调用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Date()</code>就是一个构造函数，使用<code>new</code>命令调用，返回 Date 对象的实例。</p>
<p>构造函数的类型写法，就是在参数列表前面加上<code>new</code>命令。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">numLegs</span>:<span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalConstructor</span> = <span class="keyword">new</span> () =&gt; <span class="title class_">Animal</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">c:AnimalConstructor</span>):<span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">create</span>(<span class="title class_">Animal</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>AnimalConstructor</code>就是一个构造函数，而函数<code>create()</code>需要传入一个构造函数。在 JavaScript 中，类（class）本质上是构造函数，所以<code>Animal</code>这个类可以传入<code>create()</code>。</p>
<p>构造函数还有另一种类型写法，就是采用对象形式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F = &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>:<span class="built_in">string</span>): <span class="built_in">object</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型 F 就是一个构造函数。类型写成一个可执行对象的形式，并且在参数列表前面要加上<code>new</code>命令。</p>
<p>某些函数既是构造函数，又可以当作普通函数使用，比如<code>Date()</code>。这时，类型声明可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F = &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>:<span class="built_in">string</span>): <span class="built_in">object</span>;</span><br><span class="line">  (n?:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，F 既可以当作普通函数执行，也可以当作构造函数使用。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的 interface 接口</title>
    <url>/2023/09/05/ts-interface/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，定义了一个接口<code>Person</code>，它指定一个对象模板，拥有三个属性<code>firstName</code>、<code>lastName</code>和<code>age</code>。任何实现这个接口的对象，都必须部署这三个属性，并且必须符合规定的类型。</p>
<p>实现该接口很简单，只要指定它作为对象的类型即可。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Smith&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>p</code>的类型就是接口<code>Person</code>，所以必须符合<code>Person</code>指定的结构。</p>
<p>方括号运算符可以取出 interface 某个属性的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Foo</span>[<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Foo[&#39;a&#39;]</code>返回属性<code>a</code>的类型，所以类型<code>A</code>就是<code>string</code>。</p>
<p>interface 可以表示对象的各种语法，它的成员有5种形式。</p>
<ul>
<li>对象属性</li>
<li>对象的属性索引</li>
<li>对象方法</li>
<li>函数</li>
<li>构造函数</li>
</ul>
<p>（1）对象属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>和<code>y</code>都是对象的属性，分别使用冒号指定每个属性的类型。</p>
<p>属性之间使用分号或逗号分隔，最后一个属性结尾的分号或逗号可以省略。</p>
<p>如果属性是可选的，就在属性名后面加一个问号。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  x?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果属性是只读的，需要加上<code>readonly</code>修饰符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象的属性索引</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[prop: string]</code>就是属性的字符串索引，表示属性名只要是字符串，都符合类型要求。</p>
<p>属性索引共有<code>string</code>、<code>number</code>和<code>symbol</code>三种类型。</p>
<p>一个接口中，最多只能定义一个字符串索引。字符串索引会约束该类型中所有名字为字符串的属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">boolean</span>;      <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性索引指定所有名称为字符串的属性，它们的属性值必须是数值（<code>number</code>）。属性<code>a</code>的值为布尔值就报错了。</p>
<p>属性的数值索引，其实是指定数组的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:A = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[prop: number]</code>表示属性名的类型是数值，所以可以用数组对变量<code>obj</code>赋值。</p>
<p>同样的，一个接口中最多只能定义一个数值索引。数值索引会约束所有名称为数值的属性。</p>
<p>如果一个 interface 同时定义了字符串索引和数值索引，那么数值索引必须服从于字符串索引。因为在 JavaScript 中，数值属性名最终是自动转换成字符串属性名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数值索引的属性值类型与字符串索引不一致，就会报错。数值索引必须兼容字符串索引的类型声明。</p>
<p>（3）对象的方法</p>
<p>对象的方法共有三种写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">f</span>: <span class="function">(<span class="params">x: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">  <span class="attr">f</span>: &#123; (<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性名可以采用表达式，所以下面的写法也是可以的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [f](<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型方法可以重载。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 里面的函数重载，不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params"></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params">x: <span class="built_in">boolean</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x?:<span class="built_in">boolean</span>|<span class="built_in">string</span>, y?:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">number</span>|<span class="built_in">boolean</span>|<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">undefined</span> &amp;&amp; y === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;boolean&#x27;</span> &amp;&amp; y === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong parameters&#x27;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = &#123;</span><br><span class="line">  <span class="attr">f</span>: <span class="title class_">MyFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>A</code>的方法<code>f()</code>有函数重载，需要额外定义一个函数<code>MyFunc()</code>实现这个重载，然后部署接口<code>A</code>的对象<code>a</code>的属性<code>f</code>等于函数<code>MyFunc()</code>就可以了。</p>
<p>（4）函数</p>
<p>interface 也可以用来声明独立的函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">  (<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>:<span class="title class_">Add</span> = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>Add</code>声明了一个函数类型。</p>
<p>（5）构造函数</p>
<p>interface 内部可以使用<code>new</code>关键字，表示构造函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ErrorConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (message?: <span class="built_in">string</span>): <span class="title class_">Error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>ErrorConstructor</code>内部有<code>new</code>命令，表示它是一个构造函数。</p>
<p>TypeScript 里面，构造函数特指具有<code>constructor</code>属性的类，详见《Class》一章。</p>
<h2 id="interface-的继承"><a href="#interface-的继承" class="headerlink" title="interface 的继承"></a>interface 的继承</h2><p>interface 可以继承其他类型，主要有下面几种情况。</p>
<h3 id="interface-继承-interface"><a href="#interface-继承-interface" class="headerlink" title="interface 继承 interface"></a>interface 继承 interface</h3><p>interface 可以使用<code>extends</code>关键字，继承其他 interface。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Circle</code>继承了<code>Shape</code>，所以<code>Circle</code>其实有两个属性<code>name</code>和<code>radius</code>。这时，<code>Circle</code>是子接口，<code>Shape</code>是父接口。</p>
<p><code>extends</code>关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性。</p>
<p>interface 允许多重继承。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Style</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Style</span>, <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Circle</code>同时继承了<code>Style</code>和<code>Shape</code>，所以拥有三个属性<code>color</code>、<code>name</code>和<code>radius</code>。</p>
<p>多重接口继承，实际上相当于多个父接口的合并。</p>
<p>如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。注意，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Bar</code>继承了<code>Foo</code>，但是两者的同名属性<code>id</code>的类型不兼容，导致报错。</p>
<p>多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_">Foo</span>, <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Baz</code>同时继承了<code>Foo</code>和<code>Bar</code>，但是后两者的同名属性<code>id</code>有类型冲突，导致报错。</p>
<h3 id="interface-继承-type"><a href="#interface-继承-type" class="headerlink" title="interface 继承 type"></a>interface 继承 type</h3><p>interface 可以继承<code>type</code>命令定义的对象类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CountryWithPop</span> <span class="keyword">extends</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  <span class="attr">population</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>CountryWithPop</code>继承了<code>type</code>命令定义的<code>Country</code>对象，并且新增了一个<code>population</code>属性。</p>
<p>注意，如果<code>type</code>命令定义的类型不是对象，interface 就无法继承。</p>
<h3 id="interface-继承-class"><a href="#interface-继承-class" class="headerlink" title="interface 继承 class"></a>interface 继承 class</h3><p>interface 还可以继承 class，即继承该类的所有成员。关于 class 的详细解释，参见下一章。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">y</span>():<span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>B</code>继承了<code>A</code>，因此<code>B</code>就具有属性<code>x</code>、<code>y()</code>和<code>z</code>。</p>
<p>实现<code>B</code>接口的对象就需要实现这些属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:B = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>b</code>就实现了接口<code>B</code>，而接口<code>B</code>又继承了类<code>A</code>。</p>
<p>某些类拥有私有成员和保护成员，interface 可以继承这样的类，但是意义不大。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">y</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:B = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> B &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>有私有成员和保护成员，<code>B</code>继承了<code>A</code>，但无法用于对象，因为对象不能实现这些成员。这导致<code>B</code>只能用于其他 class，而这时其他 class 与<code>A</code>之间不构成父类和子类的关系，使得<code>x</code>与<code>y</code>无法部署。</p>
<h2 id="接口合并"><a href="#接口合并" class="headerlink" title="接口合并"></a>接口合并</h2><p>多个同名接口会合并成一个接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两个<code>Box</code>接口会合并成一个接口，同时有<code>height</code>、<code>width</code>和<code>length</code>三个属性。</p>
<p>这样的设计主要是为了兼容 JavaScript 的行为。JavaScript 开发者常常对全局对象或者外部库，添加自己的属性和方法。那么，只要使用 interface 给出这些自定义属性和方法的类型，就能自动跟原始的 interface 合并，使得扩展外部类型非常方便。</p>
<p>举例来说，Web 网页开发经常会对<code>windows</code>对象和<code>document</code>对象添加自定义属性，但是 TypeScript 会报错，因为原始定义没有这些属性。解决方法就是把自定义属性写成 interface，合并进原始定义。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>Document</code>增加了一个自定义属性<code>foo</code>，从而就可以在<code>document</code>对象上使用自定义属性。</p>
<p>同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>A</code>的属性<code>a</code>有两个类型声明，彼此是冲突的，导致报错。</p>
<p>同名接口合并时，如果同名方法有不同的类型声明，那么会发生函数重载。而且，后面的定义比前面的定义具有更高的优先级。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Animal</span>): <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Sheep</span>): <span class="title class_">Sheep</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Dog</span>): <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Cat</span>): <span class="title class_">Cat</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Dog</span>): <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Cat</span>): <span class="title class_">Cat</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Sheep</span>): <span class="title class_">Sheep</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Animal</span>): <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>clone()</code>方法有不同的类型声明，会发生函数重载。这时，越靠后的定义，优先级越高，排在函数重载的越前面。比如，<code>clone(animal: Animal)</code>是最先出现的类型声明，就排在函数重载的最后，属于<code>clone()</code>函数最后匹配的类型。</p>
<p>这个规则有一个例外。同名方法之中，如果有一个参数是字面量类型，字面量类型有更高的优先级。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="string">&#x27;foo&#x27;</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="string">&#x27;foo&#x27;</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>f()</code>方法有一个类型声明的参数<code>x</code>是字面量类型，这个类型声明的优先级最高，会排在函数重载的最前面。</p>
<p>一个实际的例子是 Document 对象的<code>createElement()</code>方法，它会根据参数的不同，而生成不同的 HTML 节点对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">any</span>): <span class="title class_">Element</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;div&quot;</span>): <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;span&quot;</span>): <span class="title class_">HTMLSpanElement</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;canvas&quot;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;canvas&quot;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;div&quot;</span>): <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;span&quot;</span>): <span class="title class_">HTMLSpanElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">any</span>): <span class="title class_">Element</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>createElement()</code>方法的函数重载，参数为字面量的类型声明会排到最前面，返回具体的 HTML 节点对象。类型越不具体的参数，排在越后面，返回通用的 HTML 节点对象。</p>
<p>如果两个 interface 组成的联合类型存在同名属性，那么该属性的类型也是联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">area</span>: <span class="built_in">bigint</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="attr">area</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">s</span>: <span class="title class_">Circle</span> | <span class="title class_">Rectangle</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="property">area</span>;   <span class="comment">// bigint | number</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>Circle</code>和<code>Rectangle</code>组成一个联合类型<code>Circle | Rectangle</code>。因此，这个联合类型的同名属性<code>area</code>，也是一个联合类型。本例中的<code>declare</code>命令表示变量<code>s</code>的具体定义，由其他脚本文件给出，详见《declare 命令》一章。</p>
<h2 id="interface-与-type-的异同"><a href="#interface-与-type-的异同" class="headerlink" title="interface 与 type 的异同"></a>interface 与 type 的异同</h2><p><code>interface</code>命令与<code>type</code>命令作用类似，都可以表示对象类型。</p>
<p>很多对象类型既可以用 interface 表示，也可以用 type 表示。而且，两者往往可以换用，几乎所有的 interface 命令都可以改写为 type 命令。</p>
<p>它们的相似之处，首先表现在都能为对象类型起名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coutry</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是<code>type</code>命令和<code>interface</code>命令，分别定义同一个类型。</p>
<p><code>class</code>命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用<code>type</code>或<code>interface</code>。</p>
<p>interface 与 type 的区别有下面几点。</p>
<p>（1）<code>type</code>能够表示非对象类型，而<code>interface</code>只能表示对象类型（包括数组、函数等）。</p>
<p>（2）<code>interface</code>可以继承其他类型，<code>type</code>不支持继承。</p>
<p>继承的主要作用是添加属性，<code>type</code>定义的对象类型如果想要添加属性，只能使用<code>&amp;</code>运算符，重新定义一个类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bear</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Bear</code>在<code>Animal</code>的基础上添加了一个属性<code>honey</code>。</p>
<p>上例的<code>&amp;</code>运算符，表示同时具备两个类型的特征，因此可以起到两个对象类型合并的作用。</p>
<p>作为比较，<code>interface</code>添加属性，采用的是继承的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bear</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承时，type 和 interface 是可以换用的。interface 可以继承 type。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type 也可以继承 interface。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Foo</span> &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>（3）同名<code>interface</code>会自动合并，同名<code>type</code>则会报错。也就是说，TypeScript 不允许使用<code>type</code>多次定义同一个类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">foo</span>:<span class="built_in">number</span> &#125;; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">bar</span>:<span class="built_in">number</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>type</code>两次定义了类型<code>A</code>，导致两行都会报错。</p>
<p>作为比较，<code>interface</code>则会自动合并。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">foo</span>:<span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">bar</span>:<span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>interface</code>把类型<code>A</code>的两个定义合并在一起。</p>
<p>这表明，interface 是开放的，可以添加属性，type 是封闭的，不能添加属性，只能定义新的 type。</p>
<p>（4）<code>interface</code>不能包含属性映射（mapping），<code>type</code>可以，详见《映射》一章。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PointCopy1</span> = &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> keyof <span class="title class_">Point</span>]: <span class="title class_">Point</span>[<span class="title class_">Key</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PointCopy2</span> &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> keyof <span class="title class_">Point</span>]: <span class="title class_">Point</span>[<span class="title class_">Key</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（5）<code>this</code>关键字只能用于<code>interface</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">num</span>:<span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">num</span>:<span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，type 命令声明的方法<code>add()</code>，返回<code>this</code>就报错了。interface 命令没有这个问题。</p>
<p>下面是返回<code>this</code>的实际对象的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">num:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> += num;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）type 可以扩展原始数据类型，interface 不行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyStr</span> = <span class="built_in">string</span> &amp; &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;new&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyStr</span> <span class="keyword">extends</span> <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;new&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，type 可以扩展原始数据类型 string，interface 就不行。</p>
<p>（7）<code>interface</code>无法表达某些复杂类型（比如交叉类型和联合类型），但是<code>type</code>可以。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AorB</span> = A | B;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AorBwithName</span> = <span class="title class_">AorB</span> &amp; &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>AorB</code>是一个联合类型，<code>AorBwithName</code>则是为<code>AorB</code>添加一个属性。这两种运算，<code>interface</code>都没法表达。</p>
<p>综上所述，如果有复杂的类型运算，那么没有其他选择只能使用<code>type</code>；一般情况下，<code>interface</code>灵活性比较高，便于扩充类型或自动合并，建议优先使用。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 语言简介</title>
    <url>/2023/09/05/ts-intro/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TypeScript（简称 TS）是微软公司开发的一种基于 JavaScript （简称 JS）语言的编程语言。</p>
<p>它的目的并不是创造一种全新语言，而是增强 JavaScript 的功能，使其更适合多人合作的企业级项目。</p>
<p>TypeScript 可以看成是 JavaScript 的超集（superset），即它继承了后者的全部语法，所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。</p>
<p>TypeScript 对 JavaScript 添加的最主要部分，就是一个独立的类型系统。</p>
<h2 id="类型的概念"><a href="#类型的概念" class="headerlink" title="类型的概念"></a>类型的概念</h2><p>类型（type）指的是一组具有相同特征的值。如果两个值具有某种共同的特征，就可以说，它们属于同一种类型。</p>
<p>举例来说，<code>123</code>和<code>456</code>这两个值，共同特征是都能进行数值运算，所以都属于“数值”（number）这个类型。</p>
<p>一旦确定某个值的类型，就意味着，这个值具有该类型的所有特征，可以进行该类型的所有运算。凡是适用该类型的地方，都可以使用这个值；凡是不适用该类型的地方，使用这个值都会报错。</p>
<p>可以这样理解，<strong>类型是人为添加的一种编程约束和用法提示。</strong> 主要目的是在软件开发过程中，为编译器和开发工具提供更多的验证和帮助，帮助提高代码质量，减少错误。</p>
<p>下面是一段简单的 TypeScript 代码，演示一下类型系统的作用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addOne</span>(<span class="params">n:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>addOne()</code>有一个参数<code>n</code>，类型为数值（number），表示这个位置只能使用数值，传入其他类型的值就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addOne</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>addOne()</code>传入了一个字符串<code>hello</code>，TypeScript 发现类型不对，就报错了，指出这个位置只能传入数值，不能传入字符串。</p>
<p>JavaScript 语言就没有这个功能，不会检查类型对不对。开发阶段很可能发现不了这个问题，代码也许就会原样发布，导致用户在使用时遇到错误。</p>
<p>作为比较，TypeScript 是在开发阶段报错，这样有利于提早发现错误，避免使用时报错。另一方面，函数定义里面加入类型，具有提示作用，可以告诉开发者这个函数怎么用。</p>
<h2 id="动态类型与静态类型"><a href="#动态类型与静态类型" class="headerlink" title="动态类型与静态类型"></a>动态类型与静态类型</h2><p>前面说了，TypeScript 的主要功能是为 JavaScript 添加类型系统。大家可能知道，JavaScript  语言本身就有一套自己的类型系统，比如数值<code>123</code>和字符串<code>Hello</code>。</p>
<p>但是，JavaScript 的类型系统非常弱，而且没有使用限制，运算符可以接受各种类型的值。在语法上，JavaScript 属于动态类型语言。</p>
<p>请看下面的 JavaScript 代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">delete</span> y.<span class="property">foo</span>;</span><br><span class="line">y.<span class="property">bar</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面的例一，变量<code>x</code>声明时，值的类型是数值，但是后面可以改成字符串。所以，无法提前知道变量的类型是什么，也就是说，变量的类型是动态的。</p>
<p>上面的例二，变量<code>y</code>是一个对象，有一个属性<code>foo</code>，但是这个属性是可以删掉的，并且还可以新增其他属性。所以，对象有什么属性，这个属性还在不在，也是动态的，没法提前知道。</p>
<p>正是因为存在这些动态变化，所以 JavaScript 的类型系统是动态的，不具有很强的约束性。这对于提前发现代码错误，非常不利。</p>
<p>TypeScript 引入了一个更强大、更严格的类型系统，属于静态类型语言。</p>
<p>上面的代码在 TypeScript 里面都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">delete</span> y.<span class="property">foo</span>; <span class="comment">// 报错</span></span><br><span class="line">y.<span class="property">bar</span> = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，例一的报错是因为变量赋值时，TypeScript 已经推断确定了类型，后面就不允许再赋值为其他类型的值，即变量的类型是静态的。例二的报错是因为对象的属性也是静态的，不允许随意增删。</p>
<p>TypeScript 的作用，就是为 JavaScript 引入这种静态类型特征。</p>
<h2 id="静态类型的优点"><a href="#静态类型的优点" class="headerlink" title="静态类型的优点"></a>静态类型的优点</h2><p>静态类型有很多好处，这也是 TypeScript 想要达到的目的。</p>
<p>（1）有利于代码的静态分析。</p>
<p>有了静态类型，不必运行代码，就可以确定变量的类型，从而推断代码有没有错误。这就叫做代码的静态分析。</p>
<p>这对于大型项目非常重要，单单在开发阶段运行静态检查，就可以发现很多问题，避免交付有问题的代码，大大降低了线上风险。</p>
<p>（2）有利于发现错误。</p>
<p>由于每个值、每个变量、每个运算符都有严格的类型约束，TypeScript 就能轻松发现拼写错误、语义错误和方法调用错误，节省程序员的时间。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">messege</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，不小心把<code>message</code>拼错了，写成<code>messege</code>。TypeScript 就会报错，指出没有定义过这个属性。JavaScript 遇到这种情况是不报错的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> result = a + b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例是合法的 JavaScript 代码，但是没有意义，不应该将数值<code>a</code>与布尔值<code>b</code>相加。TypeScript 就会直接报错，提示运算符<code>+</code>不能用于数值和布尔值的相加。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hello</span>().<span class="title function_">find</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>hello()</code>返回的是一个字符串，TypeScript 发现字符串没有<code>find()</code>方法，所以报错了。如果是 JavaScript，只有到运行阶段才会报错。</p>
<p>（3）更好的 IDE 支持，做到语法提示和自动补全。</p>
<p>IDE（集成开发环境，比如  VSCode）一般都会利用类型信息，提供语法提示功能（编辑器自动提示函数用法、参数等）和自动补全功能（只键入一部分的变量名或函数名，编辑器补全后面的部分）。</p>
<p>（4）提供了代码文档。</p>
<p>类型信息可以部分替代代码文档，解释应该如何使用这些代码，熟练的开发者往往只看类型，就能大致推断代码的作用。借助类型信息，很多工具能够直接生成文档。</p>
<p>（5）有助于代码重构。</p>
<p>修改他人的 JavaScript 代码，往往非常痛苦，项目越大越痛苦，因为不确定修改后是否会影响到其他部分的代码。</p>
<p>类型信息大大减轻了重构的成本。一般来说，只要函数或对象的参数和返回值保持类型不变，就能基本确定，重构后的代码也能正常运行。如果还有配套的单元测试，就完全可以放心重构。越是大型的、多人合作的项目，类型信息能够提供的帮助越大。</p>
<p>综上所述，TypeScript 有助于提高代码质量，保证代码安全，更适合用在大型的企业级项目。这就是为什么大量 JavaScript 项目转成 TypeScript 的原因。</p>
<h2 id="静态类型的缺点"><a href="#静态类型的缺点" class="headerlink" title="静态类型的缺点"></a>静态类型的缺点</h2><p>静态类型也存在一些缺点。</p>
<p>（1）丧失了动态类型的代码灵活性。</p>
<p>动态类型有非常高的灵活性，给予程序员很大的自由，静态类型将这些灵活性都剥夺了。</p>
<p>（2）增加了编程工作量。</p>
<p>有了类型之后，程序员不仅需要编写功能，还需要编写类型声明，确保类型正确。这增加了不少工作量，有时会显著拖长项目的开发时间。</p>
<p>（3）更高的学习成本。</p>
<p>类型系统通常比较复杂，要学习的东西更多，要求开发者付出更高的学习成本。</p>
<p>（4）引入了独立的编译步骤。</p>
<p>原生的 JavaScript 代码，可以直接在 JavaScript 引擎运行。添加类型系统以后，就多出了一个单独的编译步骤，检查类型是否正确，并将 TypeScript 代码转成 JavaScript 代码，这样才能运行。</p>
<p>（5）兼容性问题。</p>
<p>TypeScript 依赖 JavaScript 生态，需要用到很多外部模块。但是，过去大部分 JavaScript 项目都没有做 TypeScript 适配，虽然可以自己动手做适配，不过使用时难免还是会有一些兼容性问题。</p>
<p>总的来说，这些缺点使得 TypeScript 不一定适合那些小型的、短期的个人项目。</p>
<h2 id="TypeScript-的历史"><a href="#TypeScript-的历史" class="headerlink" title="TypeScript 的历史"></a>TypeScript 的历史</h2><p>下面简要介绍 TypeScript 的发展历史。</p>
<p>2012年，微软公司宣布推出 TypeScript 语言，设计者是著名的编程语言设计大师 Anders Hejlsberg，他也是 C# 和 .NET 的设计师。</p>
<p>微软推出这门语言的主要目的，是让 JavaScript 程序员可以参与 Windows 8 应用程序的开发。</p>
<p>当时，Windows 8 即将发布，它的应用程序开发除了使用 C# 和 Visual Basic，还可以使用 HTML + JavaScript。微软希望，TypeScript 既能让 JavaScript 程序员快速上手，也能让 .Net 程序员感到熟悉。</p>
<p>这就是说，TypeScript 的最初动机是减少 .NET 程序员的转移和学习成本。所以，它的很多语法概念跟 .NET 很类似。</p>
<p>另外，TypeScript 是一个开源项目，接受社区的参与，核心的编译器采用 Apache 2.0 许可证。微软希望通过这种做法，迅速提高这门语言在社区的接受度。</p>
<p>2013年，微软的 Visual Studio 2013 开始内置支持 TypeScript 语言。</p>
<p>2014年，TypeScript 1.0 版本发布。同年，代码仓库搬到了 GitHub。</p>
<p>2016年，TypeScript 2.0 版本发布，引入了很多重大的语法功能。</p>
<p>2018年，TypeScript 3.0 版本发布。</p>
<p>2020年，TypeScript 4.0 版本发布。</p>
<p>2023年，TypeScript 5.0 版本发布。</p>
<h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><p>学习 TypeScript，必须先了解 JavaScript 的语法。因为真正的实际功能都是 JavaScript 引擎完成的，TypeScript 只是添加了一个类型系统。</p>
<p>本书假定读者已经了解 JavaScript 语言，就不再介绍它的语法了，只介绍 TypeScript 引入的新语法，主要是类型系统。</p>
<p>如果你对 JavaScript 还不熟悉，建议先阅读<a href="https://wangdoc.com/javascript">《JavaScript 教程》</a>和<a href="https://wangdoc.com/es6">《ES6 教程》</a>，再来阅读本书。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 模块</title>
    <url>/2023/09/05/ts-module/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>任何包含 import 或 export 语句的文件，就是一个模块（module）。相应地，如果文件不包含 export 语句，就是一个全局的脚本文件。</p>
<p>模块本身就是一个作用域，不属于全局作用域。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的。暴露给外部的接口，必须用 export 命令声明；如果其他文件要使用模块的接口，必须用 import 命令来输入。</p>
<p>如果一个文件不包含 export 语句，但是希望把它当作一个模块（即内部变量对外不可见），可以在脚本头部添加一行语句。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这行语句不产生任何实际作用，但会让当前文件被当作模块处理，所有它的代码都变成了内部代码。</p>
<p>ES 模块的详细介绍，请参考 ES6 教程，这里就不重复了。本章主要介绍 TypeScript 的模块处理。</p>
<p>TypeScript 模块除了支持所有 ES 模块的语法，特别之处在于允许输出和输入类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Bool</span> = <span class="literal">true</span> | <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，当前脚本输出一个类型别名<code>Bool</code>。这行语句把类型定义和接口输出写在一行，也可以写成两行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Bool</span> = <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Bool</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>假定上面的模块文件为<code>a.ts</code>，另一个文件<code>b.ts</code>就可以使用 import 语句，输入这个类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Bool</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="title class_">Bool</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，import 语句加载的是一个类型。注意，加载文件写成<code>./a</code>，没有写脚本文件的后缀名。TypeScript 允许加载模块时，省略模块文件的后缀名，它会自动定位，将<code>./a</code>定位到<code>./a.ts</code>。</p>
<p>编译时，可以两个脚本同时编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc a.ts b.ts</span><br></pre></td></tr></table></figure>

<p>上面命令会将<code>a.ts</code>和<code>b.ts</code>分别编译成<code>a.js</code>和<code>b.js</code>。</p>
<p>也可以只编译<code>b.ts</code>，因为它是入口脚本，tsc 会自动编译它依赖的所有脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc b.ts</span><br></pre></td></tr></table></figure>

<p>上面命令发现<code>b.ts</code>依赖<code>a.ts</code>，就会自动寻找<code>a.ts</code>，也将其同时编译，因此编译产物还是<code>a.js</code>和<code>b.js</code>两个文件。</p>
<h2 id="import-type-语句"><a href="#import-type-语句" class="headerlink" title="import type 语句"></a>import type 语句</h2><p>import 在一条语句中，可以同时输入类型和正常接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A, a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，文件<code>a.ts</code>的 export 语句输出了一个类型<code>A</code>和一个正常接口<code>a</code>，另一个文件<code>b.ts</code>则在同一条语句中输入了类型和正常接口。</p>
<p>这样很不利于区分类型和正常接口，容易造成混淆。为了解决这个问题，TypeScript 引入了两个解决方法。</p>
<p>第一个方法是在 import 语句输入的类型前面加上<code>type</code>关键字。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">type</span> A, a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，import 语句输入的类型<code>A</code>前面有<code>type</code>关键字，表示这是一个类型。</p>
<p>第二个方法是使用 import type 语句，这个语句只能输入类型，不能输入正常接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，import type 输入类型<code>A</code>是正确的，但是输入正常接口<code>a</code>就会报错。</p>
<p>import type 语句也可以输入默认类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> <span class="title class_">DefaultType</span> <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>import type 在一个名称空间下，输入所有类型的写法如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> * <span class="keyword">as</span> <span class="title class_">TypeNS</span> <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>同样的，export 语句也有两种方法，表示输出的是类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> B = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">type</span> A, <span class="keyword">type</span> B&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> &#123;A, B&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，方法一是使用<code>type</code>关键字作为前缀，表示输出的是类型；方法二是使用 export type 语句，表示整行输出的都是类型。</p>
<p>下面是 export type 将一个类作为类型输出的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> &#123; <span class="title class_">Point</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于使用了 export type 语句，输出的并不是 Point 这个类，而是 Point 代表的实例类型。输入时，只能作为类型输入。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Point</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Point</code>只能作为类型输入，不能当作正常接口使用。</p>
<h2 id="importsNotUsedAsValues-编译设置"><a href="#importsNotUsedAsValues-编译设置" class="headerlink" title="importsNotUsedAsValues 编译设置"></a>importsNotUsedAsValues 编译设置</h2><p>TypeScript 特有的输入类型（type）的 import 语句，编译成 JavaScript 时怎么处理呢？</p>
<p>TypeScript 提供了<code>importsNotUsedAsValues</code>编译设置项，有三个可能的值。</p>
<p>（1）<code>remove</code>：这是默认值，自动删除输入类型的 import 语句。</p>
<p>（2）<code>preserve</code>：保留输入类型的 import 语句。</p>
<p>（3）<code>error</code>：保留输入类型的 import 语句（与<code>preserve</code>相同），但是必须写成<code>import type</code>的形式，否则报错。</p>
<p>请看示例，下面是一个输入类型的 import 语句。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>TypeA</code>是一个类型。</p>
<p><code>remove</code>的编译结果会将该语句删掉。</p>
<p><code>preserve</code>的编译结果会保留该语句，但会删掉其中涉及类型的部分。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面就是<code>preserve</code>的编译结果，可以看到编译后的<code>import</code>语句不从<code>a.js</code>输入任何接口（包括类型），但是会引发<code>a.js</code>的执行，因此会保留<code>a.js</code>里面的副作用。</p>
<p><code>error</code>的编译结果与<code>preserve</code>相同，但在编译过程中会报错，因为它要求输入类型的<code>import</code>语句必须写成<code>import type</code> 的形式。原始语句改成下面的形式，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="CommonJS-模块"><a href="#CommonJS-模块" class="headerlink" title="CommonJS 模块"></a>CommonJS 模块</h2><p>CommonJS 是 Node.js 的专用模块格式，与 ES 模块格式不兼容。</p>
<h3 id="import-x3D-语句"><a href="#import-x3D-语句" class="headerlink" title="import &#x3D; 语句"></a>import &#x3D; 语句</h3><p>TypeScript 使用<code>import =</code>语句输入 CommonJS 模块。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> code = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;hello.ts&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，使用<code>import =</code>语句和<code>require()</code>命令输入了一个 CommonJS 模块。模块本身的用法跟 Node.js 是一样的。</p>
<p>除了使用<code>import =</code>语句，TypeScript 还允许使用<code>import * as [接口名] from &quot;模块文件&quot;</code>输入 CommonJS 模块。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="export-x3D-语句"><a href="#export-x3D-语句" class="headerlink" title="export &#x3D; 语句"></a>export &#x3D; 语句</h3><p>TypeScript 使用<code>export =</code>语句，输出 CommonJS 模块的对象，等同于 CommonJS 的<code>module.exports</code>对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = obj;</span><br></pre></td></tr></table></figure>

<p><code>export =</code>语句输出的对象，只能使用<code>import =</code>语句加载。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obj = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h2 id="模块定位"><a href="#模块定位" class="headerlink" title="模块定位"></a>模块定位</h2><p>模块定位（module resolution）指的是一种算法，用来确定 import 语句和 export 语句里面的模块文件位置。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相对模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非相对模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，TypeScript 怎么确定<code>./a</code>或<code>jquery</code>到底是指哪一个模块，具体位置在哪里，用到的算法就叫做“模块定位”。</p>
<p>编译参数<code>moduleResolution</code>，用来指定具体使用哪一种定位算法。常用的算法有两种：<code>Classic</code>和<code>Node</code>。</p>
<p>如果没有指定<code>moduleResolution</code>，它的默认值与编译参数<code>module</code>有关。<code>module</code>设为<code>commonjs</code>时（项目脚本采用 CommonJS 模块格式），<code>moduleResolution</code>的默认值为<code>Node</code>，即采用 Node.js 的模块定位算法。其他情况下（<code>module</code>设为 es2015、 esnext、amd, system, umd 等等），就采用<code>Classic</code>定位算法。</p>
<h3 id="相对模块，非相对模块"><a href="#相对模块，非相对模块" class="headerlink" title="相对模块，非相对模块"></a>相对模块，非相对模块</h3><p>加载模块时，目标模块分为相对模块（relative import）和非相对模块两种（non-relative import）。</p>
<p>相对模块指的是路径以<code>/</code>、<code>./</code>、<code>../</code>开头的模块。下面 import 语句加载的模块，都是相对模块。</p>
<ul>
<li><code>import Entry from &quot;./components/Entry&quot;;</code></li>
<li><code>import &#123; DefaultHeaders &#125; from &quot;../constants/http&quot;;</code></li>
<li><code>import &quot;/mod&quot;;</code></li>
</ul>
<p>相对模块的定位，是根据当前脚本的位置进行计算的，一般用于保存在当前项目目录结构中的模块脚本。</p>
<p>非相对模块指的是不带有路径信息的模块。下面 import 语句加载的模块，都是非相对模块。</p>
<ul>
<li><code>import * as $ from &quot;jquery&quot;;</code></li>
<li><code>import &#123; Component &#125; from &quot;@angular/core&quot;;</code></li>
</ul>
<p>非相对模块的定位，是由<code>baseUrl</code>属性或模块映射而确定的，通常用于加载外部模块。</p>
<h3 id="Classic-方法"><a href="#Classic-方法" class="headerlink" title="Classic 方法"></a>Classic 方法</h3><p>Classic 方法以当前脚本的路径作为“基准路径”，计算相对模块的位置。比如，脚本<code>a.ts</code>里面有一行代码<code>import &#123; b &#125; from &quot;./b&quot;</code>，那么 TypeScript 就会在<code>a.ts</code>所在的目录，查找<code>b.ts</code>和<code>b.d.ts</code>。</p>
<p>至于非相对模块，也是以当前脚本的路径作为起点，一层层查找上级目录。比如，脚本<code>a.ts</code>里面有一行代码<code>import &#123; b &#125; from &quot;b&quot;</code>，那么就会依次在每一级上层目录里面，查找<code>b.ts</code>和<code>b.d.ts</code>。</p>
<h3 id="Node-方法"><a href="#Node-方法" class="headerlink" title="Node 方法"></a>Node 方法</h3><p>Node 方法就是模拟 Node.js 的模块加载方法，也就是<code>require()</code>的实现方法。</p>
<p>相对模块依然是以当前脚本的路径作为“基准路径”。比如，脚本文件<code>a.ts</code>里面有一行代码<code>let x = require(&quot;./b&quot;);</code>，TypeScript 按照以下顺序查找。</p>
<ol>
<li>当前目录是否包含<code>b.ts</code>、<code>b.tsx</code>、<code>b.d.ts</code>。如果不存在就执行下一步。</li>
<li>当前目录是否存在子目录<code>b</code>，该子目录里面的<code>package.json</code>文件是否有<code>types</code>字段指定了模块入口文件。如果不存在就执行下一步。</li>
<li>当前目录的子目录<code>b</code>是否包含<code>index.ts</code>、<code>index.tsx</code>、<code>index.d.ts</code>。如果不存在就报错。</li>
</ol>
<p>非相对模块则是以当前脚本的路径作为起点，逐级向上层目录查找是否存在子目录<code>node_modules</code>。比如，脚本文件<code>a.js</code>有一行<code>let x = require(&quot;b&quot;);</code>，TypeScript 按照以下顺序进行查找。</p>
<ol>
<li>当前目录的子目录<code>node_modules</code>是否包含<code>b.ts</code>、<code>b.tsx</code>、<code>b.d.ts</code>。</li>
<li>当前目录的子目录<code>node_modules</code>，是否存在文件<code>package.json</code>，该文件的<code>types</code>字段是否指定了入口文件，如果是的就加载该文件。</li>
<li>当前目录的子目录<code>node_modules</code>里面，是否包含子目录<code>@types</code>，在该目录中查找文件<code>b.d.ts</code>。</li>
<li>当前目录的子目录<code>node_modules</code>里面，是否包含子目录<code>b</code>，在该目录中查找<code>index.ts</code>、<code>index.tsx</code>、<code>index.d.ts</code>。</li>
<li>进入上一层目录，重复上面4步，直到找到为止。</li>
</ol>
<h3 id="路径映射"><a href="#路径映射" class="headerlink" title="路径映射"></a>路径映射</h3><p>TypeScript 允许开发者在<code>tsconfig.json</code>文件里面，手动指定脚本模块的路径。</p>
<p>（1）baseUrl</p>
<p><code>baseUrl</code>字段可以手动指定脚本模块的基准目录。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>baseUrl</code>是一个点，表示基准目录就是<code>tsconfig.json</code>所在的目录。</p>
<p>（2）paths</p>
<p><code>paths</code>字段指定非相对路径的模块与实际脚本的映射。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;jquery&quot;</span>: [<span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，加载模块<code>jquery</code>时，实际加载的脚本是<code>node_modules/jquery/dist/jquery</code>，它的位置要根据<code>baseUrl</code>字段计算得到。</p>
<p>注意，上例的<code>jquery</code>属性的值是一个数组，可以指定多个路径。如果第一个脚本路径不存在，那么就加载第二个路径，以此类推。</p>
<p>（3）rootDirs</p>
<p><code>rootDirs</code>字段指定模块定位时必须查找的其他目录。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;rootDirs&quot;</span>: [<span class="string">&quot;src/zh&quot;</span>, <span class="string">&quot;src/de&quot;</span>, <span class="string">&quot;src/#&#123;locale&#125;&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>rootDirs</code>指定了模块定位时，需要查找的不同的国际化目录。</p>
<h3 id="tsc-的-traceResolution参数"><a href="#tsc-的-traceResolution参数" class="headerlink" title="tsc 的--traceResolution参数"></a>tsc 的<code>--traceResolution</code>参数</h3><p>由于模块定位的过程很复杂，tsc 命令有一个<code>--traceResolution</code>参数，能够在编译时在命令行显示模块定位的每一步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --traceResolution</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>traceResolution</code>会输出模块定位的判断过程。</p>
<h3 id="tsc-的-noResolve参数"><a href="#tsc-的-noResolve参数" class="headerlink" title="tsc 的--noResolve参数"></a>tsc 的<code>--noResolve</code>参数</h3><p>tsc 命令的<code>--noResolve</code>参数，表示模块定位时，只考虑在命令行传入的模块。</p>
<p>举例来说，<code>app.ts</code>包含如下两行代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> A <span class="keyword">from</span> <span class="string">&quot;moduleA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> B <span class="keyword">from</span> <span class="string">&quot;moduleB&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>使用下面的命令进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc app.ts moduleA.ts --noResolve</span><br></pre></td></tr></table></figure>

<p>上面命令使用<code>--noResolve</code>参数，因此可以定位到<code>moduleA.ts</code>，因为它从命令行传入了；无法定位到<code>moduleB</code>，因为它没有传入，因此会报错。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.51cto.com/u_13028258/5754309">tsconfig 之 importsNotUsedAsValues 属性</a></li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的类型映射</title>
    <url>/2023/09/05/ts-mapping/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>映射（mapping）指的是，将一种类型按照映射规则，转换成另一种类型，通常用于对象类型。</p>
<p>举例来说，现有一个类型<code>A</code>和另一个类型<code>B</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，这两个类型的属性结构是一样的，但是属性的类型不一样。如果属性数量多的话，逐个写起来就很麻烦。</p>
<p>使用类型映射，就可以从类型<code>A</code>得到类型<code>B</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [prop <span class="keyword">in</span> keyof A]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>B</code>采用了属性名索引的写法，<code>[prop in keyof A]</code>表示依次得到类型<code>A</code>的所有属性名，然后将每个属性的类型改成<code>string</code>。</p>
<p>在语法上，<code>[prop in keyof A]</code>是一个属性名表达式，表示这里的属性名需要计算得到。具体的计算规则如下：</p>
<ul>
<li><code>prop</code>：属性名变量，名字可以随便起。</li>
<li><code>in</code>：运算符，用来取出右侧的联合类型的每一个成员。</li>
<li><code>keyof A</code>：返回类型<code>A</code>的每一个属性名，组成一个联合类型。</li>
</ul>
<p>下面是复制原始类型的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [prop <span class="keyword">in</span> keyof A]: A[prop];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>B</code>原样复制了类型<code>A</code>。</p>
<p>为了增加代码复用性，可以把常用的映射写成泛型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToBoolean</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，定义了一个泛型，可以将其他对象的所有属性值都改成 boolean 类型。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> <span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="number">1</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="number">2</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，联合类型<code>0|1|2</code>映射成了三个属性名。</p>
<p>不使用联合类型，直接使用某种具体类型进行属性名映射，也是可以的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="string">&#x27;foo&#x27;</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p in &#39;foo&#39;</code>可以看成只有一个成员的联合类型，因此得到了只有这一个属性的对象类型。</p>
<p>甚至还可以写成<code>p in string</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [<span class="attr">p</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[p in string]</code>就是属性名索引形式<code>[p: string]</code>的映射写法。</p>
<p>通过映射，可以把某个对象的所有属性改成可选属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof A]?: A[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>B</code>在类型<code>A</code>的所有属性名后面添加问号，使得这些属性都变成了可选属性。</p>
<p>事实上，TypeScript 的内置工具类型<code>Partial&lt;T&gt;</code>，就是这样实现的。</p>
<p>TypeScript内置的工具类型<code>Readonly&lt;T&gt;</code>可以将所有属性改为只读属性，实现也是通过映射。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 T 的所有属性改为只读属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的用法如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyT</span> = <span class="title class_">Readonly</span>&lt;T&gt;;</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   readonly a: string;</span></span><br><span class="line"><span class="comment">//   readonly b: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="映射修饰符"><a href="#映射修饰符" class="headerlink" title="映射修饰符"></a>映射修饰符</h2><p>映射会原样复制原始对象的可选属性和只读属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  a?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof A]: A[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  a?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>B</code>是类型<code>A</code>的映射，把<code>A</code>的可选属性和只读属性都保留下来。</p>
<p>如果要删改可选和只读这两个特性，并不是很方便。为了解决这个问题，TypeScript 引入了两个映射修饰符，用来在映射时添加或移除某个属性的<code>?</code>修饰符和<code>readonly</code>修饰符。</p>
<ul>
<li><code>+</code>修饰符：写成<code>+?</code>或<code>+readonly</code>，为映射属性添加<code>?</code>修饰符或<code>readonly</code>修饰符。</li>
<li><code>–</code>修饰符：写成<code>-?</code>或<code>-readonly</code>，为映射属性移除<code>?</code>修饰符或<code>readonly</code>修饰符。</li>
</ul>
<p>下面是添加或移除可选属性的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加可选属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Optional</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]+?: <span class="title class_">Type</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除可选属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]-?: <span class="title class_">Type</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，<code>+?</code>或<code>-?</code>要写在属性名的后面。</p>
<p>下面是添加或移除只读属性的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加 readonly</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateImmutable</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 readonly</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateMutable</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，<code>+readonly</code>和<code>-readonly</code>要写在属性名的前面。</p>
<p>如果同时增删<code>?</code>和<code>readonly</code>这两个修饰符，写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span>&lt;T&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]+?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 原生的工具类型<code>Required&lt;T&gt;</code>专门移除可选属性，就是使用<code>-?</code>修饰符实现的。</p>
<p>注意，<code>–?</code>修饰符移除了可选属性以后，该属性就不能等于<code>undefined</code>了，实际变成必选属性了。但是，这个修饰符不会移除<code>null</code>类型。</p>
<p>另外，<code>+?</code>修饰符可以简写成<code>?</code>，<code>+readonly</code>修饰符可以简写成<code>readonly</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A&lt;T&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]+?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> A&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="键名重映射"><a href="#键名重映射" class="headerlink" title="键名重映射"></a>键名重映射</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>TypeScript 4.1 引入了键名重映射（key remapping），允许改变键名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> keyof A <span class="keyword">as</span> <span class="string">`<span class="subst">$&#123;p&#125;</span>ID`</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">fooID</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">barID</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>B</code>是类型<code>A</code>的映射，但在映射时把属性名改掉了，在原始属性名后面加上了字符串<code>ID</code>。</p>
<p>可以看到，键名重映射的语法是在键名映射的后面加上<code>as + 新类型</code>子句。这里的“新类型”通常是一个模板字符串，里面可以对原始键名进行各种操作。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T</span><br><span class="line">    <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; P&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LazyPerson</span> = <span class="title class_">Getters</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LazyPerson</span> = &#123;</span><br><span class="line">  <span class="attr">getName</span>: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">getAge</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">getLocation</span>: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>LazyPerson</code>是类型<code>Person</code>的映射，并且把键名改掉了。</p>
<p>它的修改键名的代码是一个模板字符串<code>get$&#123;Capitalize&lt;string &amp; P&gt;&#125;</code>，下面是各个部分的解释。</p>
<ul>
<li><code>get</code>：为键名添加的前缀。</li>
<li><code>Capitalize&lt;T&gt;</code>：一个原生的工具泛型，用来将<code>T</code>的首字母变成大写。</li>
<li><code>string &amp; P</code>：一个交叉类型，其中的<code>P</code>是 keyof 运算符返回的键名联合类型<code>string|number|symbol</code>，但是<code>Capitalize&lt;T&gt;</code>只能接受字符串作为类型参数，因此<code>string &amp; P</code>只返回<code>P</code>的字符串属性名。</li>
</ul>
<h3 id="属性过滤"><a href="#属性过滤" class="headerlink" title="属性过滤"></a>属性过滤</h3><p>键名重映射还可以过滤掉某些属性。下面的例子是只保留字符串属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Filter</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T</span><br><span class="line">    <span class="keyword">as</span> T[K] <span class="keyword">extends</span> <span class="built_in">string</span> ? K : <span class="built_in">never</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FilteredUser</span> = <span class="title class_">Filter</span>&lt;<span class="title class_">User</span>&gt; <span class="comment">// &#123; name: string &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，映射<code>K in keyof T</code>获取类型<code>T</code>的每一个属性以后，然后使用<code>as Type</code>修改键名。</p>
<p>它的键名重映射<code>as T[K] extends string ? K : never]</code>，使用了条件运算符。如果属性值<code>T[K]</code>的类型是字符串，那么属性名不变，否则属性名类型改为<code>never</code>，即这个属性名不存在。这样就等于过滤了不符合条件的属性，只保留属性值为字符串的属性。</p>
<h3 id="联合类型的映射"><a href="#联合类型的映射" class="headerlink" title="联合类型的映射"></a>联合类型的映射</h3><p>由于键名重映射可以修改键名类型，所以原始键名的类型不必是<code>string|number|symbol</code>，任意的联合类型都可以用来进行键名重映射。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> S = &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;square&#x27;</span>,</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyEvents</span>&lt;<span class="title class_">Events</span> <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">  [E <span class="keyword">in</span> <span class="title class_">Events</span> <span class="keyword">as</span> E[<span class="string">&#x27;kind&#x27;</span>]]: <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = <span class="title class_">MyEvents</span>&lt;S|C&gt;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = &#123;</span><br><span class="line">  <span class="attr">square</span>: <span class="function">(<span class="params">event:S</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">circle</span>: <span class="function">(<span class="params">event:C</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，原始键名的映射是<code>E in Events</code>，这里的<code>Events</code>是两个对象组成的联合类型<code>S|C</code>。所以，<code>E</code>是一个对象，然后再通过键名重映射，得到字符串键名<code>E[&#39;kind&#39;]</code>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://mariusschulz.com/blog/mapped-type-modifiers-in-typescript">Mapped Type Modifiers in TypeScript</a>, Marius Schulz</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 类型缩小</title>
    <url>/2023/09/05/ts-narrowing/</url>
    <content><![CDATA[<div id="readmore-container"><p>TypeScript 变量的值可以变，但是类型通常是不变的。唯一允许的改变，就是类型缩小，就是将变量值的范围缩得更小。</p>
<h2 id="手动类型缩小"><a href="#手动类型缩小" class="headerlink" title="手动类型缩小"></a>手动类型缩小</h2><p>如果一个变量属于联合类型，所以使用时一般需要缩小类型。</p>
<p>第一种方法是使用<code>if</code>判断。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getScore</span>(<span class="params">value: <span class="built_in">number</span>|<span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123; <span class="comment">// (A)</span></span><br><span class="line">    <span class="comment">// %inferred-type: number</span></span><br><span class="line">    value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123; <span class="comment">// (B)</span></span><br><span class="line">    <span class="comment">// %inferred-type: string</span></span><br><span class="line">    value;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unsupported value: &#x27;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个值是<code>any</code>或<code>unknown</code>，你又想对它进行处理，就必须先缩小类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseStringLiteral</span>(<span class="params">stringLiteral: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">unknown</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(stringLiteral);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;string&#x27;</span>) &#123; <span class="comment">// (A)</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string literal: &#x27;</span> + stringLiteral);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="literal">null</span> | <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">isbn</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTitle</span>(<span class="params">book: Book</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (book.<span class="property">title</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: null</span></span><br><span class="line">    book.<span class="property">title</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(Untitled)&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: string</span></span><br><span class="line">    book.<span class="property">title</span>;</span><br><span class="line">    <span class="keyword">return</span> book.<span class="property">title</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩小类型的前提是，需要先获取类型。获取类型的几种方法如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">value: <span class="built_in">Function</span>|<span class="built_in">Date</span>|<span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: Function</span></span><br><span class="line">    value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: Date</span></span><br><span class="line">    value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: number[]</span></span><br><span class="line">    value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><p>第二种方法是使用<code>switch</code>缩小类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getScore</span>(<span class="params">value: <span class="built_in">number</span>|<span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="comment">// %inferred-type: number</span></span><br><span class="line">      value;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">      <span class="comment">// %inferred-type: string</span></span><br><span class="line">      value;</span><br><span class="line">      <span class="keyword">return</span> value.<span class="property">length</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unsupported value: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>第三种方法是instanceof运算符。它能够检测实例对象与构造函数之间的关系。instanceof运算符的左操作数为实例对象，右操作数为构造函数，若构造函数的prototype属性值存在于实例对象的原型链上，则返回true；否则，返回false。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: <span class="built_in">Date</span> | <span class="built_in">RegExp</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">        x; <span class="comment">// Date</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">        x; <span class="comment">// RegExp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instanceof类型守卫同样适用于自定义构造函数，并对其实例对象进行类型细化。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: A | B</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (x <span class="keyword">instanceof</span> A) &#123;</span><br><span class="line">       x; <span class="comment">// A</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (x <span class="keyword">instanceof</span> B) &#123;</span><br><span class="line">       x; <span class="comment">// B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>第四种方法是使用in运算符。</p>
<p>in运算符是JavaScript中的关系运算符之一，用来判断对象自身或其原型链中是否存在给定的属性，若存在则返回true，否则返回false。in运算符有两个操作数，左操作数为待测试的属性名，右操作数为测试对象。</p>
<p>in类型守卫根据in运算符的测试结果，将右操作数的类型细化为具体的对象类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: A | B</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> x) &#123;</span><br><span class="line">        x; <span class="comment">// A</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x; <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">a</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123; <span class="attr">b</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickAB</span>(<span class="params">ab: A | B</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> ab) &#123;</span><br><span class="line"> ab <span class="comment">// Type is A</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ab <span class="comment">// Type is B</span></span><br><span class="line"> &#125;</span><br><span class="line"> ab <span class="comment">// Type is A | B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩小对象的属性，要用<code>in</code>运算符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FirstOrSecond</span> =</span><br><span class="line">  | &#123;<span class="attr">first</span>: <span class="built_in">string</span>&#125;</span><br><span class="line">  | &#123;<span class="attr">second</span>: <span class="built_in">string</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">firstOrSecond: FirstOrSecond</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;second&#x27;</span> <span class="keyword">in</span> firstOrSecond) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: &#123; second: string; &#125;</span></span><br><span class="line">    firstOrSecond;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">firstOrSecond: FirstOrSecond</span>) &#123;</span><br><span class="line">  <span class="comment">// @ts-expect-error: Property &#x27;second&#x27; does not exist on</span></span><br><span class="line">  <span class="comment">// type &#x27;FirstOrSecond&#x27;. [...]</span></span><br><span class="line">  <span class="keyword">if</span> (firstOrSecond.<span class="property">second</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符只能用于联合类型，不能用于检查一个属性是否存在。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">obj: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: object</span></span><br><span class="line">    obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    obj.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特征属性"><a href="#特征属性" class="headerlink" title="特征属性"></a>特征属性</h3><p>对于不同对象之间的区分，还可以人为地为每一类对象设置一个特征属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UploadEvent</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;upload&#x27;</span>;</span><br><span class="line">    <span class="attr">filename</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">contents</span>: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DownloadEvent</span> &#123; <span class="attr">type</span>: <span class="string">&#x27;download&#x27;</span>; <span class="attr">filename</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AppEvent</span> = <span class="title class_">UploadEvent</span> | <span class="title class_">DownloadEvent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">e: AppEvent</span>) &#123;</span><br><span class="line"> <span class="keyword">switch</span> (e.<span class="property">type</span>) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;download&#x27;</span>:</span><br><span class="line"> e <span class="comment">// Type is DownloadEvent</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;upload&#x27;</span>:</span><br><span class="line"> e; <span class="comment">// Type is UploadEvent</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="any-类型的细化"><a href="#any-类型的细化" class="headerlink" title="any 类型的细化"></a>any 类型的细化</h2><p>TypeScript 推断变量类型时，会根据获知的信息，不断改变推断出来的类型，越来越细化。这种现象在<code>any</code>身上特别明显。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">range</span>(<span class="params"></span></span><br><span class="line"><span class="params">  start:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  limit:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> out = []; <span class="comment">// 类型为 any[]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; limit; i++) &#123;</span><br><span class="line">    out.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out; <span class="comment">// 类型为 number[]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面示例中，变量`</span>out<span class="string">`的类型一开始推断为`</span><span class="built_in">any</span>[]<span class="string">`，后来在里面放入数值，类型就变为`</span><span class="built_in">number</span>[]<span class="string">`。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">再看下面的例子。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>typescript</span><br><span class="line"><span class="keyword">const</span> result = []; <span class="comment">// 类型为 any[]</span></span><br><span class="line">result.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">result <span class="comment">// 类型为 string[]</span></span><br><span class="line">result.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">result <span class="comment">// 类型为 (string | number)[]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>result</code>随着成员类型的不同，而不断改变自己的类型。</p>
<p>注意，这种<code>any</code>类型的细化，只在打开了编译选项<code>noImplicitAny</code>时发生。</p>
<p>这时，如果在变量的推断类型还为<code>any</code>时（即没有任何写操作)，就去输出（或读取）该变量，则会报错，因为这时推断还没有完成，无法满足<code>noImplicitAny</code>的要求。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = []; <span class="comment">// 类型为 any[]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> result); <span class="comment">// 报错</span></span><br><span class="line">result.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 类型为 string[]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，只有运行完第三行，<code>result</code>的类型才能完成第一次推断，所以第二行读取<code>result</code>就会报错。</p>
<h2 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h2><p><code>is</code>运算符返回一个布尔值，用来判断左侧的值是否属于右侧的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInputElement</span>(<span class="params">el: HTMLElement</span>): el is <span class="title class_">HTMLInputElement</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElementContent</span>(<span class="params">el: HTMLElement</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isInputElement</span>(el)) &#123;</span><br><span class="line"> el; <span class="comment">// Type is HTMLInputElement</span></span><br><span class="line">    <span class="keyword">return</span> el.<span class="property">value</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> el; <span class="comment">// Type is HTMLElement</span></span><br><span class="line"> <span class="keyword">return</span> el.<span class="property">textContent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isDefined&lt;T&gt;(<span class="attr">x</span>: T | <span class="literal">undefined</span>): x is T &#123;</span><br><span class="line"> <span class="keyword">return</span> x !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript namespace</title>
    <url>/2023/09/05/ts-namespace/</url>
    <content><![CDATA[<div id="readmore-container"><p>namespace 是一种将相关代码组织在一起的方式，中文译为“命名空间”。</p>
<p>它出现在 ES 模块诞生之前，作为 TypeScript 自己的模块格式而发明的。但是，自从有了 ES 模块，官方已经不推荐使用 namespace 了。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>namespace 用来建立一个容器，内部的所有变量和函数，都必须在这个容器里面使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="title function_">isString</span>(<span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Utils</span>.<span class="title function_">isString</span>(<span class="string">&#x27;no&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，命名空间<code>Utils</code>里面定义了一个函数<code>isString()</code>，它只能在<code>Utils</code>里面使用，如果用于外部就会报错。</p>
<p>如果要在命名空间以外使用内部成员，就必须为该成员加上<code>export</code>前缀，表示对外输出该成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">log</span>(<span class="string">&#x27;Call me&#x27;</span>);</span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">error</span>(<span class="string">&#x27;maybe!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，只要加上<code>export</code>前缀，就可以在命名空间外部使用内部成员。</p>
<p>编译出来的 JavaScript 代码如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Utility</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Utility</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Utility</span>.<span class="property">log</span> = log;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Utility</span>.<span class="property">error</span> = error;</span><br><span class="line">&#125;)(<span class="title class_">Utility</span> || (<span class="title class_">Utility</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>上面代码中，命名空间<code>Utility</code>变成了 JavaScript 的一个对象，凡是<code>export</code>的内部成员，都成了该对象的属性。</p>
<p>这就是说，namespace 会变成一个值，保留在编译后的代码中。这一点要小心，它不是纯的类型代码。</p>
<p>namespace 内部还可以使用<code>import</code>命令输入外部成员，相当于为外部成员起别名。当外部成员的名字比较长时，别名能够简化代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> isString = <span class="title class_">Utils</span>.<span class="property">isString</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isString</span>(<span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="title class_">Utils</span>.<span class="title function_">isString</span>(<span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>import</code>命令指定在命名空间<code>App</code>里面，外部成员<code>Utils.isString</code>的别名为<code>isString</code>。</p>
<p><code>import</code>命令也可以在 namespace 外部，指定别名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Polygons</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = <span class="title class_">Shapes</span>.<span class="property">Polygons</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 new Shapes.Polygons.Square()</span></span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.<span class="title class_">Square</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>import</code>命令在命名空间<code>Shapes</code>的外部，指定<code> Shapes.Polygons</code>的别名为<code>polygons</code>。</p>
<p>namespace 可以嵌套。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Messaging</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Utils</span>.<span class="property">Messaging</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，命名空间<code>Utils</code>内部还有一个命名空间<code>Messaging</code>。注意，如果要在外部使用<code>Messaging</code>，必须在它前面加上<code>export</code>命令。</p>
<p>使用嵌套的命名空间，必须从最外层开始引用，比如<code>Utils.Messaging.log()</code>。</p>
<p>namespace 不仅可以包含实义代码，还可以包括类型代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，命令空间<code>N</code>不仅对外输出类，还对外输出一个接口，它们都可以用作类型。</p>
<p>namespace 与模块的作用是一致的，都是把相关代码组织在一起，对外输出接口。区别是一个文件只能有一个模块，但可以有多个 namespace。由于模块可以取代 namespace，而且是 JavaScript 的标准语法，还不需要编译转换，所以建议总是使用模块，替代 namespace。</p>
<p>如果 namespace 代码放在一个单独的文件里，那么引入这个文件需要使用三斜杠的语法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = &quot;SomeFileName.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="namespace-的输出"><a href="#namespace-的输出" class="headerlink" title="namespace 的输出"></a>namespace 的输出</h2><p>namespace 本身也可以使用<code>export</code>命令输出，供其他文件使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是一个文件<code>shapes.ts</code>，里面使用<code>export</code>命令，输出了一个命名空间<code>Shapes</code>。</p>
<p>其他脚本文件使用<code>import</code>命令，加载这个命名空间。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Shapes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./shapes&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="title class_">Shapes</span>.<span class="title class_">Triangle</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">&quot;./shapes&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.<span class="property">Shapes</span>.<span class="title class_">Triangle</span>();</span><br></pre></td></tr></table></figure>

<p>不过，更好的方法还是建议使用模块，采用模块的输出和输入。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shapeConsumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">&quot;./shapes&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.<span class="title class_">Triangle</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，使用模块的输出和输入，改写了前面的例子。</p>
<h2 id="namespace-的合并"><a href="#namespace-的合并" class="headerlink" title="namespace 的合并"></a>namespace 的合并</h2><p>多个同名的 namespace 会自动合并，这一点跟 interface 一样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Legged</span> &#123;</span><br><span class="line">    <span class="attr">numberOfLegs</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Legged</span> &#123;</span><br><span class="line">    <span class="attr">numberOfLegs</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的目的是，如果同名的命名空间分布在不同的文件中，TypeScript 最终会将它们合并在一起。这样就比较方便扩展别人的代码。</p>
<p>合并命名空间时，命名空间中的非<code>export</code>的成员不会被合并，但是它们只能在各自的命名空间中使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">foo</span>(); <span class="comment">// 正确</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>是第一个名称空间<code>N</code>的非对外成员，它只在第一个名称空间可用。</p>
<p>命名空间还可以跟同名函数合并，但是要求同名函数必须在命名空间之前声明。这样做是为了确保先创建出一个函数对象，然后同名的命名空间就相当于给这个函数对象添加额外的属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> f.<span class="property">version</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> f &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> version = <span class="string">&#x27;1.0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()   <span class="comment">// &#x27;1.0&#x27;</span></span><br><span class="line">f.<span class="property">version</span> <span class="comment">// &#x27;1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>与命名空间<code>f</code>合并，相当于命名空间为函数对象<code>f</code>添加属性。</p>
<p>命名空间也能与同名 class 合并，同样要求class 必须在命名空间之前声明，原因同上。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C.<span class="property">bar</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，名称空间<code>C</code>为类<code>C</code>添加了一个静态属性<code>bar</code>。</p>
<p>命名空间还能与同名 Enum 合并。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> E &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(E.<span class="property">C</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E.<span class="title function_">foo</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，命名空间<code>E</code>为枚举<code>E</code>添加了一个<code>foo()</code>方法。</p>
<p>注意，Enum 成员与命名空间导出成员不允许同名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  A, <span class="comment">// 报错</span></span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> E &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，同名 Enum 与命名空间有同名成员，结果报错。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的对象类型</title>
    <url>/2023/09/05/ts-object/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>除了原始类型，对象是 JavaScript 最基本的数据结构。TypeScript 对于对象类型有很多规则。</p>
<p>对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>obj</code>的类型就写在变量名后面，使用大括号描述，内部声明每个属性的属性名和类型。</p>
<p>属性的类型可以用分号结尾，也可以用逗号结尾。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 属性类型以分号结尾</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性类型以逗号结尾</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后一个属性后面，可以写分号或逗号，也可以不写。</p>
<p>一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">o1</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">o2</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">1</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>o1</code>缺少了属性<code>y</code>，变量<code>o2</code>多出了属性<code>z</code>，都会报错。</p>
<p>读写不存在的属性也会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">z</span>); <span class="comment">// 报错</span></span><br><span class="line">obj.<span class="property">z</span> = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，读写不存在的属性<code>z</code>都会报错。</p>
<p>同样地，也不能删除类型声明中存在的属性，修改属性值是可以的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sabrina&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myUser.<span class="property">name</span> <span class="comment">// 报错</span></span><br><span class="line">myUser.<span class="property">name</span> = <span class="string">&quot;Cynthia&quot;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面声明中，删除类型声明中存在的属性<code>name</code>会报错，但是可以修改它的值。</p>
<p>对象的方法使用函数类型描述。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 或者写成</span></span><br><span class="line">  <span class="comment">// add: (x:number, y:number) =&gt; number;</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>obj</code>有一个方法<code>add()</code>，需要定义它的参数类型和返回值类型。</p>
<p>对象类型可以使用方括号读取属性的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">User</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象类型<code>User</code>使用方括号，读取了属性<code>name</code>的类型（<code>string</code>）。</p>
<p>除了<code>type</code>命令可以为对象类型声明一个别名，TypeScript 还提供了<code>interface</code>命令，可以把对象类型提炼为一个接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，写法一是<code>type</code>命令的用法，写法二是<code>interface</code>命令的用法。<code>interface</code>命令的详细解释，以及与<code>type</code>命令的区别，详见《Interface》一章。</p>
<p>注意，TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="title function_">toString</span>(): <span class="built_in">string</span>; <span class="comment">// 继承的属性</span></span><br><span class="line">  <span class="attr">prop</span>: <span class="built_in">number</span>; <span class="comment">// 自身的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyInterface</span> = &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="attr">prop</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>obj</code>只写了<code>prop</code>属性，但是不报错。因为它可以继承原型上面的<code>toString()</code>方法。</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>y</code>是可选的。</p>
<p>可选属性等同于允许赋值为<code>undefined</code>，下面两种写法是等效的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>|<span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>User</code>的可选属性<code>lastName</code>可以是字符串，也可以是<code>undefined</code>，即可选属性可以赋值为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="literal">undefined</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，可选属性<code>y</code>赋值为<code>undefined</code>，不会报错。</p>
<p>同样地，读取一个没有赋值的可选属性时，返回<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">string</span>,</span><br><span class="line">  y?: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line">obj.<span class="property">y</span>.<span class="title function_">toLowerCase</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行会报错，因为<code>obj.y</code>返回<code>undefined</code>，无法对其调用<code>toLowerCase()</code>。</p>
<p>所以，读取可选属性之前，必须检查一下是否为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user</span>:&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">firstName</span>: <span class="string">&#x27;Foo&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user.<span class="property">lastName</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>lastName</code>是可选属性，需要判断是否为<code>undefined</code>以后，才能使用。建议使用下面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> firstName = (user.<span class="property">firstName</span> === <span class="literal">undefined</span>)</span><br><span class="line">  ? <span class="string">&#x27;Foo&#x27;</span> : user.<span class="property">firstName</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = (user.<span class="property">lastName</span> === <span class="literal">undefined</span>)</span><br><span class="line">  ? <span class="string">&#x27;Bar&#x27;</span> : user.<span class="property">lastName</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> firstName = user.<span class="property">firstName</span> ?? <span class="string">&#x27;Foo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = user.<span class="property">lastName</span> ?? <span class="string">&#x27;Bar&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，写法一使用三元运算符<code>?:</code>，判断是否为<code>undefined</code>，并设置默认值。写法二使用 Null 判断运算符<code>??</code>，与写法一的作用完全相同。</p>
<p>TypeScript 提供编译设置<code>ExactOptionalPropertyTypes</code>，只要同时打开这个设置和<code>strictNullChecks</code>，可选属性就不能设为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开 ExactOptionsPropertyTypes 和 strictNullChecks</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="literal">undefined</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，打开了这两个设置以后，可选属性就不能设为<code>undefined</code>了。</p>
<p>注意，可选属性与允许设为<code>undefined</code>的必选属性是不等价的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">x</span>:<span class="built_in">number</span>, y?:<span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>|<span class="literal">undefined</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ObjA</span>:A = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ObjB</span>:B = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>y</code>如果是一个可选属性，那就可以省略不写；如果是允许设为<code>undefined</code>的必选属性，一旦省略就会报错，必须显式写成<code>&#123; x: 1, y: undefined &#125;</code>。</p>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>属性名前面加上<code>readonly</code>关键字，表示这个属性是只读属性，不能修改。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">prop</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>prop</code>属性是只读属性，不能修改它的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">person</span>:&#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125; = &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">21</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行修改了只读属性<code>age</code>，就报错了。</p>
<p>只读属性只能在对象初始化期间赋值，此后就不能修改该属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">p.<span class="property">x</span> = <span class="number">100</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Point</code>的属性<code>x</code>和<code>y</code>都带有修饰符<code>readonly</code>，表示这两个属性只能在初始化期间赋值，后面再修改就会报错。</p>
<p>注意，如果属性值是一个对象，<code>readonly</code>修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">resident</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">h</span>:<span class="title class_">Home</span> = &#123;</span><br><span class="line">  <span class="attr">resident</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Vicky&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">h.<span class="property">resident</span>.<span class="property">age</span> = <span class="number">32</span>; <span class="comment">// 正确</span></span><br><span class="line">h.<span class="property">resident</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Kate&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span> </span><br><span class="line">&#125; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>h.resident</code>是只读属性，它的值是一个对象。修改这个对象的<code>age</code>属性是可以的，但是整个替换掉<code>h.resident</code>属性会报错。</p>
<p>另一个需要注意的地方是，如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyPerson</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">w</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Vicky&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">r</span>:<span class="title class_">ReadonlyPerson</span> = w;</span><br><span class="line"></span><br><span class="line">w.<span class="property">age</span> += <span class="number">1</span>;</span><br><span class="line">r.<span class="property">age</span> <span class="comment">// 43</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>w</code>和<code>r</code>指向同一个对象，其中<code>w</code>是可写的，<code>r</code>是只读的。那么，对<code>w</code>的属性修改，会影响到<code>r</code>。</p>
<p>如果希望属性值是只读的，除了声明时加上<code>readonly</code>关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言<code>as const</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sabrina&quot;</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">myUser.<span class="property">name</span> = <span class="string">&quot;Cynthia&quot;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象后面加了只读断言<code>as const</code>，就变成只读对象了，不能修改属性了。</p>
<p>注意，上面的<code>as const</code>属于 TypeScript 的类型推断，如果变量明确地声明了类型，那么 TypeScript 会以声明的类型为准。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">myUser</span>:&#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sabrina&quot;</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">myUser.<span class="property">name</span> = <span class="string">&quot;Cynthia&quot;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，根据变量<code>myUser</code>的类型声明，<code>name</code>不是只读属性，但是赋值时又使用只读断言<code>as const</code>。这时会以声明的类型为准，因为<code>name</code>属性可以修改。</p>
<h2 id="属性名的索引类型"><a href="#属性名的索引类型" class="headerlink" title="属性名的索引类型"></a>属性名的索引类型</h2><p>如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。</p>
<p>索引类型里面，最常见的就是属性名的字符串索引。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>MyObj</code>的属性名类型就采用了表达式形式，写在方括号里面。<code>[property: string]</code>的<code>property</code>表示属性名，这个是可以随便起的，它的类型是<code>string</code>，即属性名类型为<code>string</code>。也就是说，不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明。</p>
<p>JavaScript 对象的属性名（即上例的<code>property</code>）的类型有三种可能，除了上例的<code>string</code>，还有<code>number</code>和<code>symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">symbol</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象属性名的类型分别为<code>number</code>和<code>symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  [<span class="attr">n</span>:<span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象类型<code>MyArr</code>的属性名是<code>[n:number]</code>，就表示它的属性名都是数值，比如<code>0</code>、<code>1</code>、<code>2</code>。</p>
<p>对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引。但是，数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">boolean</span>; <span class="comment">// 报错</span></span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>MyType</code>同时有两种属性名索引，但是数值索引与字符串索引冲突了，所以报错了。由于字符属性名的值类型是<code>string</code>，数值属性名的值类型只有同样为<code>string</code>，才不会报错。</p>
<p>同样地，可以既声明属性名索引，也声明具体的单个属性名。如果单个属性名符合属性名索引的范围，两者不能有冲突，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">boolean</span>; <span class="comment">// 报错</span></span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性名<code>foo</code>符合属性名的字符串索引，但是两者的属性值类型不一样，所以报错了。</p>
<p>属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。另外，属性名的数值索引不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及<code>length</code>属性，因为类型里面没有定义这些东西。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  [<span class="attr">n</span>:<span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，读取<code>arr.length</code>属性会报错，因为类型<code>MyArr</code>没有这个属性。</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值用于直接从对象中提取属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, price&#125; = product;</span><br></pre></td></tr></table></figure>

<p>上面语句从对象<code>product</code>提取了三个属性，并声明属性名的同名变量。</p>
<p>解构赋值的类型写法，跟为对象声明类型是一样的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, price&#125;:&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span></span><br><span class="line">&#125; = product;</span><br></pre></td></tr></table></figure>

<p>注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: foo, <span class="attr">y</span>: bar &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> foo = obj.<span class="property">x</span>;</span><br><span class="line"><span class="keyword">let</span> bar = obj.<span class="property">y</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，冒号不是表示属性<code>x</code>和<code>y</code>的类型，而是为这两个属性指定新的变量名。如果要为<code>x</code>和<code>y</code>指定类型，不得不写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: foo, <span class="attr">y</span>: bar &#125;</span><br><span class="line">  : &#123; <span class="attr">x</span>: <span class="built_in">string</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125; = obj;</span><br></pre></td></tr></table></figure>

<p>这一点要特别小心，TypeScript 里面很容易搞糊涂。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  shape: Shape,</span></span><br><span class="line"><span class="params">  xPos: <span class="built_in">number</span> = <span class="number">100</span>,</span></span><br><span class="line"><span class="params">  yPos: <span class="built_in">number</span> = <span class="number">100</span></span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myShape = shape; <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">let</span> x = xPos; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>draw()</code>的参数是一个对象解构，里面的冒号很像是为变量指定类型，其实是为对应的属性指定新的变量名。所以，TypeScript 就会解读成，函数体内不存在变量<code>shape</code>，而是属性<code>shape</code>的值被赋值给了变量<code>Shape</code>。</p>
<h2 id="结构类型原则"><a href="#结构类型原则" class="headerlink" title="结构类型原则"></a>结构类型原则</h2><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structural typing）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>A</code>只有一个属性<code>x</code>，类型为<code>number</code>。对象<code>B</code>满足这个特征，因此兼容对象<code>A</code>，只要可以使用<code>A</code>的地方，就可以使用<code>B</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> B = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">A</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; = B; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>和<code>B</code>并不是同一个类型，但是<code>B</code>可以赋值给<code>A</code>，因为<code>B</code>满足<code>A</code>的结构特征。</p>
<p>根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查这个值的结构是否符合要求（即“结构类型”）。</p>
<p>TypeScript 之所以这样设计，是为了符合 JavaScript 的行为。JavaScript 并不关心对象是否严格相似，只要某个对象具有所要求的属性，就可以正确运行。</p>
<p>如果类型 B 可以赋值给类型 A，TypeScript 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。</p>
<p>这种设计有时会导致令人惊讶的结果。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myObj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">obj:myObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">const</span> v = obj[n]; <span class="comment">// 报错</span></span><br><span class="line">    sum += <span class="title class_">Math</span>.<span class="title function_">abs</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>getSum()</code>要求传入参数的类型是<code>myObj</code>，但是实际上所有与<code>myObj</code>兼容的对象都可以传入。这会导致<code>const v = obj[n]</code>这一行报错，原因是<code>obj[n]</code>取出的属性值不一定是数值（<code>number</code>），使得变量<code>v</code>的类型被推断为<code>any</code>。如果项目设置为不允许变量类型推断为<code>any</code>，代码就会报错。写成下面这样，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">obj:MyObj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(obj.<span class="property">x</span>) + <span class="title class_">Math</span>.<span class="title function_">abs</span>(obj.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例就不会报错，因为函数体内部只使用了属性<code>x</code>和<code>y</code>，这两个属性有明确的类型声明，保证<code>obj.x</code>和<code>obj.y</code>肯定是数值。虽然与<code>MyObj</code>兼容的任何对象都可以传入函数<code>getSum()</code>，但是只要不使用其他属性，就不会有类型报错。</p>
<h2 id="严格字面量检查"><a href="#严格字面量检查" class="headerlink" title="严格字面量检查"></a>严格字面量检查</h2><p>如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）。如果字面量的结构跟类型定义的不一样（比如多出了未定义的属性），就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">1</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，等号右边是一个对象的字面量，这时会触发严格字面量检查。只要有类型声明中不存在的属性（本例是<code>z</code>），就会导致报错。</p>
<p>如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPoint = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = myPoint; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，等号右边是一个变量，就不会触发严格字面量检查，从而不报错。</p>
<p>TypeScript 对字面量进行严格检查的目的，主要是防止拼写错误。一般来说，字面量大多数来自手写，容易出现拼写错误，或者误用 API。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>:<span class="built_in">string</span>;</span><br><span class="line">  darkMode?:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的网页&#x27;</span>,</span><br><span class="line">  <span class="attr">darkmode</span>: <span class="literal">true</span>, <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>darkMode</code>拼写错了，成了<code>darkmode</code>。如果没有严格字面量规则，就不会报错，因为<code>darkMode</code>是可选属性，根据结构类型原则，任何对象只要有<code>title</code>属性，都认为符合<code>Options</code>类型。</p>
<p>规避严格字面量检查，可以使用中间变量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myOptions = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的网页&#x27;</span>,</span><br><span class="line">  <span class="attr">darkmode</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = myOptions;</span><br></pre></td></tr></table></figure>

<p>上面示例中，创建了一个中间变量<code>myOptions</code>，就不会触发严格字面量规则，因为这时变量<code>obj</code>的赋值，不属于直接字面量赋值。</p>
<p>如果你确认字面量没有错误，也可以使用类型断言规避严格字面量检查。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的网页&#x27;</span>,</span><br><span class="line">  <span class="attr">darkmode</span>: <span class="literal">true</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">Options</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例使用类型断言<code>as Options</code>，告诉编译器，字面量符合 Options 类型，就能规避这条规则。</p>
<p>如果允许字面量有多余属性，可以像下面这样在类型里面定义一个通用属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">baz</span>: <span class="number">2</span> &#125;;  <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型声明里面，有一个属性的字符串索引（<code>[x: string]</code>），导致任何字符串属性名都是合法的。</p>
<p>由于严格字面量检查，字面量对象传入函数必须很小心，不能有多余的属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computeDistance</span>(<span class="params">point: Point</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">computeDistance</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;); <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">computeDistance</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象字面量传入函数<code>computeDistance()</code>时，不能有多余的属性，否则就通不过严格字面量检查。</p>
<p>编译器选项<code>suppressExcessPropertyErrors</code>，可以关闭多余属性检查。下面是它在 tsconfig.json 文件里面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;suppressExcessPropertyErrors&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小可选属性规则"><a href="#最小可选属性规则" class="headerlink" title="最小可选属性规则"></a>最小可选属性规则</h2><p>根据“结构类型”原则，如果一个对象的所有属性都是可选的，那么其他对象跟它都是结构类似的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">  a?:<span class="built_in">number</span>;</span><br><span class="line">  b?:<span class="built_in">number</span>;</span><br><span class="line">  c?:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Options</code>的所有属性都是可选的，所以它可以是一个空对象，也就意味着任意对象都满足<code>Options</code>的结构。</p>
<p>为了避免这种情况，TypeScript 2.4 引入了一个“最小可选属性规则”，也称为<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection">“弱类型检测”</a>（weak type detection）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">  a?:<span class="built_in">number</span>;</span><br><span class="line">  b?:<span class="built_in">number</span>;</span><br><span class="line">  c?:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">d</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = opts; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>opts</code>与类型<code>Options</code>没有共同属性，赋值给该类型的变量就会报错。</p>
<p>报错原因是，如果某个类型的所有属性都是可选的，那么该类型的对象必须至少存在一个可选属性，不能所有可选属性都不存在。这就叫做“最小可选属性规则”。</p>
<p>如果想规避这条规则，要么在类型里面增加一条索引属性（<code>[propName: string]: someType</code>），要么使用类型断言（<code>opts as Options</code>）。</p>
<h2 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h2><p>空对象是 TypeScript 的一种特殊值，也是一种特殊类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="number">123</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>obj</code>的值是一个空对象，然后对<code>obj.prop</code>赋值就会报错。</p>
<p>原因是这时 TypeScript 会推断变量<code>obj</code>的类型为空对象，实际执行的是下面的代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;&#125; = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>空对象没有自定义属性，所以对自定义属性赋值就会报错。空对象只能使用继承的属性，即继承自原型对象<code>Object.prototype</code>的属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">obj.<span class="title function_">toString</span>() <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>toString()</code>方法是一个继承自原型对象的方法，TypeScript 允许在空对象上使用。</p>
<p>回到本节开始的例子，这种写法其实在 JavaScript 很常见：先声明一个空对象，然后向空对象添加属性。但是，TypeScript 不允许动态添加属性，所以对象不能分步生成，必须生成时一次性声明所有属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;&#125;;</span><br><span class="line">pt.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">pt.<span class="property">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果确实需要分步声明，一个比较好的方法是，使用扩展运算符（<code>...</code>）合成一个新对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt0 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> pt1 = &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> pt2 = &#123; <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  ...pt0, ...pt1, ...pt2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>pt</code>是三个部分合成的，这样既可以分步声明，也符合 TypeScript 静态声明的要求。</p>
<p>空对象作为类型，其实是<code>Object</code>类型的简写形式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">d</span>:&#123;&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// let d:Object;</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;;</span><br><span class="line">d = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">d = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">d = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，各种类型的值（除了<code>null</code>和<code>undefined</code>）都可以赋值给空对象类型，跟<code>Object</code>类型的行为是一样的。</p>
<p>因为<code>Object</code>可以接受各种类型的值，而空对象是<code>Object</code>类型的简写，所以它不会有严格字面量检查，赋值时总是允许多余的属性，只是不能读取这些属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Empty</span> &#123; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">Empty</span> = &#123;<span class="attr">myProp</span>: <span class="number">1</span>, <span class="attr">anotherProp</span>: <span class="number">2</span>&#125;; <span class="comment">// 正确</span></span><br><span class="line">b.<span class="property">myProp</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>b</code>的类型是空对象，视同<code>Object</code>类型，不会有严格字面量检查，但是读取多余的属性会报错。</p>
<p>如果想强制使用没有任何属性的对象，可以采用下面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">WithoutProperties</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">never</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="title class_">WithoutProperties</span> = &#123; <span class="attr">prop</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的示例中，<code>[key: string]: never</code>表示字符串属性名是不存在的，因此其他对象进行赋值时就会报错。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 项目使用 npm 模块</title>
    <url>/2023/09/05/ts-npm/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>npm 模块都是 JavaScript 代码。即使模块是用 TypeScript 写的，还是必须编译成 JavaScript 再发布，保证模块可以在没有 TypeScript 的环境运行。</p>
<p>问题就来了，TypeScript 项目开发时，加载外部 npm 模块，如果拿不到该模块的类型信息，就会导致无法开发。所以，必须有一个方法，可以拿到模块的类型信息。</p>
<p>有些 npm 模块本身可能包含<code>.d.ts</code>文件甚至完整的 TypeScript 代码。它的<code>package.json</code>文件里面有一个<code>types</code>字段，指向一个<code>.d.ts</code>文件，这就是它的类型声明文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;left-pad&quot;</span>,</span><br><span class="line"> <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.3.0&quot;</span>,</span><br><span class="line"> <span class="string">&quot;description&quot;</span>: <span class="string">&quot;String left pad&quot;</span>,</span><br><span class="line"> <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line"> <span class="string">&quot;types&quot;</span>: <span class="string">&quot;index.d.ts&quot;</span>,</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个模块没有<code>.d.ts</code>文件，TypeScript 官方和社区就自发为常用模块添加类型描述，可以去<a href="https://www.typescriptlang.org/dt/search">官方网站</a>搜索，然后安装网站给出的 npm 类型模块，通常是<code>@types/[模块名]</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save lodash</span><br><span class="line">$ npm install --save @types/lodash</span><br></pre></td></tr></table></figure>

<p>lodash 的类型描述就是<code>@types/lodash</code>的文件<code>index.d.ts</code>。</p>
<h2 id="TS-模块转-npm-模块"><a href="#TS-模块转-npm-模块" class="headerlink" title="TS 模块转 npm 模块"></a>TS 模块转 npm 模块</h2><p>TS 代码放在<code>ts</code>子目录，编译出来的 CommonJS 代码放在<code>dist</code>子目录。</p>
<h2 id="如何写-TypeScript-模块"><a href="#如何写-TypeScript-模块" class="headerlink" title="如何写 TypeScript 模块"></a>如何写 TypeScript 模块</h2><p>首先，创建模块目录，然后在该目录里面新建一个<code>tsconfig.json</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2015&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&quot;declaration&quot;: true</code>：生成 .d.ts 文件，方便其他使用 TypeScript 的开发者加载你的库。</li>
<li><code>&quot;module&quot;: &quot;commonjs&quot;</code>：编译后的模块格式为<code>commonjs</code>，表示该模块供 Node.js 使用。如果供浏览器使用，则要写成<code>&quot;module&quot;: &quot;esnext&quot;</code>。</li>
<li><code>&quot;target&quot;: &quot;es2015&quot;</code>：生成的 JavaScript 代码版本为 ES2015，需要 Node.js 8 以上版本。</li>
<li><code>&quot;outDir&quot;: &quot;./dist&quot;</code>：编译后的文件放在<code>./dist</code>目录。</li>
<li><code>include</code>：指定需要编译的文件。</li>
</ul>
<p>然后，使用 TypeScript 编写仓库代码。可以在<code>src</code>子目录里面，编写一个入口文件<code>index.ts</code>。</p>
<p>最后，编写<code>package.json</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;hwrld&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Can log \&quot;hello world\&quot; and \&quot;goodbye world\&quot; to the console!&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;dist/index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;dist/index.d.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;/dist&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面的<code>&quot;types&quot;: &quot;dist/index.d.ts&quot;</code>字段指定类型声明文件，否则使用这个库的 TypeScript 开发者找不到类型声明文件。<code>files</code>属性指定打包进入 npm 模块的文件。</p>
<p>然后，就是编译和发布。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc</span><br><span class="line">$ npm publish</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.tsmean.com/articles/how-to-write-a-typescript-library/">How to Write a TypeScript Library</a>, by tsmean</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 类型运算符</title>
    <url>/2023/09/05/ts-operator/</url>
    <content><![CDATA[<div id="readmore-container"><p>TypeScript 提供强大的类型运算能力，可以使用各种类型运算符，对已有的类型进行计算，得到新类型。</p>
<h2 id="keyof-运算符"><a href="#keyof-运算符" class="headerlink" title="keyof 运算符"></a>keyof 运算符</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>keyof 是一个单目运算符，接受一个对象类型作为参数，返回该对象的所有键名组成的联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = keyof <span class="title class_">MyObj</span>; <span class="comment">// &#x27;foo&#x27;|&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>keyof MyObj</code>返回<code>MyObj</code>的所有键名组成的联合类型，即<code>&#39;foo&#39;|&#39;bar&#39;</code>。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">b</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof T; <span class="comment">// 0 | &#x27;a&#x27; | &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于 JavaScript 对象的键名只有三种类型，所以对于任意对象的键名的联合类型就是<code>string|number|symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string | number | symbol</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>对于没有自定义键名的类型使用 keyof 运算符，返回<code>never</code>类型，表示不可能有这样类型的键名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof <span class="built_in">object</span>;  <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，由于<code>object</code>类型没有自身的属性，也就没有键名，所以<code>keyof object</code>返回<code>never</code>类型。</p>
<p>由于 keyof 返回的类型是<code>string|number|symbol</code>，如果有些场合只需要其中的一种类型，那么可以采用交叉类型的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Capital</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="title class_">Capitalize</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyKeys</span>&lt;<span class="title class_">Obj</span> <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = <span class="title class_">Capital</span>&lt;keyof <span class="title class_">Obj</span>&gt;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Capital</code>只接受字符串作为类型参数，传入<code>keyof Obj</code>会报错，原因是这时的类型参数是<code>string|number|symbol</code>，跟字符串不兼容。采用下面的交叉类型写法，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyKeys</span>&lt;<span class="title class_">Obj</span> <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = <span class="title class_">Capital</span>&lt;<span class="built_in">string</span> &amp; keyof <span class="title class_">Obj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>string &amp; keyof Obj</code>等同于<code>string &amp; string|number|symbol</code>进行交集运算，最后返回<code>string</code>，因此<code>Capital&lt;T extends string&gt;</code>就不会报错了。</p>
<p>如果对象属性名采用索引形式，keyof 会返回属性名的索引类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string|number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof T;</span><br></pre></td></tr></table></figure>

<p>上面的示例二，<code>keyof T</code>返回的类型是<code>string|number</code>，原因是 JavaScript 属性名为字符串时，包含了属性名为数值的情况，因为数值属性名会自动转为字符串。</p>
<p>如果 keyof 运算符用于数组或元组类型，得到的结果可能出人意料。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = keyof [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// 返回 number | &quot;0&quot; | &quot;1&quot; | &quot;2&quot;</span></span><br><span class="line"><span class="comment">// | &quot;length&quot; | &quot;pop&quot; | &quot;push&quot; | ···</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，keyof 会返回数组的所有键名，包括数字键名和继承的键名。</p>
<p>对于联合类型，keyof 返回成员共有的键名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 &#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof (A | B);</span><br></pre></td></tr></table></figure>

<p>对于交叉类型，keyof 返回所有键名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">x</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 &#x27;a&#x27; | &#x27;x&#x27; | &#x27;b&#x27; | &#x27;y&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof (A &amp; B);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">keyof (A &amp; B) ≡ keyof A | keyof B</span><br></pre></td></tr></table></figure>

<p>keyof 取出的是键名组成的联合类型，如果想取出键值组成的联合类型，可以像下面这样写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = keyof <span class="title class_">MyObj</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Values</span> = <span class="title class_">MyObj</span>[<span class="title class_">Keys</span>]; <span class="comment">// number|string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Keys</code>是键名组成的联合类型，而<code>MyObj[Keys]</code>会取出每个键名对应的键值类型，组成一个新的联合类型，即<code>number|string</code>。</p>
<h3 id="keyof-运算符的用途"><a href="#keyof-运算符的用途" class="headerlink" title="keyof 运算符的用途"></a>keyof 运算符的用途</h3><p>keyof 运算符往往用于精确表达对象的属性类型。</p>
<p>举例来说，取出对象的某个指定属性的值，JavaScript 版本可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">prop</span>(<span class="params">obj, key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数添加类型，只能写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">prop</span>(<span class="params"></span></span><br><span class="line"><span class="params">  obj: &#123; [p:string]: any &#125;,</span></span><br><span class="line"><span class="params">  key: string</span></span><br><span class="line"><span class="params"></span>):any &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的类型声明有两个问题，一是无法表示参数<code>key</code>与参数<code>obj</code>之间的关系，二是返回值类型只能写成<code>any</code>。</p>
<p>有了 keyof 以后，就可以解决这两个问题，精确表达返回值类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> prop&lt;<span class="title class_">Obj</span>, K <span class="keyword">extends</span> keyof <span class="title class_">Obj</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>:<span class="title class_">Obj</span>, <span class="attr">key</span>:K</span><br><span class="line">):<span class="title class_">Obj</span>[K] &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>K extends keyof Obj</code>表示<code>K</code>是<code>Obj</code>的一个属性名，传入其他字符串会报错。返回值类型<code>Obj[K]</code>就表示<code>K</code>这个属性值的类型。</p>
<p>keyof 的另一个用途是用于属性映射，即将一个类型的所有属性逐一映射成其他值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NewProps</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123; <span class="attr">foo</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于 &#123; foo: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">NewProps</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>NewProps</code>是类型<code>Obj</code>的映射类型，前者继承了后者的所有属性，但是把所有属性值类型都改成了<code>boolean</code>。</p>
<p>下面的例子是去掉 readonly 修饰符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]: <span class="title class_">Obj</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于 &#123; foo: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">Mutable</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[Prop in keyof Obj]</code>是<code>Obj</code>类型的所有属性名，<code>-readonly</code>表示去除这些属性的只读特性。对应地，还有<code>+readonly</code>的写法，表示添加只读属性设置。</p>
<p>下面的例子是让可选属性变成必有的属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]-?: <span class="title class_">Obj</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  foo?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于 &#123; foo: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">Concrete</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[Prop in keyof Obj]</code>后面的<code>-?</code>表示去除可选属性设置。对应地，还有<code>+?</code>的写法，表示添加可选属性设置。</p>
<h2 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h2><p>JavaScript 语言中，<code>in</code>运算符用来确定对象是否包含某个属性名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> obj)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;found a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>in</code>运算符用来判断对象<code>obj</code>是否包含属性<code>a</code>。</p>
<p><code>in</code>运算符的左侧是一个字符串，表示属性名，右侧是一个对象。它的返回值是一个布尔值。</p>
<p>TypeScript 语言的类型运算中，<code>in</code>运算符有不同的用法，用来取出（遍历）联合类型的每一个成员类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> U = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> U]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[Prop in U]</code>表示依次取出联合类型<code>U</code>的每一个成员。</p>
<p>上一小节的例子也提到，<code>[Prop in keyof Obj]</code>表示取出对象<code>Obj</code>的每一个键名。</p>
<h2 id="方括号运算符"><a href="#方括号运算符" class="headerlink" title="方括号运算符"></a>方括号运算符</h2><p>方括号运算符（<code>[]</code>）用于取出对象的键值类型，比如<code>T[K]</code>会返回对象<code>T</code>的属性<code>K</code>的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">alive</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Age 的类型是 number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person[&#39;age&#39;]</code>返回属性<code>age</code>的类型，本例是<code>number</code>。</p>
<p>方括号的参数如果是联合类型，那么返回的也是联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">alive</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number|string</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Person</span>[<span class="string">&#x27;age&#x27;</span>|<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// number|string|boolean</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Person</span>[keyof <span class="title class_">Person</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，方括号里面是属性名的联合类型，所以返回的也是对应的属性值的联合类型。</p>
<p>如果访问不存在的属性，会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="title class_">Person</span>[<span class="string">&#x27;notExisted&#x27;</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>方括号运算符的参数也可以是属性名的索引类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>:<span class="built_in">string</span>]: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Obj</span>[<span class="built_in">string</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Obj</code>的属性名是字符串的索引类型，所以可以写成<code>Obj[string]</code>，代表所有字符串属性名，返回的就是它们的类型<code>number</code>。</p>
<p>这个语法对于数组也适用，可以使用<code>number</code>作为方括号的参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyArray 的类型是 &#123; [key:number]: string &#125;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyArray</span> = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 (typeof MyArray)[number]</span></span><br><span class="line"><span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>MyArray</code>是一个数组，它的类型实际上是属性名的数值索引，而<code>typeof MyArray[number]</code>的<code>typeof</code>运算优先级高于方括号，所以返回的是所有数值键名的键值类型<code>string</code>。</p>
<p>注意，方括号里面不能有值的运算。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key]; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;g&#x27;</span> + <span class="string">&#x27;e&#x27;</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面两个示例，方括号里面都涉及值的运算，编译时不会进行这种运算，所以会报错。</p>
<h2 id="extends…-条件运算符"><a href="#extends…-条件运算符" class="headerlink" title="extends…?: 条件运算符"></a>extends…?: 条件运算符</h2><p>TypeScript 提供类似 JavaScript 的<code>?:</code>运算符这样的三元运算符，但多出了一个<code>extends</code>关键字。</p>
<p>条件运算符<code>extends...?:</code>可以根据当前类型是否符合某种条件，返回不同的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>

<p>上面式子中的<code>extends</code>用来判断，类型<code>T</code>是否可以赋值给类型<code>U</code>，即<code>T</code>是否为<code>U</code>的子类型，这里的<code>T</code>和<code>U</code>可以是任意类型。</p>
<p>如果<code>T</code>能够赋值给类型<code>U</code>，表达式的结果为类型<code>X</code>，否则结果为类型<code>Y</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="number">1</span> <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>1</code>是<code>number</code>的子类型，所以返回<code>true</code>。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">live</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">woof</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">RegExp</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Dog</code>是<code>Animal</code>的子类型，所以<code>T1</code>的类型是<code>number</code>。<code>RegExp</code>不是<code>Animal</code>的子类型，所以<code>T2</code>的类型是<code>string</code>。</p>
<p>一般来说，调换<code>extends</code>两侧类型，会返回相反的结果。举例来说，有两个类<code>Cat</code>和<code>Animal</code>，前者是后者的子类型，那么<code>Cat extends Animal</code>就为真，而<code>Animal extends Cat</code>就为伪。</p>
<p>如果需要判断的类型是一个联合类型，那么条件运算符会展开这个联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(A|B) <span class="keyword">extends</span> U ? X : Y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">(A <span class="keyword">extends</span> U ? X : Y) |</span><br><span class="line">(B <span class="keyword">extends</span> U ? X : Y)</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A|B</code>是一个联合类型，进行条件运算时，相当于<code>A</code>和<code>B</code>分别进行运算符，返回结果组成一个联合类型。</p>
<p>如果不希望联合类型被条件运算符展开，可以把<code>extends</code>两侧的操作数都放在方括号里面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string[]|number[]</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  [<span class="title class_">Type</span>] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (string | number)[]</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面的示例一，传入<code>ToArray&lt;Type&gt;</code>的类型参数是一个联合类型，所以会被展开，返回的也是联合类型。示例二是<code>extends</code>两侧的运算数都放在方括号里面，所以传入的联合类型不会展开，返回的是一个数组。</p>
<p>条件运算符还可以嵌套使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LiteralTypeName</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">bigint</span> ? <span class="string">&quot;bigint&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">  <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例是一个多重判断，返回一个字符串的值类型，对应当前类型。下面是它的用法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result1</span> = <span class="title class_">LiteralTypeName</span>&lt;<span class="number">123n</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;string&quot; | &quot;number&quot; | &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result2</span> = <span class="title class_">LiteralTypeName</span>&lt;<span class="literal">true</span> | <span class="number">1</span> | <span class="string">&#x27;a&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="infer-关键字"><a href="#infer-关键字" class="headerlink" title="infer 关键字"></a>infer 关键字</h2><p><code>infer</code>关键字用来定义泛型里面推断出来的类型参数，而不是外部传入的类型参数。</p>
<p>它通常跟条件运算符一起使用，用在<code>extends</code>关键字后面的父类型之中。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>infer Item</code>表示<code>Item</code>这个参数是 TypeScript 自己推断出来的，不用显式传入，而<code>Flatten&lt;Type&gt;</code>则表示<code>Type</code>这个类型参数是外部传入的。<code>Type extends Array&lt;infer Item&gt;</code>则表示，如果参数<code>Type</code>是一个数组，那么就将该数组的成员类型推断为<code>Item</code>，即<code>Item</code>是从<code>Type</code>推断出来的。</p>
<p>一旦使用<code>Infer Item</code>定义了<code>Item</code>，后面的代码就可以直接调用<code>Item</code>了。下面是上例的泛型<code>Flatten&lt;Type&gt;</code>的用法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">string</span>[]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，第一个例子<code>Flatten&lt;string[]&gt;</code>传入的类型参数是<code>string[]</code>，可以推断出<code>Item</code>的类型是<code>string</code>，所以返回的是<code>string</code>。第二个例子<code>Flatten&lt;number&gt;</code>传入的类型参数是<code>number</code>，它不是数组，所以直接返回自身。</p>
<p>如果不用<code>infer</code>定义类型参数，那么就要传入两个类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>, <span class="title class_">Item</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure>

<p>上面是不使用<code>infer</code>的写法，每次调用<code>Fleatten</code>的时候，都要传入两个参数，就比较麻烦。</p>
<p>下面的例子使用<code>infer</code>，推断函数的参数类型和返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnPromise</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer A) =&gt; infer R </span><br><span class="line">  ? <span class="function">(<span class="params">...args: A</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;R&gt; </span><br><span class="line">  : T;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果<code>T</code>是函数，就返回这个函数的 Promise 版本，否则原样返回。<code>infer A</code>表示该函数的参数类型为<code>A</code>，<code>infer R</code>表示该函数的返回值类型为<code>R</code>。</p>
<p>如果不使用<code>infer</code>，就不得不把<code>ReturnPromise&lt;T&gt;</code>写成<code>ReturnPromise&lt;T, A, R&gt;</code>，这样就很麻烦，相当于开发者必须人肉推断编译器可以完成的工作。</p>
<p>下面是<code>infer</code>提取对象指定属性的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: infer M,</span><br><span class="line">    <span class="attr">b</span>: infer N</span><br><span class="line">  &#125; ? [M, N] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法示例</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">MyType</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span> &#125;&gt;;</span><br><span class="line"><span class="comment">// [string, number]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>infer</code>提取了参数对象的属性<code>a</code>和属性<code>b</code>的类型。</p>
<p>下面是<code>infer</code>通过正则匹配提取类型参数的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="string">&#x27;foo-bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Str</span> <span class="keyword">extends</span> <span class="string">`foo-<span class="subst">$&#123;infer rest&#125;</span>`</span> ? rest : <span class="built_in">never</span> <span class="comment">// &#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>rest</code>是从模板字符串提取的类型参数。</p>
<h2 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h2><p>函数返回布尔值的时候，可以使用<code>is</code>运算符，限定返回值与参数之间的关系。</p>
<p><code>is</code>运算符用来描述返回值属于<code>true</code>还是<code>false</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params"></span></span><br><span class="line"><span class="params">  pet: Fish|Bird</span></span><br><span class="line"><span class="params"></span>):pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isFish()</code>的返回值类型为<code>pet is Fish</code>，表示如果参数<code>pet</code>类型为<code>Fish</code>，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p><code>is</code>运算符总是用于描述函数的返回值类型，写法采用<code>parameterName is Type</code>的形式，即左侧为当前函数的参数名，右侧为某一种类型。它返回一个布尔值，表示左侧参数是否属于右侧的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isTypeA</span>(<span class="params">x: A|B</span>): x is A &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，返回值类型<code>x is A</code>可以准确描述函数体内部的运算逻辑。</p>
<p><code>is</code>运算符可以用于类型保护。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isCat</span>(<span class="params">a:<span class="built_in">any</span></span>): a is <span class="title class_">Cat</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">name</span> === <span class="string">&#x27;kitty&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="title class_">Cat</span>|<span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isCat</span>(x)) &#123;</span><br><span class="line">  x.<span class="title function_">meow</span>(); <span class="comment">// 正确，因为 x 肯定是 Cat 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isCat()</code>的返回类型是<code>a is Cat</code>，它是一个布尔值。后面的<code>if</code>语句就用这个返回值进行判断，从而起到类型保护的作用，确保<code>x</code>是 Cat 类型，从而<code>x.meow()</code>不会报错（假定<code>Cat</code>类型拥有<code>meow()</code>方法）。</p>
<p><code>is</code>运算符还有一种特殊用法，就是用在类（class）的内部，描述类的方法的返回值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="title function_">isStudent</span>():<span class="variable language_">this</span> is <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">isStudent</span>():<span class="variable language_">this</span> is <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>isStudent()</code>方法的返回值类型，取决于该方法内部的<code>this</code>是否为<code>Student</code>对象。如果是的，就返回布尔值<code>true</code>，否则返回<code>false</code>。</p>
<p>注意，<code>this is T</code>这种写法，只能用来描述方法的返回值类型，而不能用来描述属性的类型。</p>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>TypeScript 允许使用模板字符串，构建类型。</p>
<p>模板字符串的最大特点，就是内部可以引用其他类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Greeting</code>是一个模板字符串，里面引用了另一个字符串类型<code>world</code>，因此<code>Greeting</code>实际上是字符串<code>hello world</code>。</p>
<p>注意，模板字符串可以引用的类型一共6种，分别是 string、number、bigint、boolean、null、undefined。引用这6种以外的类型会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = &#123; n : <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="string">`<span class="subst">$&#123;Num&#125;</span> received`</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="string">`<span class="subst">$&#123;Obj&#125;</span> received`</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，模板字符串引用数值类型的别名<code>Num</code>是可以的，但是引用对象类型的别名<code>Obj</code>就会报错。</p>
<p>模板字符串里面引用的类型，如果是一个联合类型，那么它返回的也是一个联合类型，即模板字符串可以展开联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;A&#x27;</span>|<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;A_id&quot;|&quot;B_id&quot;</span></span><br><span class="line"><span class="keyword">type</span> U = <span class="string">`<span class="subst">$&#123;T&#125;</span>_id`</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>U</code>是一个模板字符串，里面引用了一个联合类型<code>T</code>，导致最后得到的也是一个联合类型。</p>
<p>如果模板字符串引用两个联合类型，它会交叉展开这两个类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;A&#x27;</span>|<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> U = <span class="string">&#x27;1&#x27;</span>|<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;A1&#x27;|&#x27;A2&#x27;|&#x27;B1&#x27;|&#x27;B2&#x27;</span></span><br><span class="line"><span class="keyword">type</span> V = <span class="string">`<span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>T</code>和<code>U</code>都是联合类型，各自有两个成员，模板字符串里面引用了这两个类型，最后得到的就是一个4个成员的联合类型。</p>
<h2 id="satisfies-运算符"><a href="#satisfies-运算符" class="headerlink" title="satisfies 运算符"></a>satisfies 运算符</h2><p><code>satisfies</code>运算符用来检测某个值是否符合指定类型。有时候，不方便将某个值指定为某种类型，但是希望这个值符合类型条件，这时候就可以用<code>satisfies</code>运算符对其进行检测。<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator">TypeScript 4.9</a>添加了这个运算符。</p>
<p>举例来说，有一个对象的属性名拼写错误。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> palette = &#123;</span><br><span class="line">  <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">  <span class="attr">bleu</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>] <span class="comment">// 属性名拼写错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>palette</code>的属性名拼写错了，将<code>blue</code>拼成了<code>bleu</code>，我们希望通过指定类型，发现这个错误。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Colors</span> = <span class="string">&quot;red&quot;</span> | <span class="string">&quot;green&quot;</span> | <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">RGB</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">palette</span>: <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span>|<span class="variable constant_">RGB</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">  <span class="attr">bleu</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>] <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>palette</code>的类型被指定为<code>Record&lt;Colors, string|RGB&gt;</code>，这是一个类型工具，用来返回一个对象，详细介绍见《类型工具》一章。简单说，它的第一个类型参数指定对象的属性名，第二个类型参数指定对象的属性值。</p>
<p>本例的<code>Record&lt;Colors, string|RGB&gt;</code>，就表示变量<code>palette</code>的属性名应该符合类型<code>Colors</code>，属性值应该符合类型<code>string|RGB</code>，要么是字符串，要么是元组<code>RGB</code>。属性名<code>bleu</code>不符合类型<code>Colors</code>，所以就报错了。</p>
<p>这样的写法，虽然可以发现属性名的拼写错误，但是带来了新的问题。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greenComponent = palette.<span class="property">green</span>.<span class="title function_">substring</span>(<span class="number">1</span>, <span class="number">6</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>palette.green</code>属性调用<code>substring()</code>方法会报错，原因是这个方法只有字符串才有，而<code>palette.green</code>的类型是<code>srting|RGB</code>，除了字符串，还可能是元组<code>RGB</code>，而元组并不存在<code>substring()</code>方法，所以报错了。</p>
<p>如果要避免报错，要么精确给出变量<code>palette</code>每个属性的类型，要么对<code>palette.green</code>的值进行类型缩小。两种做法都比较麻烦，也不是很有必要。</p>
<p>这时就可以使用<code>satisfies</code>运算符，对<code>palette</code>进行类型检测，但是不改变 TypeScript 对<code>palette</code>的类型推断。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Colors</span> = <span class="string">&quot;red&quot;</span> | <span class="string">&quot;green&quot;</span> | <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">RGB</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> palette = &#123;</span><br><span class="line">  <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">  <span class="attr">bleu</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>] <span class="comment">// 报错</span></span><br><span class="line">&#125; satisfies <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span>|<span class="variable constant_">RGB</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greenComponent = palette.<span class="property">green</span>.<span class="title function_">substring</span>(<span class="number">1</span>); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>palette</code>的值后面增加了<code>satisfies Record&lt;Colors, string|RGB&gt;</code>，表示该值必须满足<code>Record&lt;Colors, string|RGB&gt;</code>这个条件，所以能够检测出属性名<code>bleu</code>的拼写错误。同时，它不会改变<code>palette</code>的类型推断，所以，TypeScript 知道<code>palette.green</code>是一个字符串，对其调用<code>substring()</code>方法就不会报错。</p>
<p><code>satisfies</code>也可以检测属性值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> palette = &#123;</span><br><span class="line">  <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">  <span class="attr">blue</span>: [<span class="number">0</span>, <span class="number">0</span>] <span class="comment">// 报错</span></span><br><span class="line">&#125; satisfies <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span>|<span class="variable constant_">RGB</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>blue</code>的值只有两个成员，不符合元组<code>RGB</code>必须有三个成员的条件，从而报错了。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的 React 支持</title>
    <url>/2023/09/05/ts-react/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><p>JSX 是 React 库引入的一种语法，可以在 JavaScript 脚本中直接书写 HTML 风格的标签。</p>
<p>TypeScript 支持 JSX 语法，但是必须将脚本后缀名改成<code>.tsx</code>。</p>
<p><code>.tsx</code>文件中，类型断言一律使用<code>as</code>形式，因为尖括号的写法会与 JSX 冲突。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> x = foo <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用</span></span><br><span class="line"><span class="keyword">var</span> x = &lt;<span class="built_in">any</span>&gt;foo;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>被断言为类型<code>any</code>，在<code>.tsx</code>文件中只能使用第一种写法，不使用第二种写法。</p>
<h2 id="React-库"><a href="#React-库" class="headerlink" title="React 库"></a>React 库</h2><p>TypeScript 使用 React 库必须引入 React 的类型定义。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;react.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">Props</span>, &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">MyComponent</span> name=<span class="string">&quot;bar&quot;</span> /&gt;; <span class="comment">// OK</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">name</span>=<span class="string">&#123;0&#125;</span> /&gt;</span></span>; <span class="comment">// error, `name` is not a number</span></span><br></pre></td></tr></table></figure>

<h2 id="内置元素"><a href="#内置元素" class="headerlink" title="内置元素"></a>内置元素</h2><p>内置元素使用<code>JSX.IntrinsicElements</code>接口。默认情况下，内置元素不进行类型检查。但是，如果给出了接口定义，就会进行类型检查。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;foo /&gt;; <span class="comment">// ok</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bar</span> /&gt;</span></span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>&lt;bar /&gt;</code>不符合接口定义，所以报错。</p>
<p>一种解决办法就是，在接口中定义一个通用元素。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">    [<span class="attr">elemName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中， 元素名可以是任意字符串。</p>
<h2 id="组件的写法"><a href="#组件的写法" class="headerlink" title="组件的写法"></a>组件的写法</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FooProp</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">X</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">Y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">AnotherComponent</span>(<span class="params">prop: &#123; name: <span class="built_in">string</span> &#125;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentFoo</span>(<span class="params">prop: FooProp</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">AnotherComponent</span> <span class="attr">name</span>=<span class="string">&#123;prop.name&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">prop: &#123; value: <span class="built_in">string</span> &#125;, context: &#123; color: <span class="built_in">string</span> &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的 symbol 类型</title>
    <url>/2023/09/05/ts-symbol/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Symbol 是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个 Symbol 值都是独一无二的，与其他任何值都不相等。</p>
<p>Symbol 值通过<code>Symbol()</code>函数生成。在 TypeScript 里面，Symbol 的类型使用<code>symbol</code>表示。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">x === y <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>和<code>y</code>的类型都是<code>symbol</code>，且都用<code>Symbol()</code>生成，但是它们是不相等的。</p>
<h2 id="unique-symbol"><a href="#unique-symbol" class="headerlink" title="unique symbol"></a>unique symbol</h2><p><code>symbol</code>类型包含所有的 Symbol 值，但是无法表示某一个具体的 Symbol 值。</p>
<p>比如，<code>5</code>是一个具体的数值，就用<code>5</code>这个字面量来表示，这也是它的值类型。但是，Symbol 值不存在字面量，必须通过变量来引用，所以写不出只包含单个 Symbol 值的那种值类型。</p>
<p>为了解决这个问题，TypeScript 设计了<code>symbol</code>的一个子类型<code>unique symbol</code>，它表示单个的、某个具体的 Symbol 值。</p>
<p>因为<code>unique symbol</code>表示单个值，所以这个类型的变量是不能修改值的，只能用<code>const</code>命令声明，不能用<code>let</code>声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>let</code>命令声明的变量，不能是<code>unique symbol</code>类型，会报错。</p>
<p><code>const</code>命令为变量赋值 Symbol 值时，变量类型默认就是<code>unique symbol</code>，所以类型可以省略不写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>每个声明为<code>unique symbol</code>类型的变量，它们的值都是不一样的，其实属于两个值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型虽然都是<code>unique symbol</code>，但其实是两个值类型。不同类型的值肯定是不相等的，所以最后一行就报错了。</p>
<p>由于 Symbol 类似于字符串，可以参考下面的例子来理解。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="string">&#x27;hello&#x27;</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="string">&#x27;world&#x27;</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>b</code>都是字符串，但是属于不同的值类型，不能使用严格相等运算符进行比较。</p>
<p>而且，由于变量<code>a</code>和<code>b</code>是两个类型，就不能把一个赋值给另一个。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:unique <span class="built_in">symbol</span> = a; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型都是<code>unique symbol</code>，但是其实类型不同，所以把<code>a</code>赋值给<code>b</code>会报错。</p>
<p>上例变量<code>b</code>的类型，如果要写成与变量<code>a</code>同一个<code>unique symbol</code>值类型，只能写成类型为<code>typeof a</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="keyword">typeof</span> a = a; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>不过我们知道，相同参数的<code>Symbol.for()</code>方法会返回相同的 Symbol 值。TypeScript 目前无法识别这种情况，所以可能出现多个 unique symbol 类型的变量，等于同一个 Symbol 值的情况。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>b</code>是两个不同的值类型，但是它们的值其实是相等的。</p>
<p>unique symbol 类型是 symbol 类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="built_in">symbol</span> = a; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:unique <span class="built_in">symbol</span> = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，unique symbol 类型（变量<code>a</code>）赋值给 symbol 类型（变量<code>b</code>）是可以的，但是 symbol 类型（变量<code>b</code>）赋值给 unique symbol 类型（变量<code>c</code>）会报错。</p>
<p>unique symbol 类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。如果要把某一个特定的 Symbol 值当作属性名，那么它的类型只能是 unique symbol，不能是 symbol。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  [x]: <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br><span class="line">  [y]: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>y</code>当作属性名，但是<code>y</code>的类型是 symbol，不是固定不变的值，导致报错。</p>
<p><code>unique symbol</code>类型也可以用作类（class）的属性值，但只能赋值给类的<code>readonly static</code>属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="attr">foo</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态只读属性<code>foo</code>的类型就是<code>unique symbol</code>。注意，这时<code>static</code>和<code>readonly</code>两个限定符缺一不可，这是为了保证这个属性是固定不变的。</p>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>如果变量声明时没有给出类型，TypeScript 会推断某个 Symbol 值变量的类型。</p>
<p><code>let</code>命令声明的变量，推断类型为 symbol。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型为 symbol</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p><code>const</code>命令声明的变量，推断类型为 unique symbol。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型为 unique symbol</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>但是，<code>const</code>命令声明的变量，如果赋值为另一个 symbol 类型的变量，则推断类型为 symbol。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为 symbol</span></span><br><span class="line"><span class="keyword">const</span> y = x;</span><br></pre></td></tr></table></figure>

<p><code>let</code>命令声明的变量，如果赋值为另一个 unique symbol 类型的变量，则推断类型还是 symbol。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为 symbol</span></span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>tsc 命令行编译器</title>
    <url>/2023/09/05/ts-tsc/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>tsc 是 TypeScript 官方的命令行编译器，用来检查代码，并将其编译成 JavaScript 代码。</p>
<p>tsc 默认使用当前目录下的配置文件<code>tsconfig.json</code>，但也可以接受独立的命令行参数。命令行参数会覆盖<code>tsconfig.json</code>，比如命令行指定了所要编译的文件，那么 tsc 就会忽略<code>tsconfig.json</code>的<code>files</code>属性。</p>
<p>tsc 的基本用法如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 tsconfig.json 的配置</span></span><br><span class="line">$ tsc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只编译 index.ts</span></span><br><span class="line">$ tsc index.ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 src 目录的所有 .ts 文件</span></span><br><span class="line">$ tsc src/*.ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译配置文件</span></span><br><span class="line">$ tsc --project tsconfig.production.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只生成类型声明文件，不编译出 JS 文件</span></span><br><span class="line">$ tsc index.js --declaration --emitDeclarationOnly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个 TS 文件编译成单个 JS 文件</span></span><br><span class="line">$ tsc app.ts util.ts --target esnext --outfile index.js</span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>tsc 的命令行参数，大部分与 tsconfig.json 的属性一一对应。</p>
<p>下面只是按照首字母排序，简单罗列出主要的一些参数，详细解释可以参考《tsconfig.json 配置文件》一章。</p>
<p><code>--all</code>：输出所有可用的参数。</p>
<p><code>--allowJs</code>：允许 TS 脚本加载 JS 模块，编译时将 JS 一起拷贝到输出目录。</p>
<p><code>--allowUnreachableCode</code>：如果 TS 脚本有不可能运行到的代码，不报错。</p>
<p><code>--allowUnusedLabels</code>：如果 TS 脚本有没有用到的标签，不报错。</p>
<p><code>--alwaysStrict</code>：总是在编译产物的头部添加<code>use strict</code>。</p>
<p><code>--baseUrl</code>：指定非相对位置的模块定位的基准 URL。</p>
<p><code>--build</code>：启用增量编译。</p>
<p><code>--checkJs</code>：对 JS 脚本进行类型检查。</p>
<p><code>--declaration</code>：为 TS 脚本生成一个类型生成文件。</p>
<p><code>--declarationDir</code>：指定生成的类型声明文件的所在目录。</p>
<p><code>--declarationMap</code>：为<code>.d.ts</code>文件生成 SourceMap 文件。</p>
<p><code>--diagnostics</code>：构建后输出编译性能信息。</p>
<p><code>--emitBOM</code>：在编译输出的 UTF-8 文件头部加上 BOM 标志。</p>
<p><code>--emitDeclarationOnly</code>：只编译输出类型声明文件，不输出 JS 文件。</p>
<p><code>--esModuleInterop</code>：更容易使用 import 命令加载 CommonJS 模块。</p>
<p><code>--exactOptionalPropertyTypes</code>：不允许将可选属性设置为<code>undefined</code>。</p>
<p><code>--experimentalDecorators</code>：支持早期的装饰器语法。</p>
<p><code>--explainFiles</code>：输出进行编译的文件信息。</p>
<p><code>--forceConsistentCasingInFileNames</code>：文件名大小写敏感，默认打开。</p>
<p><code>--help</code>：输出帮助信息。</p>
<p><code>--importHelpers</code>：从外部库（比如 tslib）输入辅助函数。</p>
<p><code>--incremental</code>：启用增量构建。</p>
<p><code>--init</code>：在当前目录创建一个全新的<code>tsconfig.json</code>文件，里面是预设的设置。</p>
<p><code>--inlineSourceMap</code>：SourceMap 信息嵌入 JS 文件，而不是生成独立的<code>.js.map</code>文件。</p>
<p><code>--inlineSources</code>：将 TypeScript 源码作为 SourceMap 嵌入编译出来的 JS 文件。</p>
<p><code>--isolatedModules</code>：确保每个模块能够独立编译，不依赖其他输入的模块。</p>
<p><code>--jsx</code>：设置如何处理 JSX 文件。</p>
<p><code>--lib</code>：设置目标环境需要哪些内置库的类型描述。</p>
<p><code>--listEmittedFiles</code>：编译后输出编译产物的文件名。</p>
<p><code>--listFiles</code>：编译过程中，列出读取的文件名。</p>
<p><code>--listFilesOnly</code>：列出编译所要处理的文件，然后停止编译。</p>
<p><code>--locale</code>：指定编译时输出的语言，不影响编译结果。</p>
<p><code>--mapRoot</code>：指定 SourceMap 文件的位置。</p>
<p><code>--module</code>：指定编译生成的模块格式。</p>
<p><code>--moduleResolution</code>：指定如何根据模块名找到模块的位置。</p>
<p><code>--moduleSuffixes</code>：指定模块文件的后缀名。</p>
<p><code>--newLine</code>：指定编译产物的换行符，可以设为<code>crlf</code>或者<code>lf</code>。</p>
<p><code>--noEmit</code>：不生成编译产物，只进行类型检查。</p>
<p><code>--noEmitHelpers</code>：不在编译产物中加入辅助函数。</p>
<p><code>--noEmitOnError</code>：一旦报错，就停止编译，没有编译产物。</p>
<p><code>--noFallthroughCasesInSwitch</code>：Switch 结构的<code>case</code>分支必须有终止语句（比如<code>break</code>）。</p>
<p><code>--noImplicitAny</code>：类型推断只要为<code>any</code>类型就报错。</p>
<p><code>--noImplicitReturns</code>：函数内部没有显式返回语句（比如<code>return</code>）就报错。</p>
<p><code>--noImplicitThis</code>：如果<code>this</code>关键字是<code>any</code>类型，就报错。</p>
<p><code>--noImplicitUseStrict</code>：编译产生的 JS 文件头部不添加<code>use strict</code>语句。</p>
<p><code>--noResolve</code>：不进行模块定位，除非该模块是由命令行传入。</p>
<p><code>--noUnusedLocals</code>：如果有未使用的局部变量就报错。</p>
<p><code>--noUnusedParameters</code>：如果有未使用的函数参数就报错。</p>
<p><code>--outDir</code>：指定编译产物的存放目录。</p>
<p><code>--outFile</code>：所有编译产物打包成一个指定文件。</p>
<p><code>--preserveConstEnums</code>：不将<code>const enum</code>结构在生成的代码中，替换成常量。</p>
<p><code>--preserveWatchOutput</code>： watch 模式下不清屏。</p>
<p><code>--pretty</code>：美化显示编译时的终端输出。这是默认值，但是可以关闭<code>--pretty false</code>。</p>
<p><code>--project</code>（或者<code>-p</code>）：指定编译配置文件，或者该文件所在的目录。</p>
<p><code>--removeComments</code>：编译结果中移除代码注释。</p>
<p><code>--resolveJsonModule</code>：允许加载 JSON 文件。</p>
<p><code>--rootDir</code>：指定加载文件所在的根目录，该目录里面的目录结构会被复制到输出目录。</p>
<p><code>--rootDirs</code>：允许模块定位时，多个目录被当成一个虚拟目录。</p>
<p><code>--skipDefaultLibCheck</code>：跳过 TypeScript 内置类型声明文件的类型检查。</p>
<p><code>--skipLibCheck</code>：跳过<code>.d.ts</code>类型声明文件的类型检查。这样可以加快编译速度。</p>
<p><code>--showConfig</code>：终端输出编译配置信息，而不进行配置。</p>
<p><code>--sourcemap</code>：为编译产生的 JS 文件生成 SourceMap 文件（.map 文件）。</p>
<p><code>--sourceRoot</code>：指定 SourceMap 文件里面的 TypeScript 源码根目录位置。</p>
<p><code>--strict</code>：打开 TypeScript 严格检查模式。</p>
<p><code>--strictBindCallApply</code>：bind, call、apply 这三个函数的类型，匹配原始函数。</p>
<p><code>--strictFunctionTypes</code>：如果函数 B 的参数是函数 A 参数的子类型，那么函数 B 不能替代函数 A。</p>
<p><code>--strictNullChecks</code>：对<code>null</code>和<code>undefined</code>进行严格类型检查。</p>
<p><code>--strictPropertyInitialization</code>：类的属性必须进行初始值，但是允许在构造函数里面赋值。</p>
<p><code>--suppressExcessPropertyErrors</code>：关闭对象字面量的多余参数的报错。</p>
<p><code>--target</code>：指定编译出来的 JS 代码的版本，TypeScript 还会在编译时自动加入对应的库类型声明文件。</p>
<p><code>--traceResolution</code>：编译时在终端输出模块解析（moduleResolution）的具体步骤。</p>
<p><code>--typeRoots</code>：设置类型模块所在的目录，替代默认的<code>node_modules/@types</code>。</p>
<p><code>--types</code>：设置<code>typeRoots</code>目录下需要包括在编译之中的类型模块。</p>
<p><code>--version</code>：终端输出 tsc 的版本号。</p>
<p><code>--watch</code>（或者<code>-w</code>）：进入观察模式，只要文件有修改，就会自动重新编译。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的元组类型</title>
    <url>/2023/09/05/ts-tuple/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。</p>
<p>由于成员的类型可以不一样，所以元组必须明确声明每个成员的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s</span>:[<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>]</span><br><span class="line">  = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组<code>s</code>的前两个成员的类型是<code>string</code>，最后一个成员的类型是<code>boolean</code>。</p>
<p>元组类型的写法，与上一章的数组有一个重大差异。数组的成员类型写在方括号外面（<code>number[]</code>），元组的成员类型是写在方括号里面（<code>[number]</code>）。TypeScript 的区分方法就是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">t</span>:[<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>t</code>的值都是<code>[1]</code>，但是它们的类型是不一样的。<code>a</code>是一个数组，成员类型<code>number</code>写在方括号外面；<code>t</code>是一个元组，成员类型<code>number</code>写在方括号里面。</p>
<p>使用元组时，必须明确给出类型声明（上例的<code>[number]</code>），不能省略，否则 TypeScript 会把一个值自动推断为数组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a 的类型被推断为 (number | boolean)[]</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>的值其实是一个元组，但是 TypeScript 会将其推断为一个联合类型的数组，即<code>a</code>的类型为<code>(number | boolean)[]</code>。所以，元组必须显式给出类型声明。</p>
<p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:[<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组<code>a</code>的第二个成员是可选的，可以省略。</p>
<p>注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myTuple = [</span><br><span class="line">  <span class="built_in">number</span>,</span><br><span class="line">  <span class="built_in">number</span>,</span><br><span class="line">  <span class="built_in">number</span>?,</span><br><span class="line">  <span class="built_in">string</span>?</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组<code>myTuple</code>的最后两个成员是可选的。也就是说，它的成员数量可能有两个、三个和四个。</p>
<p>由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:[<span class="built_in">string</span>, <span class="built_in">string</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line">x[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>是一个只有两个成员的元组，如果对第三个成员赋值就报错了。</p>
<p>但是，使用扩展运算符（<code>...</code>），可以表示不限成员数量的元组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NamedNums</span> = [</span><br><span class="line">  <span class="built_in">string</span>,</span><br><span class="line">  ...<span class="built_in">number</span>[]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="title class_">NamedNums</span> = [<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">NamedNums</span> = [<span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组类型<code>NamedNums</code>的第一个成员是字符串，后面的成员使用扩展运算符来展开一个数组，从而实现了不定数量的成员。</p>
<p>扩展运算符（<code>...</code>）用在元组的任意位置都可以，它的后面只能是一个数组或元组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];</span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t3 = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，扩展运算符分别在元组的尾部、中部和头部，<code>...</code>的后面是一个数组<code>boolean[]</code>。</p>
<p>如果不确定元组成员的类型和数量，可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [...<span class="built_in">any</span>[]];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组<code>Tuple</code>可以放置任意数量和类型的成员。但是这样写，也就失去了使用元组和 TypeScript 的意义。</p>
<p>元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = [</span><br><span class="line">  <span class="attr">red</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">green</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">blue</span>: <span class="built_in">number</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:<span class="title class_">Color</span> = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Color</code>是一个元组，它有三个成员。每个成员都有一个名字，写在具体类型的前面，使用冒号分隔。这几个名字可以随便取，没有实际作用，只是用来说明每个成员的含义。</p>
<p>元组可以通过方括号，读取成员类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Tuple</span>[<span class="number">1</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Tuple[1]</code>返回1号位置的成员类型。</p>
<p>由于元组的成员都是数值索引，即索引类型都是<code>number</code>，所以可以像下面这样读取。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="title class_">Date</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TupleEl</span> = <span class="title class_">Tuple</span>[<span class="built_in">number</span>];  <span class="comment">// string|number|Date</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Tuple[number]</code>表示元组<code>Tuple</code>的所有数值索引的成员类型，所以返回<code>string|number|Date</code>，即这个类型是三种值的联合类型。</p>
<h2 id="只读元组"><a href="#只读元组" class="headerlink" title="只读元组"></a>只读元组</h2><p>元组也可以是只读的，不允许修改，有两种写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">type</span> t = <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">string</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">type</span> t = <span class="title class_">Readonly</span>&lt;[<span class="built_in">number</span>, <span class="built_in">string</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种写法都可以得到只读元组，其中写法二是一个泛型，用到了工具类型<code>Readonly&lt;T&gt;</code>。</p>
<p>跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而只读元组不能替代元组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:t2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:t1 = x; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>t1</code>是只读元组，类型<code>t2</code>是普通元组。<code>t2</code>类型可以赋值给<code>t1</code>类型，反过来就会报错。</p>
<p>由于只读元组不能替代元组，所以会产生一些令人困惑的报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distanceFromOrigin</span>(<span class="params">[x, y]:[<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(x**<span class="number">2</span> + y**<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point = [<span class="number">3</span>, <span class="number">4</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">distanceFromOrigin</span>(point); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>distanceFromOrigin()</code>的参数是一个元组，传入只读元组就会报错，因为只读元组不能替代元组。</p>
<p>读者可能注意到了，上例中<code>[3, 4] as const</code>的写法，在上一章讲到，生成的是只读数组，其实生成的同时也是只读元组。因为它生成的实际上是一个只读的“值类型”<code>readonly [3, 4]</code>，把它解读成只读数组或只读元组都可以。</p>
<p>上面示例报错的解决方法，就是使用类型断言，在最后一行将传入的参数断言为普通元组，详见《类型断言》一章。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">distanceFromOrigin</span>(</span><br><span class="line">  point <span class="keyword">as</span> [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="成员数量的推断"><a href="#成员数量的推断" class="headerlink" title="成员数量的推断"></a>成员数量的推断</h2><p>如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">point: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (point.<span class="property">length</span> === <span class="number">3</span>) &#123;  <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例会报错，原因是 TypeScript 发现元组<code>point</code>的长度是<code>2</code>，不可能等于<code>3</code>，这个判断无意义。</p>
<p>如果包含了可选成员，TypeScript 会推断出可能的成员数量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span></span><br><span class="line"><span class="params">  point:[<span class="built_in">number</span>, <span class="built_in">number</span>?, <span class="built_in">number</span>?]</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (point.<span class="property">length</span> === <span class="number">4</span>) &#123;  <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例会报错，原因是 TypeScript 发现<code>point.length</code>的类型是<code>1|2|3</code>，不可能等于<code>4</code>。</p>
<p>如果使用了扩展运算符，TypeScript 就无法推断出成员数量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">myTuple</span>:[...<span class="built_in">string</span>[]]</span><br><span class="line">  = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myTuple.<span class="property">length</span> === <span class="number">4</span>) &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>myTuple</code>只有三个成员，但是 TypeScript 推断不出它的成员数量，因为它的类型用到了扩展运算符，TypeScript 把<code>myTuple</code>当成数组看待，而数组的成员数量是不确定的。</p>
<p>一旦扩展运算符使得元组的成员数量无法推断，TypeScript 内部就会把该元组当成数组处理。</p>
<h2 id="扩展运算符与成员数量"><a href="#扩展运算符与成员数量" class="headerlink" title="扩展运算符与成员数量"></a>扩展运算符与成员数量</h2><p>扩展运算符（<code>...</code>）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。</p>
<p>这导致如果函数调用时，使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(...arr) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例会报错，原因是函数<code>add()</code>只能接受两个参数，但是传入的是<code>...arr</code>，TypeScript 认为转换后的参数个数是不确定的。</p>
<p>有些函数可以接受任意数量的参数，这时使用扩展运算符就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>console.log()</code>可以接受任意数量的参数，所以传入<code>...arr</code>就不会报错。</p>
<p>解决这个问题的一个方法，就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:[<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(...arr) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>arr</code>是一个拥有两个成员的元组，所以 TypeScript 能够确定<code>...arr</code>可以匹配函数<code>add()</code>的参数数量，就不会报错了。</p>
<p>另一种写法是使用<code>as const</code>断言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<p>上面这种写法也可以，因为 TypeScript 会认为<code>arr</code>的类型是<code>readonly [1, 2]</code>，这是一个只读的值类型，可以当作数组，也可以当作元组。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>tsconfig.json</title>
    <url>/2023/09/05/ts-tsconfig.json/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>tsconfig.json</code>是 TypeScript 项目的配置文件，放在项目的根目录。反过来说，如果一个目录里面有<code>tsconfig.json</code>，TypeScript 就认为这是项目的根目录。</p>
<p>如果项目源码是 JavaScript，但是想用 TypeScript 处理，那么配置文件的名字是<code>jsconfig.json</code>，它跟<code>tsconfig</code>的写法是一样的。</p>
<p><code>tsconfig.json</code>文件主要供<code>tsc</code>编译器使用，它的命令行参数<code>--project</code>或<code>-p</code>可以指定<code>tsconfig.json</code>的位置（目录或文件皆可）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc -p ./dir</span><br></pre></td></tr></table></figure>

<p>如果不指定配置文件的位置，<code>tsc</code>就会在当前目录下搜索<code>tsconfig.json</code>文件，如果不存在，就到上一级目录搜索，直到找到为止。</p>
<p><code>tsconfig.json</code>文件的格式，是一个 JSON 对象，最简单的情况可以只放置一个空对象<code>&#123;&#125;</code>。下面是一个示例。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./built&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./src/**/*&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>本章后面会详细介绍<code>tsconfig.json</code>的各个属性，这里简单说一下，上面示例的四个属性的含义。</p>
<ul>
<li>include：指定哪些文件需要编译。</li>
<li>allowJs：指定源目录的 JavaScript 文件是否原样拷贝到编译后的目录。</li>
<li>outDir：指定编译产物存放的目录。</li>
<li>target：指定编译产物的 JS 版本。</li>
</ul>
<p><code>tsconfig.json</code>文件可以不必手写，使用 tsc 命令的<code>--init</code>参数自动生成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc --init</span><br></pre></td></tr></table></figure>

<p>上面命令生成的<code>tsconfig.json</code>文件，里面会有一些默认配置。</p>
<p>你也可以使用别人预先写好的 tsconfig.json 文件，npm 的<code>@tsconfig</code>名称空间下面有很多模块，都是写好的<code>tsconfig.json</code>样本，比如 <code>@tsconfig/recommended</code>和<code>@tsconfig/node16</code>。</p>
<p>这些模块需要安装，以<code>@tsconfig/deno</code>为例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @tsconfig/deno</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ yarn add --dev @tsconfig/deno</span><br></pre></td></tr></table></figure>

<p>安装以后，就可以在<code>tsconfig.json</code>里面引用这个模块，相当于继承它的设置，然后进行扩展。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@tsconfig/deno/tsconfig.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>@tsconfig</code>空间下包含的完整 tsconfig 文件目录，可以查看 <a href="https://github.com/tsconfig/bases/tree/main/bases">GitHub</a>。</p>
<p><code>tsconfig.json</code>的一级属性并不多，只有很少几个，但是<code>compilerOptions</code>属性有很多二级属性。下面先逐一介绍一级属性，然后再介绍<code>compilerOptions</code>的二级属性，按照首字母排序。</p>
<h2 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h2><p><code>exclude</code>属性是一个数组，必须与<code>include</code>属性一起使用，用来从编译列表中去除指定的文件。它也支持使用与<code>include</code>属性相同的通配符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;**/*&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;**/*.spec.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p><code>tsconfig.json</code>可以继承另一个<code>tsconfig.json</code>文件的配置。如果一个项目有多个配置，可以把共同的配置写成<code>tsconfig.base.json</code>，其他的配置文件继承该文件，这样便于维护和修改。</p>
<p><code>extends</code>属性用来指定所要继承的配置文件。它可以是本地文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../tsconfig.base.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>extends</code>属性指定的路径不是以<code>./</code>或<code>../</code>开头，那么编译器将在<code>node_modules</code>目录下查找指定的配置文件。</p>
<p><code>extends</code>属性也可以继承已发布的 npm 模块里面的 tsconfig 文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@tsconfig/node12/tsconfig.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>extends</code>指定的<code>tsconfig.json</code>会先加载，然后加载当前的<code>tsconfig.json</code>。如果两者有重名的属性，后者会覆盖前者。</p>
<h2 id="files"><a href="#files" class="headerlink" title="files"></a>files</h2><p><code>files</code>属性指定编译的文件列表，如果其中有一个文件不存在，就会报错。</p>
<p>它是一个数组，排在前面的文件先编译。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [<span class="string">&quot;a.ts&quot;</span>, <span class="string">&quot;b.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该属性必须逐一列出文件，不支持文件匹配。如果文件较多，建议使用<code>include</code>和<code>exclude</code>属性。</p>
<h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p><code>include</code>属性指定所要编译的文件列表，既支持逐一列出文件，也支持通配符。文件位置相对于当前配置文件而定。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;src/**/*&quot;</span>, <span class="string">&quot;tests/**/*&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>include</code>属性支持三种通配符。</p>
<ul>
<li><code>?</code>：指代单个字符</li>
<li><code>*</code>：指代任意字符，不含路径分隔符</li>
<li><code>**</code>：指定任意目录层级。</li>
</ul>
<p>如果不指定文件后缀名，默认包括<code>.ts</code>、<code>.tsx</code>和<code>.d.ts</code>文件。如果打开了<code>allowJs</code>，那么还包括<code>.js</code>和<code>.jsx</code>。</p>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><code>references</code>属性是一个数组，数组成员为对象，适合一个大项目由许多小项目构成的情况，用来设置需要引用的底层项目。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;references&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;path&quot;</span>: <span class="string">&quot;../pkg1&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;path&quot;</span>: <span class="string">&quot;../pkg2/tsconfig.json&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>references</code>数组成员对象的<code>path</code>属性，既可以是含有文件<code>tsconfig.json</code>的目录，也可以直接是该文件。</p>
<p>与此同时，引用的底层项目的<code>tsconfig.json</code>必须启用<code>composite</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;composite&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="compileOptions"><a href="#compileOptions" class="headerlink" title="compileOptions"></a>compileOptions</h2><p><code>compilerOptions</code>属性用来定制编译行为。这个属性可以省略，这时编译器将使用默认设置。</p>
<h3 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h3><p><code>allowJs</code>允许 TypeScript 项目加载 JS 脚本。编译时，也会将 JS 文件，一起拷贝到输出目录。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a>alwaysStrict</h3><p><code>alwaysStrict</code>确保脚本以 ECMAScript 严格模式进行解析，因此脚本头部不用写<code>&quot;use strict&quot;</code>。它的值是一个布尔值，默认为<code>true</code>。</p>
<h3 id="allowSyntheticDefaultImports"><a href="#allowSyntheticDefaultImports" class="headerlink" title="allowSyntheticDefaultImports"></a>allowSyntheticDefaultImports</h3><p><code>allowSyntheticDefaultImports</code>允许<code>import</code>命令默认加载没有<code>default</code>输出的模块。</p>
<p>比如，打开这个设置，就可以写<code>import React from &quot;react&quot;;</code>，而不是<code>import * as React from &quot;react&quot;;</code>。</p>
<h3 id="allowUnreachableCode"><a href="#allowUnreachableCode" class="headerlink" title="allowUnreachableCode"></a>allowUnreachableCode</h3><p><code>allowUnreachableCode</code>设置是否允许存在不可能执行到的代码。它的值有三种可能。</p>
<ul>
<li><code>undefined</code>： 默认值，编辑器显示警告。</li>
<li><code>true</code>：忽略不可能执行到的代码。</li>
<li><code>false</code>：编译器报错。</li>
</ul>
<h3 id="allowUnusedLabels"><a href="#allowUnusedLabels" class="headerlink" title="allowUnusedLabels"></a>allowUnusedLabels</h3><p><code>allowUnusedLabels</code>设置是否允许存在没有用到的代码标签（label）。它的值有三种可能。</p>
<ul>
<li><code>undefined</code>： 默认值，编辑器显示警告。</li>
<li><code>true</code>：忽略没有用到的代码标签。</li>
<li><code>false</code>：编译器报错。</li>
</ul>
<h3 id="baseUrl"><a href="#baseUrl" class="headerlink" title="baseUrl"></a>baseUrl</h3><p><code>baseUrl</code>的值为字符串，指定 TypeScript 项目的基准目录。</p>
<p>由于默认是以 tsconfig.json 的位置作为基准目录，所以一般情况不需要使用该属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>baseUrl</code>为当前目录<code>./</code>。那么，当遇到下面的语句，TypeScript 将以<code>./</code>为起点，寻找<code>hello/world.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; helloWorld &#125; <span class="keyword">from</span> <span class="string">&quot;hello/world&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="checkJs"><a href="#checkJs" class="headerlink" title="checkJs"></a>checkJs</h3><p><code>checkJS</code>设置对 JS 文件同样进行类型检查。打开这个属性，也会自动打开<code>allowJs</code>。它等同于在 JS 脚本的头部添加<code>// @ts-check</code>命令。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="composite"><a href="#composite" class="headerlink" title="composite"></a>composite</h3><p><code>composite</code>打开某些设置，使得 TypeScript 项目可以进行增量构建，往往跟<code>incremental</code>属性配合使用。</p>
<h3 id="declaration"><a href="#declaration" class="headerlink" title="declaration"></a>declaration</h3><p><code>declaration</code>设置编译时是否为每个脚本生成类型声明文件<code>.d.ts</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="declarationDir"><a href="#declarationDir" class="headerlink" title="declarationDir"></a>declarationDir</h3><p><code>declarationDir</code>设置生成的<code>.d.ts</code>文件所在的目录。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;declarationDir&quot;</span>: <span class="string">&quot;./types&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="declarationMap"><a href="#declarationMap" class="headerlink" title="declarationMap"></a>declarationMap</h3><p><code>declarationMap</code>设置生成<code>.d.ts</code>类型声明文件的同时，还会生成对应的 Source Map 文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;declarationMap&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emitBOM"><a href="#emitBOM" class="headerlink" title="emitBOM"></a>emitBOM</h3><p><code>emitBOM</code>设置是否在编译结果的文件头添加字节顺序标志 BOM，默认值是<code>false</code>。</p>
<h3 id="emitDeclarationOnly"><a href="#emitDeclarationOnly" class="headerlink" title="emitDeclarationOnly"></a>emitDeclarationOnly</h3><p><code>emitDeclarationOnly</code>设置编译后只生成<code>.d.ts</code>文件，不生成<code>.js</code>文件。</p>
<h3 id="esModuleInterop"><a href="#esModuleInterop" class="headerlink" title="esModuleInterop"></a>esModuleInterop</h3><p><code>esModuleInterop</code>修复了一些 CommonJS 和 ES6 模块之间的兼容性问题。</p>
<p>如果<code>module</code>属性为<code>node16</code>或<code>nodenext</code>，则<code>esModuleInterop</code>默认为<code>true</code>，其他情况默认为<code>false</code>。</p>
<p>打开这个属性，使用<code>import</code>命令加载 CommonJS 模块时，TypeScript 会严格检查兼容性问题是否存在。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span></span><br><span class="line"><span class="title function_">moment</span>(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，根据 ES6 规范，<code>import * as moment</code>里面的<code>moment</code>是一个对象，不能当作函数调用，所以第二行报错了。</p>
<p>解决方法就是改写上面的语句，改成加载默认接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span></span><br><span class="line"><span class="title function_">moment</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>打开<code>esModuleInterop</code>以后，如果将上面的代码编译成 CommonJS 模块格式，就会加入一些辅助函数，保证编译后的代码行为正确。</p>
<p>注意，打开<code>esModuleInterop</code>，将自动打开<code>allowSyntheticDefaultImports</code>。</p>
<h3 id="exactOptionalPropertyTypes"><a href="#exactOptionalPropertyTypes" class="headerlink" title="exactOptionalPropertyTypes"></a>exactOptionalPropertyTypes</h3><p><code>exactOptionalPropertyTypes</code>设置可选属性不能赋值为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开 exactOptionalPropertyTypes</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  foo?: <span class="string">&#x27;A&#x27;</span> | <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">foo</span>: <span class="string">&#x27;A&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span> = <span class="literal">undefined</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>foo</code>是可选属性，打开<code>exactOptionalPropertyTypes</code>以后，该属性就不能显式赋值为<code>undefined</code>。</p>
<h3 id="forceConsistentCasingInFileNames"><a href="#forceConsistentCasingInFileNames" class="headerlink" title="forceConsistentCasingInFileNames"></a>forceConsistentCasingInFileNames</h3><p><code>forceConsistentCasingInFileNames</code>设置文件名是否为大小写敏感，默认为<code>true</code>。</p>
<h3 id="incremental"><a href="#incremental" class="headerlink" title="incremental"></a>incremental</h3><p><code>incremental</code>让 TypeScript 项目构建时产生文件<code>tsbuildinfo</code>，从而完成增量构建。</p>
<h3 id="inlineSourceMap"><a href="#inlineSourceMap" class="headerlink" title="inlineSourceMap"></a>inlineSourceMap</h3><p><code>inlineSourceMap</code>设置将 SourceMap 文件写入编译后的 JS 文件中，否则会单独生成一个<code>.js.map</code>文件。</p>
<h3 id="inlineSources"><a href="#inlineSources" class="headerlink" title="inlineSources"></a>inlineSources</h3><p><code>inlineSources</code>设置将原始的<code>.ts</code>代码嵌入编译后的 JS 中。</p>
<p>它要求<code>sourceMap</code>或<code>inlineSourceMap</code>至少打开一个。</p>
<h3 id="isolatedModules"><a href="#isolatedModules" class="headerlink" title="isolatedModules"></a>isolatedModules</h3><p><code>isolatedModules</code>设置如果当前 TypeScript 脚本作为单个模块编译，是否会因为缺少其他脚本的类型信息而报错，主要便于非官方的编译工具（比如 Babel）正确编译单个脚本。</p>
<h3 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h3><p><code>jsx</code>设置如何处理<code>.tsx</code>文件。它可以取以下五个值。</p>
<ul>
<li><code>preserve</code>：保持 jsx 语法不变，输出的文件名为<code>.jsx</code>。</li>
<li><code>react</code>：将<code>&lt;div /&gt;</code>编译成<code>React.createElement(&quot;div&quot;)</code>，输出的文件名为<code>.js</code>。</li>
<li><code>react-native</code>：保持 jsx 语法不变，输出的文件后缀名为<code>.js</code>。</li>
<li><code>react-jsx</code>：将<code>&lt;div /&gt;</code>编译成<code>_jsx(&quot;div&quot;)</code>，输出的文件名为<code>.js</code>。</li>
<li><code>react-jsxdev</code>：跟<code>react-jsx</code>类似，但是为<code>_jsx()</code>加上更多的开发调试项，输出的文件名为<code>.js</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p><code>lib</code>值是一个数组，描述项目需要加载的 TypeScript 内置类型描述文件，跟三斜线指令<code>/// &lt;reference lib=&quot;&quot; /&gt;</code>作用相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;dom&quot;</span>, <span class="string">&quot;es2021&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 内置的类型描述文件，主要有以下一些，完整的清单可以参考 <a href="https://github.com/microsoft/TypeScript/tree/main/src/lib">TypeScript 源码</a>。</p>
<ul>
<li>ES5</li>
<li>ES2015</li>
<li>ES6</li>
<li>ES2016</li>
<li>ES7</li>
<li>ES2017</li>
<li>ES2018</li>
<li>ES2019</li>
<li>ES2020</li>
<li>ES2021</li>
<li>ES2022</li>
<li>ESNext</li>
<li>DOM</li>
<li>WebWorker</li>
<li>ScriptHost</li>
</ul>
<h3 id="listEmittedFiles"><a href="#listEmittedFiles" class="headerlink" title="listEmittedFiles"></a>listEmittedFiles</h3><p><code>listEmittedFiles</code>设置编译时在终端显示，生成了哪些文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;listEmittedFiles&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listFiles"><a href="#listFiles" class="headerlink" title="listFiles"></a>listFiles</h3><p><code>listFiles</code>设置编译时在终端显示，参与本次编译的文件列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;listFiles&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mapRoot"><a href="#mapRoot" class="headerlink" title="mapRoot"></a>mapRoot</h3><p><code>mapRoot</code>指定 SourceMap 文件的位置，而不是默认的生成位置。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;mapRoot&quot;</span>: <span class="string">&quot;https://my-website.com/debug/sourcemaps/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p><code>module</code>指定编译产物的模块格式。它的默认值与<code>target</code>属性有关，如果<code>target</code>是<code>ES3</code>或<code>ES5</code>，它的默认值是<code>commonjs</code>，否则就是<code>ES6/ES2015</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>它可以取以下值：none、commonjs、amd、umd、system、es6&#x2F;es2015、es2020、es2022、esnext、node16、nodenext。</p>
<h3 id="moduleResolution"><a href="#moduleResolution" class="headerlink" title="moduleResolution"></a>moduleResolution</h3><p><code>moduleResolution</code>确定模块路径的算法，即如何查找模块。它可以取以下四种值。</p>
<ul>
<li><code>node</code>：采用 Node.js 的 CommonJS 模块算法。</li>
<li><code>node16</code>或<code>nodenext</code>：采用 Node.js 的 ECMAScript 模块算法，从 TypeScript 4.7 开始支持。</li>
<li><code>classic</code>：TypeScript 1.6 之前的算法，新项目不建议使用。</li>
<li><code>bundler</code>：TypeScript 5.0 新增的选项，表示当前代码会被其他打包器（比如 Webpack、Vite、esbuild、Parcel、rollup、swc）处理，从而放宽加载规则，它要求<code>module</code>设为<code>es2015</code>或更高版本，详见加入该功能的 <a href="https://github.com/microsoft/TypeScript/pull/51669">PR 说明</a>。</li>
</ul>
<p>它的默认值与<code>module</code>属性有关，如果<code>module</code>为<code>AMD</code>、<code>UMD</code>、<code>System</code>或<code>ES6/ES2015</code>，默认值为<code>classic</code>；如果<code>module</code>为<code>node16</code>或<code>nodenext</code>，默认值为这两个值；其他情况下,默认值为<code>Node</code>。</p>
<h3 id="moduleSuffixes"><a href="#moduleSuffixes" class="headerlink" title="moduleSuffixes"></a>moduleSuffixes</h3><p><code>moduleSuffixes</code>指定模块的后缀名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;moduleSuffixes&quot;</span>: [<span class="string">&quot;.ios&quot;</span>, <span class="string">&quot;.native&quot;</span>, <span class="string">&quot;&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的设置使得 TypeScript 对于语句<code>import * as foo from &quot;./foo&quot;;</code>，会搜索以下脚本<code>./foo.ios.ts</code>、<code>./foo.native.ts</code>和<code>./foo.ts</code>。</p>
<h3 id="newLine"><a href="#newLine" class="headerlink" title="newLine"></a>newLine</h3><p><code>newLine</code>设置换行符为<code>CRLF</code>（Windows）还是<code>LF</code>（Linux）。</p>
<h3 id="noEmit"><a href="#noEmit" class="headerlink" title="noEmit"></a>noEmit</h3><p><code>noEmit</code>设置是否产生编译结果。如果不生成，TypeScript 编译就纯粹作为类型检查了。</p>
<h3 id="noEmitHelpers"><a href="#noEmitHelpers" class="headerlink" title="noEmitHelpers"></a>noEmitHelpers</h3><p><code>noEmitHelpers</code>设置在编译结果文件不插入 TypeScript 辅助函数，而是通过外部引入辅助函数来解决，比如 NPM 模块<code>tslib</code>。</p>
<h3 id="noEmitOnError"><a href="#noEmitOnError" class="headerlink" title="noEmitOnError"></a>noEmitOnError</h3><p><code>noEmitOnError</code>指定一旦编译报错，就不生成编译产物，默认为<code>false</code>。</p>
<h3 id="noFallthroughCasesInSwitch"><a href="#noFallthroughCasesInSwitch" class="headerlink" title="noFallthroughCasesInSwitch"></a>noFallthroughCasesInSwitch</h3><p><code>noFallthroughCasesInSwitch</code>设置是否对没有<code>break</code>语句（或者<code>return</code>和<code>throw</code>语句）的 switch 分支报错，即<code>case</code>代码里面必须有终结语句（比如<code>break</code>）。</p>
<h3 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h3><p><code>noImplicitAny</code>设置当一个表达式没有明确的类型描述、且编译器无法推断出具体类型时，是否允许将它推断为<code>any</code>类型。</p>
<p>它是一个布尔值，默认为<code>true</code>，即只要推断出<code>any</code>类型就报错。</p>
<h3 id="noImplicitReturns"><a href="#noImplicitReturns" class="headerlink" title="noImplicitReturns"></a>noImplicitReturns</h3><p><code>noImplicitReturns</code>设置是否要求函数任何情况下都必须返回一个值，即函数必须有<code>return</code>语句。</p>
<h3 id="noImplicitThis"><a href="#noImplicitThis" class="headerlink" title="noImplicitThis"></a>noImplicitThis</h3><p><code>noImplicitThis</code>设置如果<code>this</code>被推断为<code>any</code>类型是否报错。</p>
<h3 id="noUnusedLocals"><a href="#noUnusedLocals" class="headerlink" title="noUnusedLocals"></a>noUnusedLocals</h3><p><code>noUnusedLocals</code>设置是否允许未使用的局部变量。</p>
<h3 id="noUnusedParameters"><a href="#noUnusedParameters" class="headerlink" title="noUnusedParameters"></a>noUnusedParameters</h3><p><code>noUnusedParameters</code>设置是否允许未使用的函数参数。</p>
<h3 id="outDir"><a href="#outDir" class="headerlink" title="outDir"></a>outDir</h3><p><code>outDir</code>指定编译产物的存放目录。如果不指定，编译出来的<code>.js</code>文件存放在对应的<code>.ts</code>文件的相同位置。</p>
<h3 id="outFile"><a href="#outFile" class="headerlink" title="outFile"></a>outFile</h3><p><code>outFile</code>设置将所有非模块的全局文件，编译在同一个文件里面。它只有在<code>module</code>属性为<code>None</code>、<code>System</code>、<code>AMD</code>时才生效，并且不能用来打包 CommonJS 或 ES6 模块。</p>
<h3 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h3><p><code>paths</code>设置模块名和模块路径的映射，也就是 TypeScript 如何导入<code>require</code>或<code>imports</code>语句加载的模块。</p>
<p><code>paths</code>基于<code>baseUrl</code>进行加载，所以必须同时设置后者。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;b&quot;</span>: [<span class="string">&quot;bar/b&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它还可以使用通配符“*”。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@bar/*&quot;</span>: [<span class="string">&quot;bar/*&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preserveConstEnums"><a href="#preserveConstEnums" class="headerlink" title="preserveConstEnums"></a>preserveConstEnums</h3><p><code>preserveConstEnums</code>将<code>const enum</code>结构保留下来，不替换成常量值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;preserveConstEnums&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pretty"><a href="#pretty" class="headerlink" title="pretty"></a>pretty</h3><p><code>pretty</code>设置美化输出终端的编译信息，默认为<code>true</code>。</p>
<h3 id="removeComments"><a href="#removeComments" class="headerlink" title="removeComments"></a>removeComments</h3><p><code>removeComments</code>移除 TypeScript 脚本里面的注释，默认为<code>false</code>。</p>
<h3 id="resolveJsonModule"><a href="#resolveJsonModule" class="headerlink" title="resolveJsonModule"></a>resolveJsonModule</h3><p><code>resolveJsonModule</code>允许 import 命令导入 JSON 文件。</p>
<h3 id="rootDir"><a href="#rootDir" class="headerlink" title="rootDir"></a>rootDir</h3><p><code>rootDir</code>设置源码脚本所在的目录，主要跟编译后的脚本结构有关。<code>rootDir</code>对应目录下的所有脚本，会成为输出目录里面的顶层脚本。</p>
<h3 id="rootDirs"><a href="#rootDirs" class="headerlink" title="rootDirs"></a>rootDirs</h3><p><code>rootDirs</code>把多个不同目录，合并成一个目虚拟目录，便于模块定位。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;rootDirs&quot;</span>: [<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;foo&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>rootDirs</code>将<code>bar</code>和<code>foo</code>组成一个虚拟目录。</p>
<h3 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h3><p><code>sourceMap</code>设置编译时是否生成 SourceMap 文件。</p>
<h3 id="sourceRoot"><a href="#sourceRoot" class="headerlink" title="sourceRoot"></a>sourceRoot</h3><p><code>sourceRoot</code>在 SourceMap 里面设置 TypeScript 源文件的位置。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;sourceRoot&quot;</span>: <span class="string">&quot;https://my-website.com/debug/source/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h3><p><code>strict</code>用来打开 TypeScript 的严格检查。它的值是一个布尔值，默认是关闭的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设置相当于同时打开以下的一系列设置。</p>
<ul>
<li>alwaysStrict</li>
<li>strictNullChecks</li>
<li>strictBindCallApply</li>
<li>strictFunctionTypes</li>
<li>strictPropertyInitialization</li>
<li>noImplicitAny</li>
<li>noImplicitThis</li>
<li>useUnknownInCatchVaria</li>
</ul>
<p>打开<code>strict</code>的时候，允许单独关闭其中一项。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="strictBindCallApply"><a href="#strictBindCallApply" class="headerlink" title="strictBindCallApply"></a>strictBindCallApply</h3><p><code>strictBindCallApply</code>设置是否对函数的<code>call()</code>、<code>bind()</code>、<code>apply()</code>这三个方法进行类型检查。</p>
<p>如果不打开<code>strictBindCallApply</code>编译选项，编译器不会对以上三个方法进行类型检查，参数类型都是<code>any</code>，传入任何参数都不会产生编译错误。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strictBindCallApply:false</span></span><br><span class="line"><span class="keyword">const</span> n = fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 以上不报错</span></span><br></pre></td></tr></table></figure>

<h3 id="strictFunctionTypes"><a href="#strictFunctionTypes" class="headerlink" title="strictFunctionTypes"></a>strictFunctionTypes</h3><p><code>strictFunctionTypes</code>允许对函数更严格的参数检查。具体来说，如果函数 B 的参数是函数 A 参数的子类型，那么函数 B 不能替代函数 A。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + x.<span class="title function_">toLowerCase</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumberFunc</span> = <span class="function">(<span class="params">ns:<span class="built_in">string</span>|<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开 strictFunctionTypes，下面代码会报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func</span>:<span class="title class_">StringOrNumberFunc</span> = fn;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fn()</code>的参数是<code>StringOrNumberFunc</code>参数的子集，因此<code>fn</code>不能替代<code>StringOrNumberFunc</code>。</p>
<h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h3><p><code>strictNullChecks</code>设置对<code>null</code>和<code>undefined</code>进行严格类型检查。如果打开<code>strict</code>属性，这一项就会自动设为<code>true</code>，否则为<code>false</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> value:string;</span><br><span class="line"></span><br><span class="line">// strictNullChecks:<span class="literal">false</span></span><br><span class="line">// 下面语句不报错</span><br><span class="line">value = null;</span><br></pre></td></tr></table></figure>

<p>它可以理解成只要打开，就需要显式检查<code>null</code>或<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">x:<span class="built_in">string</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + x.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strictPropertyInitialization"><a href="#strictPropertyInitialization" class="headerlink" title="strictPropertyInitialization"></a>strictPropertyInitialization</h3><p><code>strictPropertyInitialization</code>设置类的实例属性都必须初始化，包括以下几种情况。</p>
<ul>
<li>设为<code>undefined</code>类型</li>
<li>显式初始化</li>
<li>构造函数中赋值</li>
</ul>
<p>注意，使用该属性的同时，必须打开<code>strictNullChecks</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// strictPropertyInitialization：true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="comment">// 报错，属性 username 没有初始化</span></span><br><span class="line">  <span class="attr">username</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  username = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">username</span>:<span class="built_in">string</span>|<span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法三</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">username</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">username:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">username</span> = username;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> username:<span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法四：赋值断言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  username!:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">username:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initialize</span>(username);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">initialize</span>(<span class="params">username:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">username</span> = username;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="suppressExcessPropertyErrors"><a href="#suppressExcessPropertyErrors" class="headerlink" title="suppressExcessPropertyErrors"></a>suppressExcessPropertyErrors</h3><p><code>suppressExcessPropertyErrors</code>关闭对象字面量的多余参数的报错。</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p><code>target</code>指定编译出来的 JavaScript 代码的 ECMAScript 版本，比如<code>es2021</code>，默认是<code>es3</code>。</p>
<p>它可以取以下值。</p>
<ul>
<li>es3</li>
<li>es5</li>
<li>es6&#x2F;es2015</li>
<li>es2016</li>
<li>es2017</li>
<li>es2018</li>
<li>es2019</li>
<li>es2020</li>
<li>es2021</li>
<li>es2022</li>
<li>esnext</li>
</ul>
<p>注意，如果编译的目标版本过老，比如<code>&quot;target&quot;: &quot;es3&quot;</code>，有些语法可能无法编译，<code>tsc</code>命令会报错。</p>
<h3 id="traceResolution"><a href="#traceResolution" class="headerlink" title="traceResolution"></a>traceResolution</h3><p><code>traceResolution</code>设置编译时，在终端输出模块解析的具体步骤。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;traceResolution&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeRoots"><a href="#typeRoots" class="headerlink" title="typeRoots"></a>typeRoots</h3><p><code>typeRoots</code>设置类型模块所在的目录，默认是<code>node_modules/@types</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [<span class="string">&quot;./typings&quot;</span>, <span class="string">&quot;./vendor/types&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><p><code>types</code>设置<code>typeRoots</code>目录下需要包括在编译之中的类型模块。默认情况下，该目录下的所有类型模块，都会自动包括在编译之中。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;types&quot;</span>: [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;jest&quot;</span>, <span class="string">&quot;express&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useUnknownInCatchVariables"><a href="#useUnknownInCatchVariables" class="headerlink" title="useUnknownInCatchVariables"></a>useUnknownInCatchVariables</h3><p><code>useUnknownInCatchVariables</code>设置<code>catch</code>语句捕获的<code>try</code>抛出的返回值类型，从<code>any</code>变成<code>unknown</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">someExternalFunction</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  err; <span class="comment">// 类型 any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，默认情况下，<code>catch</code>语句的参数<code>err</code>类型是<code>any</code>，即可以是任何值。</p>
<p>打开<code>useUnknownInCatchVariables</code>以后，<code>err</code>的类型抛出的错误将是<code>unknown</code>类型。这带来的变化就是使用<code>err</code>之前，必须缩小它的类型，否则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">someExternalFunction</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://mariusschulz.com/blog/strict-property-initialization-in-typescript">Strict Property Initialization in TypeScript</a>, Marius Schulz</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>类型运算</title>
    <url>/2023/09/05/ts-type-operations/</url>
    <content><![CDATA[<div id="readmore-container"><h2 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h2><p>改变成员类型的顺序不影响联合类型的结果类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>对部分类型成员使用分组运算符不影响联合类型的结果类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = (<span class="built_in">boolean</span> | <span class="built_in">string</span>) | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">boolean</span> | (<span class="built_in">string</span> | <span class="built_in">number</span>);</span><br></pre></td></tr></table></figure>

<p>联合类型的成员类型可以进行化简。假设有联合类型“U &#x3D; T0 | T1”，如果T1是T0的子类型，那么可以将类型成员T1从联合类型U中消去。最后，联合类型U的结果类型为“U &#x3D; T0”。例如，有联合类型“boolean | true | false”。其中，true类型和false类型是boolean类型的子类型，因此可以将true类型和false类型从联合类型中消去。最终，联合类型“boolean | true | false”的结果类型为boolean类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="built_in">boolean</span> | <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以T0等同于 T1</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">boolean</span>;</span><br></pre></td></tr></table></figure>

<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>&amp;</code>的优先级高于<code>|</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">A &amp; B | C &amp; D</span><br><span class="line"><span class="comment">// 该类型等同于如下类型：</span></span><br><span class="line">(A &amp; B) | (C &amp; D)</span><br></pre></td></tr></table></figure>

<p>分配律</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">A &amp; (B | C) </span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">(A &amp; B) | (A &amp; C)</span><br></pre></td></tr></table></figure>

<p>一个稍微复杂的类型等式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(A | B) &amp; (C | D) ≡ A &amp; C | A &amp; D | B &amp; C | B &amp; D</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">T = (<span class="built_in">string</span> | <span class="number">0</span>) &amp; (<span class="built_in">number</span> | <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">T = (<span class="built_in">string</span> &amp; <span class="built_in">number</span>) | (<span class="built_in">string</span> &amp; <span class="string">&#x27;a&#x27;</span>) | (<span class="number">0</span> &amp; <span class="built_in">number</span>) | (<span class="number">0</span> &amp; <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">T = <span class="built_in">never</span> | <span class="string">&#x27;a&#x27;</span> | <span class="number">0</span> | <span class="built_in">never</span>;</span><br><span class="line">T = <span class="string">&#x27;a&#x27;</span> | <span class="number">0</span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> extend&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U): T &amp; U &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  for (let id in first) &#123;</span><br><span class="line">    (&lt;T&gt;result)[id] = first[id];</span><br><span class="line">  &#125;</span><br><span class="line">  for (let id in second) &#123;</span><br><span class="line">    if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;U&gt;result)[id] = second[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x = extend(&#123; a: &#x27;hello&#x27; &#125;, &#123; b: 42 &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><p>never 可以视为空集。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NeverIntersection</span> = <span class="built_in">never</span> &amp; <span class="built_in">string</span>; <span class="comment">// Type: never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NeverUnion</span> = <span class="built_in">never</span> | <span class="built_in">string</span>; <span class="comment">// Type: string</span></span><br></pre></td></tr></table></figure>

<p>很适合在交叉类型中用作过滤。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OnlyStrings</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? T : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RedOrBlue</span> = <span class="title class_">OnlyStrings</span>&lt;<span class="string">&quot;red&quot;</span> | <span class="string">&quot;blue&quot;</span> | <span class="number">0</span> | <span class="literal">false</span>&gt;;</span><br><span class="line"><span class="comment">// Equivalent to: &quot;red&quot; | &quot;blue&quot;</span></span><br></pre></td></tr></table></figure>

<p>范例：<a href="https://www.typescriptlang.org/play#example/conditional-types">https://www.typescriptlang.org/play#example/conditional-types</a></p>
<h2 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a>unknown 类型</h2><p>在联合类型中，unknown吸收所有类型。这意味着如果任何组成类型是unknown，则联合类型的计算结果为unknown。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In an intersection everything absorbs unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T00</span> = <span class="built_in">unknown</span> &amp; <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T01</span> = <span class="built_in">unknown</span> &amp; <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T02</span> = <span class="built_in">unknown</span> &amp; <span class="literal">null</span> &amp; <span class="literal">undefined</span>; <span class="comment">// null &amp; undefined (which becomes never)</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T03</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">string</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T04</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">string</span>[]; <span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T05</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">unknown</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T06</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">any</span>; <span class="comment">// any</span></span><br><span class="line"><span class="comment">// In a union an unknown absorbs everything</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T10</span> = <span class="built_in">unknown</span> | <span class="literal">null</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T11</span> = <span class="built_in">unknown</span> | <span class="literal">undefined</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T12</span> = <span class="built_in">unknown</span> | <span class="literal">null</span> | <span class="literal">undefined</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T13</span> = <span class="built_in">unknown</span> | <span class="built_in">string</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T14</span> = <span class="built_in">unknown</span> | <span class="built_in">string</span>[]; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T15</span> = <span class="built_in">unknown</span> | <span class="built_in">unknown</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T16</span> = <span class="built_in">unknown</span> | <span class="built_in">any</span>; <span class="comment">// any</span></span><br><span class="line"><span class="comment">// Type variable and unknown in union and intersection</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T20</span>&lt;T&gt; = T &amp; &#123;&#125;; <span class="comment">// T &amp; &#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T21</span>&lt;T&gt; = T | &#123;&#125;; <span class="comment">// T | &#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T22</span>&lt;T&gt; = T &amp; <span class="built_in">unknown</span>; <span class="comment">// T</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T23</span>&lt;T&gt; = T | <span class="built_in">unknown</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="comment">// unknown in conditional types</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T30</span>&lt;T&gt; = <span class="built_in">unknown</span> <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// Deferred</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T31</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">unknown</span> ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// Deferred (so it distributes)</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T32</span>&lt;T&gt; = <span class="built_in">never</span> <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T33</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">never</span> ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// Deferred</span></span><br></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType1</span> = <span class="built_in">unknown</span> | <span class="literal">null</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType2</span> = <span class="built_in">unknown</span> | <span class="literal">undefined</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType3</span> = <span class="built_in">unknown</span> | <span class="built_in">string</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType4</span> = <span class="built_in">unknown</span> | <span class="built_in">number</span>[]; <span class="comment">// unknown</span></span><br></pre></td></tr></table></figure>

<p>该规则的一个例外是any。如果至少有一种构成类型是any，则联合类型的计算结果为any：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType5</span> = <span class="built_in">unknown</span> | <span class="built_in">any</span>; <span class="comment">// any</span></span><br></pre></td></tr></table></figure>

<p>在交叉类型中，每种类型都吸收unknown. 这意味着与任何类型相交unknown不会改变结果类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType1</span> = <span class="built_in">unknown</span> &amp; <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType2</span> = <span class="built_in">unknown</span> &amp; <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType3</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">string</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType4</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">number</span>[]; <span class="comment">// number[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType5</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">any</span>; <span class="comment">// any</span></span><br></pre></td></tr></table></figure>

<p>除非使用<code>as</code>断言，首先缩小类型<code>unknown</code>类型的范围，然后才可以用于其他类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">value</span>: <span class="built_in">unknown</span> = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">someString</span>: <span class="built_in">string</span> = value <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">const</span> otherString = someString.<span class="title function_">toUpperCase</span>(); <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>如果类型是多个值的联合，甚至可以产生插值的效果。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EmailLocaleIDs</span> = <span class="string">&quot;welcome_email&quot;</span> | <span class="string">&quot;email_heading&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooterLocaleIDs</span> = <span class="string">&quot;footer_title&quot;</span> | <span class="string">&quot;footer_sendoff&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 type AllLocaleIDs = &quot;welcome_email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AllLocaleIDs</span> = <span class="string">`<span class="subst">$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;</span>_id`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Brightness</span> = <span class="string">&quot;dark&quot;</span> | <span class="string">&quot;light&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&quot;blue&quot;</span> | <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BrightnessAndColor</span> = <span class="string">`<span class="subst">$&#123;Brightness&#125;</span>-<span class="subst">$&#123;Color&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// Equivalent to: &quot;dark-red&quot; | &quot;light-red&quot; | &quot;dark-blue&quot; | &quot;light-blue&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果交叉类型中存在多个相同的成员类型，那么相同的成员类型将被合并为单一成员类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">boolean</span> &amp; <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="built_in">boolean</span> &amp; <span class="built_in">boolean</span> &amp; <span class="built_in">boolean</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，T0、T1和T2都表示同一种类型boolean。</p>
<p>改变成员类型的顺序不影响交叉类型的结果类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">    <span class="title function_">click</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Focusable</span> &#123;</span><br><span class="line">    <span class="title function_">focus</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Clickable</span> &amp; <span class="title class_">Focusable</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Focusable</span> &amp; <span class="title class_">Clickable</span>;</span><br></pre></td></tr></table></figure>
<p>注意，当交叉类型涉及调用签名重载或构造签名重载时便失去了“加法交换律”的性质。因为交叉类型中成员类型的顺序将决定重载签名的顺序，进而将影响重载签名的解析顺序。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">    <span class="title function_">register</span>(<span class="attr">x</span>: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Focusable</span> &#123;</span><br><span class="line">    <span class="title function_">register</span>(<span class="attr">x</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClickableAndFocusable</span> = <span class="title class_">Clickable</span> &amp; <span class="title class_">Focusable</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FocusableAndFocusable</span> = <span class="title class_">Focusable</span> &amp; <span class="title class_">Clickable</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span></span><br><span class="line"><span class="params">    clickFocus: ClickableAndFocusable,</span></span><br><span class="line"><span class="params">    focusClick: FocusableAndFocusable</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">void</span> = clickFocus.<span class="title function_">register</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">boolean</span> = focusClick.<span class="title function_">register</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例第8行和第9行使用不同的成员类型顺序定义了两个交叉类型。第15行，调用“register()”方法的返回值类型为void，说明在ClickableAndFocusable类型中，Clickable接口中定义的“register()”方法具有更高的优先级。第16行，调用“register()”方法的返回值类型为boolean，说明FocusableAndFocusable类型中Focusable接口中定义的“register()”方法具有更高的优先级。此例也说明了调用签名重载的顺序与交叉类型中成员类型的定义顺序是一致的。</p>
<p>对部分类型成员使用分组运算符不影响交叉类型的结果类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">  <span class="title function_">click</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Focusable</span> &#123;</span><br><span class="line">  <span class="title function_">focus</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Scrollable</span> &#123;</span><br><span class="line">  <span class="title function_">scroll</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = (<span class="title class_">Clickable</span> &amp; <span class="title class_">Focusable</span>) &amp; <span class="title class_">Scrollable</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Clickable</span> &amp; (<span class="title class_">Focusable</span> &amp; <span class="title class_">Scrollable</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例的T0和T1类型是同一种类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Combined</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span> &#125; &amp; &#123; <span class="attr">b</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Conflicting</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span> &#125; &amp; &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>只要交叉类型I中任意一个成员类型包含了属性签名M，那么交叉类型I也包含属性签名M。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交叉类型如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若交叉类型的属性签名M在所有成员类型中都是可选属性，那么该属性签名在交叉类型中也是可选属性。否则，属性签名M是一个必选属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    y?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    x?: <span class="built_in">boolean</span>;</span><br><span class="line">    y?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交叉类型如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    y?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 的类型系统</title>
    <url>/2023/09/05/ts-types/</url>
    <content><![CDATA[<div id="readmore-container"><p>本章是 TypeScript 类型系统的总体介绍。</p>
<p>TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript 语言（注意，不是 TypeScript）将值分成8种类型。</p>
<ul>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
<li>object</li>
<li>undefined</li>
<li>null</li>
</ul>
<p>TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。</p>
<p>注意，上面所有类型的名称都是小写字母，首字母大写的<code>Number</code>、<code>String</code>、<code>Boolean</code>等在 JavaScript  语言中都是内置对象，而不是类型名称。</p>
<p>另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。</p>
<p>这8种基本类型是 TypeScript 类型系统的基础，复杂类型由它们组合而成。</p>
<p>以下是它们的简单介绍。</p>
<h3 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h3><p><code>boolean</code>类型只包含<code>true</code>和<code>false</code>两个布尔值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>和<code>y</code>就属于 boolean 类型。</p>
<h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p><code>string</code>类型包含所有字符串。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;x&#125;</span> world`</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，普通字符串和模板字符串都属于 string 类型。</p>
<h3 id="number-类型"><a href="#number-类型" class="headerlink" title="number 类型"></a>number 类型</h3><p><code>number</code>类型包含所有整数和浮点数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">number</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z</span>:<span class="built_in">number</span> = <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，整数、浮点数和非十进制数都属于 number 类型。</p>
<h3 id="bigint-类型"><a href="#bigint-类型" class="headerlink" title="bigint 类型"></a>bigint 类型</h3><p>bigint 类型包含所有的大整数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">bigint</span> = <span class="number">123n</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">bigint</span> = <span class="number">0xffffn</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>和<code>y</code>就属于 bigint 类型。</p>
<p>bigint 与 number 类型不兼容。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">bigint</span> = <span class="number">123</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">bigint</span> = <span class="number">3.14</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>bigint</code>类型赋值为整数和小数，都会报错。</p>
<p>注意，bigint 类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数<code>target</code>不低于<code>es2020</code>）。</p>
<h3 id="symbol-类型"><a href="#symbol-类型" class="headerlink" title="symbol 类型"></a>symbol 类型</h3><p>symbol 类型包含所有的 Symbol 值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Symbol()</code>函数的返回值就是 symbol 类型。</p>
<p>symbol 类型的详细介绍，参见《Symbol》一章。</p>
<h3 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h3><p>根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">object</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z</span>:<span class="built_in">object</span> = <span class="function">(<span class="params">n:<span class="built_in">number</span></span>) =&gt;</span> n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象、数组、函数都属于 object 类型。</p>
<h3 id="undefined-类型，null-类型"><a href="#undefined-类型，null-类型" class="headerlink" title="undefined 类型，null 类型"></a>undefined 类型，null 类型</h3><p>undefined 和 null 是两种独立类型，它们各自都只有一个值。</p>
<p>undefined 类型只包含一个值<code>undefined</code>，表示未定义（即还未给出定义，以后可能会有定义）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>就属于 undefined 类型。两个<code>undefined</code>里面，第一个是类型，第二个是值。</p>
<p>null 类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>就属于 null 类型。</p>
<p>注意，如果没有声明类型的变量，被赋值为<code>undefined</code>或<code>null</code>，在关闭编译设置<code>noImplicitAny</code>和<code>strictNullChecks</code>时，它们的类型会被推断为<code>any</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭 noImplicitAny 和 strictNullChecks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">undefined</span>;   <span class="comment">// any</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">undefined</span>; <span class="comment">// any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">null</span>;        <span class="comment">// any</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">null</span>;      <span class="comment">// any</span></span><br></pre></td></tr></table></figure>

<p>如果希望避免这种情况，则需要打开编译选项<code>strictNullChecks</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开编译设置 strictNullChecks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">undefined</span>;   <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">null</span>;        <span class="comment">// null</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">null</span>;      <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，打开编译设置<code>strictNullChecks</code>以后，赋值为<code>undefined</code>的变量会被推断为<code>undefined</code>类型，赋值为<code>null</code>的变量会被推断为<code>null</code>类型。</p>
<h2 id="包装对象类型"><a href="#包装对象类型" class="headerlink" title="包装对象类型"></a>包装对象类型</h2><h3 id="包装对象的概念"><a href="#包装对象的概念" class="headerlink" title="包装对象的概念"></a>包装对象的概念</h3><p>JavaScript 的8种类型之中，<code>undefined</code>和<code>null</code>其实是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p>
<ul>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
</ul>
<p>上面这五种原始类型的值，都有对应的包装对象（wrapper object）。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span>.<span class="title function_">charAt</span>(<span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串<code>hello</code>执行了<code>charAt()</code>方法。但是，在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。这行代码之所以可以运行，就是因为在调用方法时，字符串会自动转为包装对象，<code>charAt()</code>方法其实是定义在包装对象上。</p>
<p>这样的设计大大方便了字符串处理，省去了将原始类型的值手动转成对象实例的麻烦。</p>
<p>五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即<code>Symbol()</code>和<code>BigInt()</code>不能作为构造函数使用），但是剩下三种可以。</p>
<ul>
<li><code>Boolean()</code></li>
<li><code>String()</code></li>
<li><code>Number()</code></li>
</ul>
<p>以上三个构造函数，执行后可以直接获取某个原始类型值的包装对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">s.<span class="title function_">charAt</span>(<span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>s</code>就是字符串<code>hello</code>的包装对象，<code>typeof</code>运算符返回<code>object</code>，不是<code>string</code>，但是本质上它还是字符串，可以使用所有的字符串方法。</p>
<p>注意，<code>String()</code>只有当作构造函数使用时（即带有<code>new</code>命令调用），才会返回包装对象。如果当作普通函数使用（不带有<code>new</code>命令），返回就是一个普通字符串。其他两个构造函数<code>Number()</code>和<code>Boolean()</code>也是如此。</p>
<h3 id="包装对象类型与字面量类型"><a href="#包装对象类型与字面量类型" class="headerlink" title="包装对象类型与字面量类型"></a>包装对象类型与字面量类型</h3><p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> <span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 包装对象</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第一行是字面量，第二行是包装对象，它们都是字符串。</p>
<p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。</p>
<ul>
<li>Boolean 和 boolean</li>
<li>String 和 string</li>
<li>Number 和 number</li>
<li>BigInt 和 bigint</li>
<li>Symbol 和 symbol</li>
</ul>
<p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="title class_">String</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="title class_">String</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s3</span>:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s4</span>:<span class="built_in">string</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>String</code>类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，<code>string</code>类型只能赋值为字面量，赋值为包装对象就会报错。</p>
<p>建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">n1</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">n2</span>:<span class="title class_">Number</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(n1) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(n2) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Math.abs()</code>方法的参数类型被定义成小写的<code>number</code>，传入大写的<code>Number</code>类型就会报错。</p>
<p>上一小节说过，<code>Symbol()</code>和<code>BigInt()</code>这两个函数不能当作构造函数使用，所以没有办法直接获得 symbol 类型和 bigint 类型的包装对象，除非使用下面的写法。但是，它们没有使用场景，因此<code>Symbol</code>和<code>BigInt</code>这两个类型虽然存在，但是完全没有使用的理由。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Object</span>(<span class="title class_">Symbol</span>());</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>(<span class="title class_">BigInt</span>());</span><br></pre></td></tr></table></figure>

<p>上面示例中，得到的就是 Symbol 和 BigInt 的包装对象，但是没有使用的意义。</p>
<p>注意，目前在 TypeScript 里面，<code>symbol</code>和<code>Symbol</code>两种写法没有差异，<code>bigint</code>和<code>BigInt</code>也是如此，不知道是否属于官方的疏忽。建议始终使用小写的<code>symbol</code>和<code>bigint</code>，不使用大写的<code>Symbol</code>和<code>BigInt</code>。</p>
<h2 id="Object-类型与-object-类型"><a href="#Object-类型与-object-类型" class="headerlink" title="Object 类型与 object 类型"></a>Object 类型与 object 类型</h2><p>TypeScript 的对象类型也有大写<code>Object</code>和小写<code>object</code>两种。</p>
<h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>大写的<code>Object</code>类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，这囊括了几乎所有的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">Object</span>;</span><br><span class="line"> </span><br><span class="line">obj = <span class="literal">true</span>;</span><br><span class="line">obj = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">obj = <span class="number">1</span>;</span><br><span class="line">obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">obj = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型。</p>
<p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">Object</span>;</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">undefined</span>; <span class="comment">// 报错</span></span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>undefined</code>和<code>null</code>赋值给<code>Object</code>类型，就会报错。</p>
<p>另外，空对象<code>&#123;&#125;</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">obj = <span class="literal">true</span>;</span><br><span class="line">obj = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">obj = <span class="number">1</span>;</span><br><span class="line">obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">obj = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>obj</code>的类型是空对象<code>&#123;&#125;</code>，就代表<code>Object</code>类型。</p>
<p>显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p>
<h3 id="object-类型-1"><a href="#object-类型-1" class="headerlink" title="object 类型"></a>object 类型</h3><p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="built_in">object</span>;</span><br><span class="line"> </span><br><span class="line">obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">obj = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line">obj = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">obj = <span class="string">&#x27;hi&#x27;</span>; <span class="comment">// 报错</span></span><br><span class="line">obj = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>object</code>类型不包含原始类型值，只包含对象、数组和函数。</p>
<p>大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code>。</p>
<p>注意，无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript  内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">o1</span>:<span class="title class_">Object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">o2</span>:<span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.<span class="title function_">toString</span>() <span class="comment">// 正确</span></span><br><span class="line">o1.<span class="property">foo</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">o2.<span class="title function_">toString</span>() <span class="comment">// 正确</span></span><br><span class="line">o2.<span class="property">foo</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>toString()</code>是对象的原生方法，可以正确访问。<code>foo</code>是自定义属性，访问就会报错。如何描述对象的自定义属性，详见《对象类型》一章。</p>
<h2 id="undefined-和-null-的特殊性"><a href="#undefined-和-null-的特殊性" class="headerlink" title="undefined 和 null 的特殊性"></a>undefined 和 null 的特殊性</h2><p><code>undefined</code>和<code>null</code>既是值，又是类型。</p>
<p>作为值，它们有一个特殊的地方：任何其他类型的变量都可以赋值为<code>undefined</code>或<code>null</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">age = <span class="literal">null</span>;      <span class="comment">// 正确</span></span><br><span class="line">age = <span class="literal">undefined</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>age</code>的类型是<code>number</code>，但是赋值为<code>null</code>或<code>undefined</code>并不报错。</p>
<p>这并不是因为<code>undefined</code>和<code>null</code>包含在<code>number</code>类型里面，而是故意这样设计，任何类型的变量都可以赋值为<code>undefined</code>和<code>null</code>，以便跟 JavaScript 的行为保持一致。</p>
<p>JavaScript 的行为是，变量如果等于<code>undefined</code>就表示还没有赋值，如果等于<code>null</code>就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。</p>
<p>但是有时候，这并不是开发者想要的行为，也不利于发挥类型系统的优势。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="built_in">object</span> = <span class="literal">undefined</span>;</span><br><span class="line">obj.<span class="title function_">toString</span>() <span class="comment">// 编译不报错，运行就报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>obj</code>等于<code>undefined</code>，编译不会报错。但是，实际执行时，调用<code>obj.toString()</code>就报错了，因为<code>undefined</code>不是对象，没有这个方法。</p>
<p>为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项<code>strictNullChecks</code>。只要打开这个选项，<code>undefined</code>和<code>null</code>就不能赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p>
<p>下面是 tsc 命令打开这个编译选项的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsc --strictNullChecks app.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">age = <span class="literal">null</span>;      <span class="comment">// 报错</span></span><br><span class="line">age = <span class="literal">undefined</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，打开<code>--strictNullChecks</code>以后，<code>number</code>类型的变量<code>age</code>就不能赋值为<code>undefined</code>和<code>null</code>。</p>
<p>这个选项在配置文件<code>tsconfig.json</code>的写法如下。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>这两种值也不能互相赋值了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开 strictNullChecks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="literal">undefined</span> = <span class="literal">null</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="literal">null</span> = <span class="literal">undefined</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>undefined</code>类型的变量赋值为<code>null</code>，或者<code>null</code>类型的变量赋值为<code>undefined</code>，都会报错。</p>
<p>总之，打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>只能赋值给自身，或者<code>any</code>类型和<code>unknown</code>类型的变量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span>     = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">unknown</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>TypeScript 规定，单个值也是一种类型，称为“值类型”。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是字符串<code>hello</code>，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。</p>
<p>TypeScript 推断类型时，遇到<code>const</code>命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 的类型是 &quot;https&quot;</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y 的类型是 string</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">string</span> = <span class="string">&#x27;https&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>是<code>const</code>命令声明的，TypeScript 就会推断它的类型是值<code>https</code>，而不是<code>string</code>类型。</p>
<p>这样推断是合理的，因为<code>const</code>命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。</p>
<p>注意，<code>const</code>命令声明的变量，如果赋值为对象，并不会推断为值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 的类型是 &#123; foo: number &#125;</span></span><br><span class="line"><span class="keyword">const</span> x = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>没有被推断为值类型，而是推断属性<code>foo</code>的类型是<code>number</code>。这是因为 JavaScript 里面，<code>const</code>变量赋值为对象时，属性值是可以改变的。</p>
<p>值类型可能会出现一些很奇怪的报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="number">5</span> = <span class="number">4</span> + <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，等号左侧的类型是数值<code>5</code>，等号右侧<code>4 + 1</code>的类型，TypeScript 推测为<code>number</code>。由于<code>5</code>是<code>number</code>的子类型，<code>number</code>是<code>5</code>的父类型，父类型不能赋值给子类型，所以报错了（详见本章后文）。</p>
<p>但是，反过来是可以的，子类型可以赋值给父类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="number">5</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span> = <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// 报错</span></span><br><span class="line">y = x; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>属于子类型，变量<code>y</code>属于父类型。子类型<code>x</code>不能赋值为父类型<code>y</code>，但是反过来是可以的。</p>
<p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言（详见《类型断言》一章）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="number">5</span> = (<span class="number">4</span> + <span class="number">1</span>) <span class="keyword">as</span> <span class="number">5</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，在<code>4 + 1</code>后面加上<code>as 5</code>，就是告诉编译器，可以把<code>4 + 1</code>的类型视为值类型<code>5</code>，这样就不会报错了。</p>
<p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（union types）指的是多个类型组成的一个新类型，使用符号<code>|</code>表示。</p>
<p>联合类型<code>A|B</code>表示，任何一个类型只要属于<code>A</code>或<code>B</code>，就属于联合类型<code>A|B</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">string</span>|<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">123</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>就是联合类型<code>string|number</code>，表示它的值既可以是字符串，也可以是数值。</p>
<p>联合类型可以与值类型相结合，表示一个变量的值有若干种可能。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">setting</span>:<span class="literal">true</span>|<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>:<span class="string">&#x27;male&#x27;</span>|<span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">rainbowColor</span>:<span class="string">&#x27;赤&#x27;</span>|<span class="string">&#x27;橙&#x27;</span>|<span class="string">&#x27;黄&#x27;</span>|<span class="string">&#x27;绿&#x27;</span>|<span class="string">&#x27;青&#x27;</span>|<span class="string">&#x27;蓝&#x27;</span>|<span class="string">&#x27;紫&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的示例都是由值类型组成的联合类型，非常清晰地表达了变量的取值范围。其中，<code>true|false</code>其实就是布尔类型<code>boolean</code>。</p>
<p>前面提到，打开编译选项<code>strictNullChecks</code>后，其他类型的变量不能赋值为<code>undefined</code>或<code>null</code>。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>:<span class="built_in">string</span>|<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">name = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>name</code>的值可以是字符串，也可以是<code>null</code>。</p>
<p>联合类型的第一个成员前面，也可以加上竖杠<code>|</code>，这样便于多行书写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:</span><br><span class="line">  | <span class="string">&#x27;one&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;two&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;three&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;four&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，联合类型的第一个成员<code>one</code>前面，加上了竖杠。</p>
<p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params"></span></span><br><span class="line"><span class="params">  id:<span class="built_in">number</span>|<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>()); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数变量<code>id</code>可能是数值，也可能是字符串，这时直接对这个变量调用<code>toUpperCase()</code>方法会报错，因为这个方法只存在于字符串，不存在于数值。</p>
<p>解决方法就是对参数<code>id</code>做一下类型缩小，确定它的类型以后再进行处理。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params"></span></span><br><span class="line"><span class="params">  id:<span class="built_in">number</span>|<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数体内部会判断一下变量<code>id</code>的类型，如果是字符串，就对其执行<code>toUpperCase()</code>方法。</p>
<p>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。</p>
<p>下面是“类型缩小”的另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPort</span>(<span class="params"></span></span><br><span class="line"><span class="params">  scheme: <span class="string">&#x27;http&#x27;</span>|<span class="string">&#x27;https&#x27;</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (scheme) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;http&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;https&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">443</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数体内部对参数变量<code>scheme</code>进行类型缩小，根据不同的值类型，返回不同的结果。</p>
<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号<code>&amp;</code>表示。</p>
<p>交叉类型<code>A&amp;B</code>表示，任何一个类型必须同时属于<code>A</code>和<code>B</code>，才属于交叉类型<code>A&amp;B</code>，即交叉类型同时满足<code>A</code>和<code>B</code>的特征。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>&amp;<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为<code>x</code>的类型实际是<code>never</code>。</p>
<p>交叉类型的主要用途是表示对象的合成。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:</span><br><span class="line">  &#123; <span class="attr">foo</span>: <span class="built_in">string</span> &#125; &amp;</span><br><span class="line">  &#123; <span class="attr">bar</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>obj</code>同时具有属性<code>foo</code>和属性<code>bar</code>。</p>
<p>交叉类型常常用来为对象类型添加新属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">foo</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = A &amp; &#123; <span class="attr">bar</span>: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>B</code>是一个交叉类型，用来在<code>A</code>的基础上增加了属性<code>bar</code>。</p>
<h2 id="type-命令"><a href="#type-命令" class="headerlink" title="type 命令"></a>type 命令</h2><p><code>type</code>命令用来定义一个类型的别名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="title class_">Age</span> = <span class="number">55</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>type</code>命令为<code>number</code>类型定义了一个别名<code>Age</code>。这样就能像使用<code>number</code>一样，使用<code>Age</code>作为类型。</p>
<p>别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。</p>
<p>别名不允许重名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&#x27;blue&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，同一个别名<code>Color</code>声明了两次，就报错了。</p>
<p>别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>if</code>代码块内部的类型别名<code>Color</code>，跟外部的<code>Color</code>是不一样的。</p>
<p>别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，别名<code>Greeting</code>使用了模板字符串，读取另一个别名<code>World</code>。</p>
<p><code>type</code>命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。</p>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>JavaScript 语言中，typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>typeof</code>运算符返回字符串<code>foo</code>的类型是<code>string</code>。</p>
<p>注意，这时 typeof 的操作数是一个值。</p>
<p>JavaScript 里面，<code>typeof</code>运算符只可能返回八种结果，而且都是字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1337</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;foo&quot;</span>; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">parseInt</span>; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(); <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">127n</span> <span class="comment">// &quot;bigint&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例是<code>typeof</code>运算符在 JavaScript 语言里面，可能返回的八种结果。</p>
<p>TypeScript 将<code>typeof</code>运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="keyword">typeof</span> a;   <span class="comment">// &#123; x: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="keyword">typeof</span> a.<span class="property">x</span>; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>typeof a</code>表示返回变量<code>a</code>的 TypeScript 类型（<code>&#123; x: number &#125;</code>）。同理，<code>typeof a.x</code>返回的是属性<code>x</code>的类型（<code>number</code>）。</p>
<p>这种用法的<code>typeof</code>返回的是 TypeScript 类型，所以只能用在类型运算之中（即跟类型相关的代码之中），不能用在值运算。</p>
<p>也就是说，同一段代码可能存在两种<code>typeof</code>运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="keyword">typeof</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，用到了两个<code>typeof</code>，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。</p>
<p>JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。</p>
<p>上例的代码编译结果如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，只保留了原始代码的第二个 typeof，删除了第一个 typeof。</p>
<p>由于编译时不会进行 JavaScript 的值运算，所以TypeScript 规定，typeof 的参数只能是标识符，不能是需要运算的表达式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="keyword">typeof</span> <span class="title class_">Date</span>(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例会报错，原因是 typeof 的参数不能是一个值的运算式，而<code>Date()</code>需要运算才知道结果。</p>
<p>另外，<code>typeof</code>命令的参数不能是类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyAge</span> = <span class="keyword">typeof</span> <span class="title class_">Age</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Age</code>是一个类型别名，用作<code>typeof</code>命令的参数就会报错。</p>
<p>typeof 是一个很重要的 TypeScript 运算符，有些场合不知道某个变量<code>foo</code>的类型，这时使用<code>typeof foo</code>就可以获得它的类型。</p>
<h2 id="块级类型声明"><a href="#块级类型声明" class="headerlink" title="块级类型声明"></a>块级类型声明</h2><p>TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">type</span> T = <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">v</span>:T = <span class="number">5</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> T = <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">v</span>:T = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，存在两个代码块，其中分别有一个类型<code>T</code>的声明。这两个声明都只在自己的代码块内部有效，在代码块外部无效。</p>
<h2 id="类型的兼容"><a href="#类型的兼容" class="headerlink" title="类型的兼容"></a>类型的兼容</h2><p>TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="built_in">number</span>|<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:T = a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>b</code>的类型是不一样的，但是变量<code>a</code>赋值给变量<code>b</code>并不会报错。这时，我们就认为，<code>b</code>的类型兼容<code>a</code>的类型。</p>
<p>TypeScript 为这种情况定义了一个专门术语。如果类型<code>A</code>的值可以赋值给类型<code>B</code>，那么类型<code>A</code>就称为类型<code>B</code>的子类型（subtype）。在上例中，类型<code>number</code>就是类型<code>number|string</code>的子类型。</p>
<p>TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="string">&#x27;hi&#x27;</span> = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">b = a; <span class="comment">// 正确</span></span><br><span class="line">a = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>hi</code>是<code>string</code>的子类型，<code>string</code>是<code>hi</code>的父类型。所以，变量<code>a</code>可以赋值给变量<code>b</code>，但是反过来就会报错。</p>
<p>之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 类型工具</title>
    <url>/2023/09/05/ts-utility/</url>
    <content><![CDATA[<div id="readmore-container"><p>TypeScript 提供了一些内置的类型工具，用来方便地处理各种类型，以及生成新的类型。</p>
<p>TypeScript 内置了17个类型工具，可以直接使用。</p>
<h2 id="Awaited-lt-Type-gt"><a href="#Awaited-lt-Type-gt" class="headerlink" title="Awaited&lt;Type&gt;"></a><code>Awaited&lt;Type&gt;</code></h2><p><code>Awaited&lt;Type&gt;</code>用来取出 Promise 的返回值类型，适合用在描述<code>then()</code>方法和 await 命令的参数类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Awaited</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Awaited&lt;Type&gt;</code>会返回 Promise 的返回值类型（string）。</p>
<p>它也可以返回多重 Promise 的返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Awaited</span>&lt;<span class="title class_">Promise</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>如果它的类型参数不是 Promise 类型，那么就会原样返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number | boolean</span></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">Awaited</span>&lt;<span class="built_in">boolean</span> | <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数是一个联合类型，其中的<code>boolean</code>会原样返回，所以最终返回的是<code>number|boolean</code>。</p>
<p><code>Awaited&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Awaited</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? T :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">object</span> &amp; &#123;</span><br><span class="line">    <span class="title function_">then</span>(</span><br><span class="line">      <span class="attr">onfulfilled</span>: infer F,</span><br><span class="line">      ...<span class="attr">args</span>: infer _</span><br><span class="line">    ): <span class="built_in">any</span>;</span><br><span class="line">  &#125; ? F <span class="keyword">extends</span> (</span><br><span class="line">    <span class="attr">value</span>: infer V,</span><br><span class="line">    ...<span class="attr">args</span>: infer _</span><br><span class="line">  ) =&gt; <span class="built_in">any</span> ? <span class="title class_">Awaited</span>&lt;...&gt; : <span class="attr">never</span>:</span><br><span class="line">  T;</span><br></pre></td></tr></table></figure>

<h2 id="ConstructorParameters-lt-Type-gt"><a href="#ConstructorParameters-lt-Type-gt" class="headerlink" title="ConstructorParameters&lt;Type&gt;"></a><code>ConstructorParameters&lt;Type&gt;</code></h2><p><code>ConstructorParameters&lt;Type&gt;</code>提取构造方法<code>Type</code>的参数类型，组成一个元组类型返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">number</span>) =&gt; <span class="built_in">object</span></span><br><span class="line">&gt;; <span class="comment">// [x: string, y: number]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="keyword">new</span> (x?: <span class="built_in">string</span>) =&gt; <span class="built_in">object</span></span><br><span class="line">&gt;; <span class="comment">// [x?: string | undefined]</span></span><br></pre></td></tr></table></figure>

<p>它可以返回一些内置构造方法的参数类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="title class_">ErrorConstructor</span></span><br><span class="line">&gt;; <span class="comment">// [message?: string]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="title class_">FunctionConstructor</span></span><br><span class="line">&gt;; <span class="comment">// string[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="title class_">RegExpConstructor</span></span><br><span class="line">&gt;; <span class="comment">// [pattern:string|RegExp, flags?:string]</span></span><br></pre></td></tr></table></figure>

<p>如果参数类型不是构造方法，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="built_in">string</span>&gt;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="title class_">Function</span>&gt;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><code>any</code>类型和<code>never</code>类型是两个特殊值，分别返回<code>unknown[]</code>和<code>never</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="built_in">any</span>&gt;;  <span class="comment">// unknown[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="built_in">never</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p><code>ConstructorParameters&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: infer P) </span><br><span class="line">  =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="Exclude-lt-UnionType-ExcludedMembers-gt"><a href="#Exclude-lt-UnionType-ExcludedMembers-gt" class="headerlink" title="Exclude&lt;UnionType, ExcludedMembers&gt;"></a><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code></h2><p><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code>用来从联合类型<code>UnionType</code>里面，删除某些类型<code>ExcludedMembers</code>，组成一个新的类型返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// &#x27;b&#x27;|&#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>&gt;; <span class="comment">// &#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Exclude</span>&lt;<span class="built_in">string</span>|(<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="title class_">Function</span>&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Exclude</span>&lt;<span class="built_in">string</span> | <span class="built_in">string</span>[], <span class="built_in">any</span>[]&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Exclude</span>&lt;(<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="literal">null</span>, <span class="title class_">Function</span>&gt;; <span class="comment">// null</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">Exclude</span>&lt;<span class="number">200</span> | <span class="number">400</span>, <span class="number">200</span> | <span class="number">201</span>&gt;; <span class="comment">// 400</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T7</span> = <span class="title class_">Exclude</span>&lt;<span class="built_in">number</span>, <span class="built_in">boolean</span>&gt;; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<p>上面代码中，等号右边的部分，表示先判断<code>T</code>是否兼容<code>U</code>，如果是的就返回<code>never</code>类型，否则返回当前类型<code>T</code>。由于<code>never</code>类型是任何其他类型的子类型，它跟其他类型组成联合类型时，可以直接将<code>never</code>类型从联合类型中“消掉”，因此<code>Exclude&lt;T, U&gt;</code>就相当于删除兼容的类型，剩下不兼容的类型。</p>
<h2 id="Extract-lt-Type-Union-gt"><a href="#Extract-lt-Type-Union-gt" class="headerlink" title="Extract&lt;Type, Union&gt;"></a><code>Extract&lt;Type, Union&gt;</code></h2><p><code>Extract&lt;UnionType, Union&gt;</code>用来从联合类型<code>UnionType</code>之中，提取指定类型<code>Union</code>，组成一个新类型返回。它与<code>Exclude&lt;T, U&gt;</code>正好相反。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Extract</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Extract</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>&gt;; <span class="comment">// &#x27;a&#x27;|&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Extract</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;d&#x27;</span>&gt;; <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Extract</span>&lt;<span class="built_in">string</span> | <span class="built_in">string</span>[], <span class="built_in">any</span>[]&gt;; <span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Extract</span>&lt;(<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="literal">null</span>, <span class="title class_">Function</span>&gt;; <span class="comment">// () =&gt; void</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">Extract</span>&lt;<span class="number">200</span> | <span class="number">400</span>, <span class="number">200</span> | <span class="number">201</span>&gt;; <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>

<p>如果参数类型<code>Union</code>不包含在联合类型<code>UnionType</code>之中，则返回<code>never</code>类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="title class_">Extract</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>, <span class="built_in">boolean</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p><code>Extract&lt;UnionType, Union&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<h2 id="InstanceType-lt-Type-gt"><a href="#InstanceType-lt-Type-gt" class="headerlink" title="InstanceType&lt;Type&gt;"></a><code>InstanceType&lt;Type&gt;</code></h2><p><code>InstanceType&lt;Type&gt;</code>提取构造函数的返回值的类型（即实例类型），参数<code>Type</code>是一个构造函数，等同于构造函数的<code>ReturnType&lt;Type&gt;</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="title class_">InstanceType</span>&lt;</span><br><span class="line">  <span class="keyword">new</span> () =&gt; <span class="built_in">object</span></span><br><span class="line">&gt;; <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数是一个构造函数<code>new () =&gt; object</code>，返回值是该构造函数的实例类型（<code>object</code>）。</p>
<p>下面是一些例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="title class_">InstanceType</span>&lt;<span class="title class_">ErrorConstructor</span>&gt;; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">InstanceType</span>&lt;<span class="title class_">FunctionConstructor</span>&gt;; <span class="comment">// Function</span></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">InstanceType</span>&lt;<span class="title class_">RegExpConstructor</span>&gt;; <span class="comment">// RegExp</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>InstanceType&lt;T&gt;</code>的参数都是 TypeScript 内置的原生对象的构造函数类型，<code>InstanceType&lt;T&gt;</code>的返回值就是这些构造函数的实例类型。</p>
<p>由于 Class 作为类型，代表实例类型。要获取它的构造方法，必须把它当成值，然后用<code>typeof</code>运算符获取它的构造方法类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">InstanceType</span>&lt;<span class="keyword">typeof</span> C&gt;; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>typeof C</code>是<code>C</code>的构造方法类型，然后 InstanceType 就能获得实例类型，即<code>C</code>本身。</p>
<p>如果类型参数不是构造方法，就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">InstanceType</span>&lt;<span class="built_in">string</span>&gt;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">InstanceType</span>&lt;<span class="title class_">Function</span>&gt;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果类型参数是<code>any</code>或<code>never</code>两个特殊值，分别返回<code>any</code>和<code>never</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">InstanceType</span>&lt;<span class="built_in">any</span>&gt;; <span class="comment">// any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">InstanceType</span>&lt;<span class="built_in">never</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p><code>InstanceType&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">InstanceType</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>:<span class="built_in">any</span>) =&gt; <span class="built_in">any</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer R ? R :</span><br><span class="line">  <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<h2 id="NonNullable-lt-Type-gt"><a href="#NonNullable-lt-Type-gt" class="headerlink" title="NonNullable&lt;Type&gt;"></a><code>NonNullable&lt;Type&gt;</code></h2><p><code>NonNullable&lt;Type&gt;</code>用来从联合类型<code>Type</code>删除<code>null</code>类型和<code>undefined</code>类型，组成一个新类型返回，也就是返回<code>Type</code>的非空类型版本。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string|number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>|<span class="literal">undefined</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span>[]|<span class="literal">null</span>|<span class="literal">undefined</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">boolean</span>&gt;; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">number</span>|<span class="literal">null</span>&gt;; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span>|<span class="literal">undefined</span>&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">NonNullable</span>&lt;<span class="literal">null</span>|<span class="literal">undefined</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p><code>NonNullable&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T &amp; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>T &amp; &#123;&#125;</code>等同于求<code>T &amp; Object</code>的交叉类型。由于 TypeScript 的非空值都属于<code>Object</code>的子类型，所以会返回自身；而<code>null</code>和<code>undefined</code>不属于<code>Object</code>，会返回<code>never</code>类型。</p>
<h2 id="Omit-lt-Type-Keys-gt"><a href="#Omit-lt-Type-Keys-gt" class="headerlink" title="Omit&lt;Type, Keys&gt;"></a><code>Omit&lt;Type, Keys&gt;</code></h2><p><code>Omit&lt;Type, Keys&gt;</code>用来从对象类型<code>Type</code>中，删除指定的属性<code>Keys</code>，组成一个新的对象类型返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Omit</span>&lt;A, <span class="string">&#x27;x&#x27;</span>&gt;;       <span class="comment">// &#123; y: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Omit</span>&lt;A, <span class="string">&#x27;y&#x27;</span>&gt;;       <span class="comment">// &#123; x: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Omit</span>&lt;A, <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt;; <span class="comment">// &#123; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Omit&lt;Type, Keys&gt;</code>从对象类型<code>A</code>里面删除指定属性，返回剩下的属性。</p>
<p>指定删除的键名<code>Keys</code>可以是对象类型<code>Type</code>中不存在的属性，但必须兼容<code>string|number|symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Omit</span>&lt;A, <span class="string">&#x27;z&#x27;</span>&gt;; <span class="comment">// &#123; x: number; y: number &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象类型<code>A</code>中不存在属性<code>z</code>，所以就原样返回了。</p>
<p><code>Omit&lt;Type, Keys&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; </span><br><span class="line">  = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="OmitThisParameter-lt-Type-gt"><a href="#OmitThisParameter-lt-Type-gt" class="headerlink" title="OmitThisParameter&lt;Type&gt;"></a><code>OmitThisParameter&lt;Type&gt;</code></h2><p><code>OmitThisParameter&lt;Type&gt;</code>从函数类型中移除 this 参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toHex</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">OmitThisParameter</span>&lt;<span class="keyword">typeof</span> toHex&gt;; <span class="comment">// () =&gt; string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>OmitThisParameter&lt;T&gt;</code>给出了函数<code>toHex()</code>的类型，并将其中的<code>this</code>参数删除。</p>
<p>如果函数没有 this 参数，则返回原始函数类型。</p>
<p><code>OmitThisParameter&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OmitThisParameter</span>&lt;T&gt; =</span><br><span class="line">  <span class="built_in">unknown</span> <span class="keyword">extends</span> <span class="title class_">ThisParameterType</span>&lt;T&gt; ? T :</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer A) =&gt; infer R ?</span><br><span class="line">  <span class="function">(<span class="params">...args: A</span>) =&gt;</span> R : T;</span><br></pre></td></tr></table></figure>

<h2 id="Parameters-lt-Type-gt"><a href="#Parameters-lt-Type-gt" class="headerlink" title="Parameters&lt;Type&gt;"></a><code>Parameters&lt;Type&gt;</code></h2><p><code>Parameters&lt;Type&gt;</code>从函数类型<code>Type</code>里面提取参数类型，组成一个元组返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;; <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">s:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;; <span class="comment">// [s:string]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Parameters</span>&lt;&lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T&gt;;    <span class="comment">// [arg: unknown]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Parameters</span>&lt;</span><br><span class="line">  <span class="function">(<span class="params">x:&#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&gt;; <span class="comment">// [x: &#123; a: number, b: string &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Parameters</span>&lt;</span><br><span class="line">  <span class="function">(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">&gt;; <span class="comment">// [a:number, b:number]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Parameters&lt;Type&gt;</code>的返回值会包括函数的参数名，这一点需要注意。</p>
<p>如果参数类型<code>Type</code>不是带有参数的函数形式，会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;<span class="title class_">Function</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>由于<code>any</code>和<code>never</code>是两个特殊值，会返回<code>unknown[]</code>和<code>never</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="built_in">any</span>&gt;; <span class="comment">// unknown[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;<span class="built_in">never</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p><code>Parameters&lt;Type&gt;</code>主要用于从外部模块提供的函数类型中，获取参数类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SecretName</span> &#123;</span><br><span class="line">  <span class="attr">first</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">last</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SecretSanta</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">SecretName</span>;</span><br><span class="line">  <span class="attr">gift</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getGift</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name: SecretName,</span></span><br><span class="line"><span class="params">  gift: <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">SecretSanta</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，模块只输出了函数<code>getGift()</code>，没有输出参数<code>SecretName</code>和返回值<code>SecretSanta</code>。这时就可以通过<code>Parameters&lt;T&gt;</code>和<code>ReturnType&lt;T&gt;</code>拿到这两个接口类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ParaT</span> = <span class="title class_">Parameters</span>&lt;<span class="keyword">typeof</span> getGift&gt;[<span class="number">0</span>]; <span class="comment">// SecretName</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnT</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> getGift&gt;; <span class="comment">// SecretSanta</span></span><br></pre></td></tr></table></figure>

<p><code>Parameters&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer P)</span><br><span class="line">  =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="Partial-lt-Type-gt"><a href="#Partial-lt-Type-gt" class="headerlink" title="Partial&lt;Type&gt;"></a><code>Partial&lt;Type&gt;</code></h2><p><code>Partial&lt;Type&gt;</code>返回一个新类型，将参数类型<code>Type</code>的所有属性变为可选属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Partial</span>&lt;A&gt;; <span class="comment">// &#123; x?: number; y?: number; &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Partial&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Pick-lt-Type-Keys-gt"><a href="#Pick-lt-Type-Keys-gt" class="headerlink" title="Pick&lt;Type, Keys&gt;"></a><code>Pick&lt;Type, Keys&gt;</code></h2><p><code>Pick&lt;Type, Keys&gt;</code>返回一个新的对象类型，第一个参数<code>Type</code>是一个对象类型，第二个参数<code>Keys</code>是<code>Type</code>里面被选定的键名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Pick</span>&lt;A, <span class="string">&#x27;x&#x27;</span>&gt;; <span class="comment">// &#123; x: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Pick</span>&lt;A, <span class="string">&#x27;y&#x27;</span>&gt;; <span class="comment">// &#123; y: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Pick</span>&lt;A, <span class="string">&#x27;x&#x27;</span>|<span class="string">&#x27;y&#x27;</span>&gt;;  <span class="comment">// &#123; x: number; y: number &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Pick&lt;Type, Keys&gt;</code>会从对象类型<code>A</code>里面挑出指定的键名，组成一个新的对象类型。</p>
<p>指定的键名<code>Keys</code>必须是对象键名<code>Type</code>里面已经存在的键名，否则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Pick</span>&lt;A, <span class="string">&#x27;z&#x27;</span>&gt;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象类型<code>A</code>不存在键名<code>z</code>，所以报错了。</p>
<p><code>Pick&lt;Type, Keys&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Readonly-lt-Type-gt"><a href="#Readonly-lt-Type-gt" class="headerlink" title="Readonly&lt;Type&gt;"></a><code>Readonly&lt;Type&gt;</code></h2><p><code>Readonly&lt;Type&gt;</code>返回一个新类型，将参数类型<code>Type</code>的所有属性变为只读属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; readonly x: number; readonly y?: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Readonly</span>&lt;A&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>y</code>是可选属性，<code>Readonly&lt;Type&gt;</code>不会改变这一点，只会让<code>y</code>变成只读。</p>
<p><code>Readonly&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以自定义类型工具<code>Mutable&lt;Type&gt;</code>，将参数类型的所有属性变成可变属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>-readonly</code>表示去除属性的只读标志。</p>
<p>相应地，<code>+readonly</code>就表示增加只读标志，等同于<code>readonly</code>。因此，<code>ReadOnly&lt;Type&gt;</code>的实现也可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Readonly&lt;Type&gt;</code>可以与<code>Partial&lt;Type&gt;</code>结合使用，将所有属性变成只读的可选属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">worker</span>: <span class="title class_">Readonly</span>&lt;<span class="title class_">Partial</span>&lt;<span class="title class_">Person</span>&gt;&gt;</span><br><span class="line">  = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">worker.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h2 id="Record-lt-Keys-Type-gt"><a href="#Record-lt-Keys-Type-gt" class="headerlink" title="Record&lt;Keys, Type&gt;"></a><code>Record&lt;Keys, Type&gt;</code></h2><p><code>Record&lt;Keys, Type&gt;</code>返回一个对象类型，参数<code>Keys</code>用作键名，参数<code>Type</code>用作键值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123; a: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Record&lt;Keys, Type&gt;</code>的第一个参数<code>a</code>，用作对象的键名，第二个参数<code>number</code>是<code>a</code>的键值类型。</p>
<p>参数<code>Keys</code>可以是联合类型，这时会依次展开为多个键。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123; a: number, b: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，第一个参数是联合类型<code>&#39;a&#39;|&#39;b&#39;</code>，展开成两个键名<code>a</code>和<code>b</code>。</p>
<p>如果参数<code>Type</code>是联合类型，就表明键值是联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123; a: number|string &#125;</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span>, <span class="built_in">number</span>|<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>参数<code>Keys</code>的类型必须兼容<code>string|number|symbol</code>，否则不能用作键名，会报错。</p>
<p><code>Record&lt;Keys, Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">symbol</span>, T&gt;</span><br><span class="line">  = &#123; [P <span class="keyword">in</span> K]: T; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Required-lt-Type-gt"><a href="#Required-lt-Type-gt" class="headerlink" title="Required&lt;Type&gt;"></a><code>Required&lt;Type&gt;</code></h2><p><code>Required&lt;Type&gt;</code>返回一个新类型，将参数类型<code>Type</code>的所有属性变为必选属性。它与<code>Partial&lt;Type&gt;</code>的作用正好相反。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Required</span>&lt;A&gt;; <span class="comment">// &#123; x: number; y: number; &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Required&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，符号<code>-?</code>表示去除可选属性的“问号”，使其变成必选属性。</p>
<p>相对应地，符号<code>+?</code>表示增加可选属性的“问号”，等同于<code>?</code>。因此，前面的<code>Partial&lt;Type&gt;</code>的定义也可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]+?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="ReadonlyArray-lt-Type-gt"><a href="#ReadonlyArray-lt-Type-gt" class="headerlink" title="ReadonlyArray&lt;Type&gt;"></a><code>ReadonlyArray&lt;Type&gt;</code></h2><p><code>ReadonlyArray&lt;Type&gt;</code>用来生成一个只读数组类型，类型参数<code>Type</code>表示数组成员的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">values</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">string</span>&gt; </span><br><span class="line">  = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">values[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>; <span class="comment">// 报错</span></span><br><span class="line">values.<span class="title function_">push</span>(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// 报错</span></span><br><span class="line">values.<span class="title function_">pop</span>(); <span class="comment">// 报错</span></span><br><span class="line">values.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>values</code>的类型是一个只读数组，所以修改成员会报错，并且那些会修改源数组的方法<code>push()</code>、<code>pop()</code>、<code>splice()</code>等都不存在。</p>
<p><code>ReadonlyArray&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyArray</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">n</span>: <span class="built_in">number</span>]: T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReturnType-lt-Type-gt"><a href="#ReturnType-lt-Type-gt" class="headerlink" title="ReturnType&lt;Type&gt;"></a><code>ReturnType&lt;Type&gt;</code></h2><p><code>ReturnType&lt;Type&gt;</code>提取函数类型<code>Type</code>的返回值类型，作为一个新类型返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span></span><br><span class="line">&#125;&gt;; <span class="comment">// &#123; a: string; b: number &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">(<span class="params">s:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;; <span class="comment">// void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="function">() =&gt;</span> <span class="built_in">any</span>[]&gt;; <span class="comment">// () =&gt; any[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Math</span>.<span class="property">random</span>&gt;; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Array</span>.<span class="property">isArray</span>&gt;; <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<p>如果参数类型是泛型函数，返回值取决于泛型类型。如果泛型不带有限制条件，就会返回<code>unknown</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;&lt;T&gt;<span class="function">() =&gt;</span> T&gt;; <span class="comment">// unknown</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ReturnType</span>&lt;</span><br><span class="line">  &lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> <span class="built_in">number</span>[]&gt;<span class="function">() =&gt;</span> T</span><br><span class="line">&gt;; <span class="comment">// number[]</span></span><br></pre></td></tr></table></figure>

<p>如果类型不是函数，会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="built_in">boolean</span>&gt;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Function</span>&gt;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><code>any</code>和<code>never</code>是两个特殊值，分别返回<code>any</code>和<code>never</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="built_in">any</span>&gt;; <span class="comment">// any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ReturnType</span>&lt;<span class="built_in">never</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p><code>ReturnType&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span></span><br><span class="line">&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<h2 id="ThisParameterType-lt-Type-gt"><a href="#ThisParameterType-lt-Type-gt" class="headerlink" title="ThisParameterType&lt;Type&gt;"></a><code>ThisParameterType&lt;Type&gt;</code></h2><p><code>ThisParameterType&lt;Type&gt;</code>提取函数类型中<code>this</code>参数的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toHex</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ThisParameterType</span>&lt;<span class="keyword">typeof</span> toHex&gt;; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>如果函数没有<code>this</code>参数，则返回<code>unknown</code>。</p>
<p><code>ThisParameterType&lt;Type&gt;</code>的实现如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ThisParameterType</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> (</span><br><span class="line">    <span class="attr">this</span>: infer U,</span><br><span class="line">    ...<span class="attr">args</span>: <span class="built_in">never</span></span><br><span class="line">  ) =&gt; <span class="built_in">any</span> ? U : <span class="built_in">unknown</span>;</span><br></pre></td></tr></table></figure>

<h2 id="ThisType-lt-Type-gt"><a href="#ThisType-lt-Type-gt" class="headerlink" title="ThisType&lt;Type&gt;"></a><code>ThisType&lt;Type&gt;</code></h2><p><code>ThisType&lt;Type&gt;</code>不返回类型，只用来跟其他类型组成交叉类型，用来提示 TypeScript 其他类型里面的<code>this</code>的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HelperThisValue</span> &#123;</span><br><span class="line">  <span class="attr">logError</span>: <span class="function">(<span class="params">error:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">helperFunctions</span>:</span><br><span class="line">  &#123; [<span class="attr">name</span>: <span class="built_in">string</span>]: <span class="title class_">Function</span> &#125; &amp;</span><br><span class="line">  <span class="title class_">ThisType</span>&lt;<span class="title class_">HelperThisValue</span>&gt;</span><br><span class="line">= &#123;</span><br><span class="line">  <span class="attr">hello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">logError</span>(<span class="string">&quot;Error: Something wrong!&quot;</span>); <span class="comment">// 正确</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>helperFunctions</code>的类型是一个正常的对象类型与<code>ThisType&lt;HelperThisValue&gt;</code>组成的交叉类型。</p>
<p>这里的<code>ThisType</code>的作用是提示 TypeScript，变量<code>helperFunctions</code>的<code>this</code>应该满足<code>HelperThisValue</code>的条件。所以，<code>this.logError()</code>可以正确调用，而<code>this.update()</code>会报错，因为<code>HelperThisValue</code>里面没有这个方法。</p>
<p>注意，使用这个类型工具时，必须打开<code>noImplicitThis</code>设置。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">ThisType</span>&lt;&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125;&gt; &amp;</span><br><span class="line">  &#123; <span class="attr">getX</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj = &#123;</span><br><span class="line">  <span class="title function_">getX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>; <span class="comment">// 报错</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getX()</code>里面的<code>this.y</code>会报错，因为根据<code>ThisType&lt;&#123; x: number &#125;&gt;</code>，这个对象的<code>this</code>不包含属性<code>y</code>。</p>
<p><code>ThisType&lt;Type&gt;</code>的实现就是一个空接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ThisType</span>&lt;T&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串类型工具"><a href="#字符串类型工具" class="headerlink" title="字符串类型工具"></a>字符串类型工具</h2><p>TypeScript 内置了四个字符串类型工具，专门用来操作字符串类型。这四个工具类型都定义在 TypeScript 自带的<code>.d.ts</code>文件里面。</p>
<p>它们的实现都是在底层调用 JavaScript 引擎提供 JavaScript 字符操作方法。</p>
<h3 id="Uppercase-lt-StringType-gt"><a href="#Uppercase-lt-StringType-gt" class="headerlink" title="Uppercase&lt;StringType&gt;"></a><code>Uppercase&lt;StringType&gt;</code></h3><p><code>Uppercase&lt;StringType&gt;</code>将字符串类型的每个字符转为大写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;HELLO&quot;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Uppercase</span>&lt;A&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Uppercase&lt;T&gt;</code>将 hello 转为 HELLO。</p>
<h3 id="Lowercase-lt-StringType-gt"><a href="#Lowercase-lt-StringType-gt" class="headerlink" title="Lowercase&lt;StringType&gt;"></a><code>Lowercase&lt;StringType&gt;</code></h3><p><code>Lowercase&lt;StringType&gt;</code>将字符串的每个字符转为小写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;HELLO&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Lowercase</span>&lt;A&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Lowercase&lt;T&gt;</code>将 HELLO 转为 hello。</p>
<h3 id="Capitalize-lt-StringType-gt"><a href="#Capitalize-lt-StringType-gt" class="headerlink" title="Capitalize&lt;StringType&gt;"></a><code>Capitalize&lt;StringType&gt;</code></h3><p><code>Capitalize&lt;StringType&gt;</code>将字符串的第一个字符转为大写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Capitalize</span>&lt;A&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Capitalize&lt;T&gt;</code>将 hello 转为 Hello。</p>
<h3 id="Uncapitalize-lt-StringType-gt"><a href="#Uncapitalize-lt-StringType-gt" class="headerlink" title="Uncapitalize&lt;StringType&gt;"></a><code>Uncapitalize&lt;StringType&gt;</code></h3><p><code>Uncapitalize&lt;StringType&gt;</code> 将字符串的第一个字符转为小写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;HELLO&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;hELLO&quot;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Uncapitalize</span>&lt;A&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Uncapitalize&lt;T&gt;</code>将 HELLO 转为 hELLO。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://stackoverflow.com/questions/55029032/what-is-typescripts-thistype-used-for">What is TypeScript’s ThisType used for?</a></li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <categories>
        <category>TS教程</category>
      </categories>
  </entry>
  <entry>
    <title>卡辛斯基的警告</title>
    <url>/2023/07/20/%E5%8D%A1%E8%BE%9B%E6%96%AF%E5%9F%BA%E7%9A%84%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<div id="readmore-container"><article class="content is-size-4-desktop">
<p>作者： 阮一峰</p>
<p>1、</p><p>1978年5月25日，美国西北大学的工程教授巴克利·克利斯（Buckley Crist），收到了邮政局退回的一个包裹。</p><p>这个包裹寄往芝加哥大学，但是收件人“查无此人”。克利斯教授不记得寄过它，可是发件人却写着自己的名字。他叫来了学校的保安。保安打开了包裹，里面是一颗炸弹，立刻爆炸了。保安身受重伤。</p><p>此后的18年，这样的案件一再发生。凶手一共寄出了16枚邮件炸弹，共炸死3人，炸伤23人。袭击对象主要是大学的理工科教授，所以凶手被称为“大学炸弹客”（Unabomber）。</p><p>联邦调查局 FBI 想尽办法要抓住凶手。十几年的调查中，动用了500名特工，误抓了200多名嫌疑犯，查访上万民众，接了2万多通检举电话，花费500万美元，但是一无所获。凶手非常小心，没有留下任何线索。这个案件成了 FBI 历史上最昂贵的调查之一。</p><p>2、</p><p>1995年4月，凶手又一次作案，一次性寄出了四样东西：两个邮件炸弹，炸死了加州林业协会的总裁吉卜特·莫里，炸断了耶鲁大学计算机科学教授大卫·加勒特的几根手指；一封警告信，警告1993年诺贝尔奖获得者遗传学家理查·罗伯特和菲利普·夏普，要求他们立刻停止基因研究；一篇发给《纽约时报》的长达3.5万字的文章，承诺如果美国主流媒体一字不改地全文刊登，他就将永久停止炸弹袭击。</p><p>经过反复研究，FBI 局长和美国司法部长最终同意刊登这篇文章。1995年9月19日，它发表在当天的《纽约时报》和《华盛顿邮报》上，题目叫做《论工业社会及其未来》（Industrial Society and Its Future）。</p><figure><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017090903.jpg" alt=""></figure><p>新闻界觉得不可思议，难道凶手用了18年时间，精心策划实施了那么多起爆炸案，目的竟然只是为了发表一篇论文？更令人吃惊的是，这居然是一篇充满思辨的哲学论文，作者明显受过学术训练。论文声称，工业革命带来的是人类的灾难，技术使人类丧失自由，最终将导致社会的动荡甚至毁灭，人们应该摧毁现代工业体系。这就是凶手为什么袭击大学教授的原因，因为他们推动了技术的发展。</p><p>看过的人都觉得，这篇论文写得很有说服力。许多人开始认真思考作者的观点，主流的知识分子杂志（比如《大西洋》、《纽约人》）专文讨论它。那位被炸断手指的耶鲁大学教授大卫·加勒特承认，文章的推断不无道理，工业文明时代，人类的未来，也许真的险恶重重。Java 语言的创始人之一的计算机学家 Bill Joy 则说，他对文章预言的未来深感困扰。艺术家更是深受影响， 后来的许多小说和电影（比如《黑客帝国》），都能看到这篇论文的影子。</p><p>3、</p><p>论文发表以后，FBI 收到一条线索：有人举报，该文的写作风格和论点，很像出自他的哥哥泰德·卡辛斯基（Ted Kaczynski）之手。</p><p>1996年4月3日，卡辛斯基在蒙大拿州被逮捕，他住在远离人群的荒野森林之中，自己搭建了一个小木屋，里面堆满了炸弹原料。至此，邮包炸弹案宣告破案。</p><figure><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017090904.jpg" alt=""></figure><p>卡辛斯基的人生很不寻常。他生于1942年，从小就具有超人的数学天才， 16岁被哈佛大学数学系录取。</p><figure><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017090901.jpg" alt=""></figure><p>1962年进入密歇根大学攻读数学博士，只用了几个月就拿到了博士学位。指导教授说他的博士论文十分深奥，全美只有十几个人能看懂。25岁时，他被加州大学柏克莱分校聘为助理教授，是该校史上最年轻的教授。</p><figure><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017090905.jpg" alt=""></figure><p>卡辛斯基在柏克莱只待了不到2年，就辞职了，没有给出任何理由。他从此脱离学术界，过上了离群索居的生活，1971年，在父母的资助下，他在蒙大拿州一个偏僻的山区盖了一间小木屋，搬到那里去住了。屋子里没有电灯、电话、自来水。平日里他吃自己种的菜、猎捕的食物，晚上点蜡烛看书，砍柴做饭取暖。只有购买日用品的时候，他才会骑自行车来到几十公里以外的小镇。1978年，他在那里寄出了第一个邮件炸弹，攻击目标是在图书馆里面随机选择的。</p><figure><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017090902.jpg" alt=""></figure><p>被捕后，卡辛斯基拒绝了律师为其辩护。1998年，被判处终身监禁，不得保释。</p><figure><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017090906.jpg" alt=""></figure><p>4、</p><p>《论工业社会及其未来》这篇论文值得细细阅读，它对人类现状和未来的分析描述，是非常震撼的。</p><figure><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017090907.jpg" alt=""></figure><p>关于人类的现状，作者的第一句话就是：“工业文明带给人类的是极大的灾难。”</p><blockquote><p>“工业文明极大地增加了发达国家的人口预期寿命，但也破坏了社会的稳定性，令生活空虚无谓，剥夺了人类的尊严，导致了心理疾病的扩散，还严重地破坏了自然界。”</p></blockquote><p>许多人认为，新技术带给人类更大的自由，卡辛斯基的观点正好相反，他认为新技术会剥夺人类的自由。“自由与技术进步不相容，技术越进步，自由越后退。”</p><blockquote><p>“新技术改变社会，最后人们会发现，自己将被强制去使用它。比如，自从有了汽车，城市的布局发生了很大改变，大多数人的住宅已经不在工作场所、购物区和娱乐区的步行距离之内，他们不得不依赖汽车。<strong>人们不再拥有不使用新技术的自由了。</strong>”</p></blockquote><p>一项新技术诞生后，不太可能被拒绝使用，因为“每一项新技术单独考虑都是可取的”，然后人类就会依赖它。</p><blockquote><p>”电力、下水道、无线电话……一个人怎么能反对这些东西呢？怎么能反对数不清的技术进步呢？所有的新技术汇总到一起，就创造出了这样一个世界。<strong>在这个世界中，普通人的命运不再掌握在他自己手中，而是掌握在政客、公司主管、技术人员和官僚手中。</strong>以遗传工程为例。很少人会反对消灭某种遗传病的基因技术，但是大量的基因修改，会使人变成一种人工设计制造的产品，而不是自然的创造物。“</p></blockquote><p>以基因技术为例，如果这种技术变得成熟和普及，那么政府将不得不管制它，因为万一被滥用，后果不堪设想。这样的话，个人就没有选择，只能接受政府管制，其程度将是前所未有，因为政府将可以管到你的基因结构。</p><p>工业社会要想正常运作，必须遵循一整套严格的规则，这导致”现代人都被一张规则之网所笼罩，在所有重要方面，个人的行为都必须服从这些规则。“这导致所有人在本质上都高度类似。</p><blockquote><p>“今天，在技术发达地区，人们的生活方式十分相像。芝加哥的一个基督教银行职员，东京的一个佛教银行职员，莫斯科的一个共产党银行职员，他们彼此之间的日常生活十分相像，而他们的生活与1000年以前人们的生活却非常不同。这就是技术进步的结果……”</p></blockquote><p>最终，“<strong>技术完全控制地球上的一切，人类自由基本上将不复存在，因为个人无法对抗用超级技术武装起来的大型组织。</strong>只有极少数人握有真正的权力，但甚至就连他们的自由也是十分有限的，因为他们的行为也是受到管制的。”</p><p>5、</p><p>丧失自由还不是最可怕的，更糟糕的是，技术最终将取代人类。</p><p>关于人类的未来，卡辛斯基假设“计算机科学家成功地开发出了智能机器，这些机器无论做什么事都比人类强。在这种情况下，大概所有工作都会由巨大的、高度组织化的机器系统去做，而不再需要任何人类的努力。”</p><p>这时可能会有两种情况发生。“一种是允许机器在没有人类监督的情况下，自已做出所有的决策，另一种是人类保留对于机器的控制。”</p><blockquote><p>”如果我们允许机器自己做出所有的决策，人类的命运那时就全凭机器发落了。人们也许会反驳，人类决不会愚蠢到把全部权力都交给机器。但我们既不是说人类会有意将权力交给机器，也不是说机器会存心夺权。我们实际上说的是，人类可能会轻易地让自己沦落到一个完全依赖机器的位置，沦落到不能做出任何实际选择，只能接受机器的所有决策的地步。<strong>随着社会及其面临的问题变得越来越复杂，而机器变得越来越聪明，人们会让机器替他们做更多的决策。仅仅是因为机器做出的决策会比人的决策带来更好的结果。最后，维持体系运行所必需的决策已变得如此之复杂。以至于人类已无能力明智地进行决策。</strong>在这一阶段，机器实质上已处于控制地位。人们已不能把机器关上，因为我们已如此地依赖于机器，关上它们就等于是自杀。”</p></blockquote><p>就算人们想尽办法，保留对机器的控制权，结果也会很糟。</p><blockquote><p>“另一方面，也可能人类还能保持对机器的控制。在这种情况下，一般人也许可以控制自己的私人机器，如他的汽车或计算机，但对于大型机器系统的控制权将落入一小群精英之手——就像今天一样。<strong>由于技术的改进，精英对于大众的控制能力将会极大提高，因为人不再必需工作，大众就成为了多余的人，成为了体系的无用负担。</strong>如果精英集团失去了怜悯心，他们完全可以决定灭绝人类大众。如果他们有些人情味，他们也可以使用宣传或其他心理学或生物学技术降低出生率，直至人类大众自行消亡，让这个世界由精英们独占。”</p><p>“或者，如果精英集团是由软心肠的自由派人士组成的，他们将注意保证每个人的生理需求都得到满足，每一个孩子都在心理十分健康的条件下被抚养成人，每一个人都有一项有益于健康的癖好来打发日子，每一个可能会变得不满的人都会接受治疗以治愈其‘疾病’。<strong>当然，生活是如此没有目的，以致于人们都不得不经过生物学的或心理学的改造，以去除他们的权力欲，或使他们的权力欲‘升华’为无害的癖好。</strong>这些经过改造的人们也许能在这样一个社会中生活得平和愉快，但他们决不会自由。他们将被贬低到家畜的地位。”</p></blockquote><p>6、</p><p>退一步说，如果前面的假设不成立，人工智能没有取得成功，人的工作还是必要的，但是“即使这种情况，机器也将承担越来越多的简单工作，而低能力的工人将越来越过剩（正如我们所见，这种事已经发生了。许多人很难或根本找不到工作，因为他们由于智力或心理原因，而不能达到体系所需要的训练水平）。”</p><blockquote><p>“<strong>对于那些找到工作的人，就业的要求会越来越高。他们将需要越来越多的训练，越来越强的能力，他们将不得不越来越可靠、越来越规矩、越来越驯服，因为他们将越来越像巨型有机体的细胞。</strong>他们的任务将越来越专门化，因而他们的工作在某种意义上也将越来越脱离真实世界，仅集中于现实的一块小碎片。体系将使用一切可以使用的心理学或生物学手段来设计制造人类，使之驯顺，使之具有体系要求的能力。”</p></blockquote><p>机器接管了大部分具有真正重要性的工作以后，留给人类的（或者说普通人有能力从事的）都是一些相对不那么重要的工作。</p><blockquote><p>“例如有人建议，大力发展服务业可以给人类提供工作机会。这样人们就可以把时间花在互相擦皮鞋上面，可以用出租车带着彼此到处瞎转，互相为对方做手工艺品，互相给对方端盘子等等。<strong>人类如果最终以这样的方式结局，那对于我们来说也实在是太可怜了，而且我们怀疑有多少人会觉得这样的无意义的忙碌等同于充实的生活。</strong>他们会去寻找危险的其他渲泄途径（毒品、犯罪、邪教、仇恨群体等），除非他们经过生物学或心理学的设计改造后适应了这种生活方式。”</p></blockquote><p>7、</p><p>卡辛斯基的结论就是，未来要么人类无法幸存下来，要么个人空前地依赖大型组织，空前地“社会化”，人类的生理和心理是设计和改造的结果，而不是自然的产物。</p><p>唯一的解决方法就是放弃科学技术，“把这个腐朽的体系整个扔进垃圾堆，并勇敢地承受其后果。”</p><blockquote><p>“我们希望已经说服了读者，体系无法通过改革来调和自由与技术。唯一的出路是摒弃整个工业-技术体系。这意味着革命，不一定是武装起义，但肯定是激烈而根本的社会性质变化。”</p></blockquote><p>卡辛斯基认为，这个体系是由技术人员为了自己的利益和声望在推动前进。“体系需要科学家、数学家与工程师，否则就无法正常运作。”因此他选择这些人作为袭击目标。这样做当然是邪恶的，但是他对于人类命运的警告却理应受到重视。</p><p>卡辛斯基反复提及，引入新技术一定要慎而又慎。</p><blockquote><p>“<strong>一项新技术被引入社会时，将会引发一长串其他变化，这些变化之中的大部分是不可预见的。</strong>历史经验告诉我们，技术进步给社会带来新问题的速度，远比它解决旧问题的速度要快。技术已将人类带入了一条无法轻易逃脱的死胡同。”</p></blockquote><p>技术会有我们难以预测的长期后果。比如，抗生素的目的是消灭细菌，但是大量使用后却产生了难以杀死的超级细菌，人们不得不限制抗生素的使用；再比如，医疗技术提高了人类的寿命，但也因此导致了地球的人口激增、社会老龄化、生育率下降等重大的社会变化，这些恐怕都不是技术的发明者能想到的。如果新技术（比如机器人技术、基因工程、纳米技术）被恐怖主义组织掌握，后果就更可怕。如果不是真人，而是机器人在街头发动恐怖袭击，那会是怎样的情景？</p><p>距离《论工业社会及其未来》的发表，已经过去了20多年，互联网和人工智能都变成了现实，基因技术开始萌芽。人类对于新技术的入迷简直到了无以复加的地步，恨不得越多越好，一项新技术还在实验室中，人们就开始计划如何尽快形成生产力，占领尽可能多的市场。我们不能不担心，卡辛斯基的预言似乎正一步步变成现实。</p><hr><h2 id="《论工业社会及其未来》原文摘录">《论工业社会及其未来》原文摘录 <a class="markdownIt-Anchor" href="#《论工业社会及其未来》原文摘录">#</a>  <a href="#navbar"><span class="icon"><i class="fa fa-angle-up"></i></span></a></h2><p>工业革命极大增加了城市规模和城市人口比例，而人群聚集会增加压力与攻击性。</p><p>技术变革导致现代社会的变化十分迅速，因此整个社会不存在稳定的框架和价值观。</p><p>有些人急于拯救自由却不愿牺牲技术带来的所谓好处，他们会提出天真的新式社会构想来调和自由与技术。</p><p>所有人都理所当然地认为，每一个人都必需向技术的需要低头，而且理由十分充分：如果人的需求被摆在了优先于技术需要的地位，就会出现经济问题、失业、短缺甚至更糟。在我们的社会当中，“精神健康”的概念主要被定义为在多大程度一个人能够根据体系的需要行事并且不会流露出承受精神压力的迹象。</p><p>经济体系所能容纳的企业数是有限的，我们大多数人只有成为别人的雇员才可以生存。</p><p>工业-技术体系可能幸存也可能崩溃。假如该体系幸存下来，可能最终将会降低生理与心理的痛苦水平，但在此之前必须经历一段漫长而痛苦的调整期，而且人类与众多其他生命体也将付出惨重代价，永远沦为社会机器上的齿轮。更有甚者，假如这个体系幸存下来，将会导致不可避免的后果：没有任何方法能够改革或改进这一体系，使之不至于剥夺人的尊严与自主。</p><p>假如这一体系崩溃，结果依旧会十分痛苦。但是体系规模越大，崩溃造成的结果就越可怕。因此假如真要崩溃的话最好赶早不赶迟。</p><p>所以我们主张发动针对工业体系的革命。这场革命可能使用或不使用暴力，可能突然完成也可能在几十年时间里相对循序渐进地进行。我们无法预测这一点。但是我们的确为那些憎恨工业体系的人们勾勒了一套十分宽泛的方法，从而为反对这一特定社会形式的革命铺平道路。这不是一场政治革命。革命目标并非推翻政府，而是颠覆现存社会的经济与技术基础。</p><p>一般来说科学家都是这样。可能其中也有少数例外，但总体而言他们的动机既不是好奇也不是造福人类，而是完成权力过程的需要。其他动机对于许多科学家来说也有作用，例如金钱与地位。</p><p>科学技术也构成了群体权力运动，许多科学家都通过认同这一运动来满足自己的权力需求。</p><p>因此科学盲目地前进，不考虑人类种族的真正福祉或任何其他标准，仅仅服从科学家以及提供研究资金的政府官员与企业高管的心理需求。</p><p>体系需要科学家、数学家与工程师，否则就无法正常运作。</p><p>遗传工程的伦理规范事实上将成为管制人类遗传构造的手段。一部分人（多半是上层阶级）将决定如此这般的遗传工程合乎“道德”，如此这般的做法则不道德，因而他们将在实际上将自己的价值观强加于整个人口的遗传构造。即使伦理规范是以完全民主的方式选择出来的，多数族裔也会将他们自己的价值观强加于那些很可能对于如何 “道德地”运用遗传工程另有看法的少数族裔。真正能够保护自由的伦理规范只能是一条，那就是禁止任何人类遗传工程。而我们可以十分有把握地说，这一点恰恰不可能在技术社会中得到实现。任何将遗传工程贬低成配角的规范都不可能维持下去，因为生物技术的巨大力量所产生的诱惑是无法抗拒的。特别是在大多数人看来，大量生物技术的应用显然且肯定是有益的（可以根除身体与精神疾病，赋予人们当今世界所需要的能力）。基因技术必将不可避免地得到大规模应用，但应用方式只能与工业-技术体系的需求相一致。</p><p>技术之所以是如此强有力的社会力量的另一个理由是，在给定社会的条件下技术进步只会不可逆地朝一个方向前进。只要某项技术发明被引进，人们就往往会对其产生依赖，除非它被某种更先进的发明所取代。人们不仅仅作为个人依赖这项新技术。甚至体系作为一个整体都会依赖它。（例如请想像一下，如果没有了计算机，今天的体系会怎么样）因此，体系只能朝向更加技术化的方向移动。在不至于颠覆整个技术体系的前提下，技术将会不断地逼迫自由后退。</p><p>技术的进步十分迅速并在许多方面威胁自由（拥挤、规章制度、个人对于大型组织越发严重的依赖、宣传与其他心理学技术、遗传工程、通过监视设备和计算机侵犯隐私，等等），阻挡任何一项对于自由的威胁都需要一场单独的社会斗争。那些想要保卫自由的人会被无数的新攻势及其发展速度所压倒，他们会变得微不足道并停止抵抗。分别反击这些威胁是无效的。只有把技术体系作为一个整体来反击才有成功的希望，但这就是革命而不是改革了。</p><p>人们倾向于想当然地认为，由于革命带来的变化比改革大，所以革命也就比改革更难发动。实际上，在某些条件下革命比改革容易得多。这是因为一场革命运动能够激发出人们极大的献身热情，而一场改革运动却不能。一场革命运动许诺一下子解决所有问题并创造整个新世界；它提供人民为之甘冒风险、甘作牺牲的理想。由于这些理由，推翻整个技术体系要比对技术的某一部分——如遗传工程的应用发展——进行有效、持久的限制容易得多。在适当的条件下，许许多多的人会热情地献身于推翻工业技术体系的革命。正如我们提到的那样，寻求限制技术的某些方面的改革者是为了避免不良后果而工作。然而，革命者是为了获得强力的报偿——实现其革命理想——而工作，因此他们比改革者更努力且更执著。</p><p>现代社会不是去改变那些使人们抑郁的条件，而是给人们抗抑郁药。</p><p>但另一方面，请假设今后几十年的压力超出了体系的承受能力。如果体系崩溃，可能会有一个混乱时期，“动乱年代”，就像在过去各个时代历史所记载的那样。不可能预见动乱年代最后会产生什么结果。但无论如何人类会被赋予一个新机会。最大的危险是工业化社会很可能在崩溃后不几年就开始重组其自身，肯定会有许多人（特别是权力饥渴型的人们）急于重新开动工厂。</p><p>工业体系将人类贬低到了被奴役的状态，而憎恨这种被奴役状态的人则面临两个任务。第一，我们必须增强体系内的社会紧张态势，以加快其崩溃或把它弱化到足够程度，使得反对体系的革命成为可能。第二，当体系充分弱化时，我们必须发展并宣传一种反对技术和工业社会的意识形态。当工业社会崩溃时，这种意识形态将有助于保证其残余被粉碎到无法修复的地步，这样体系就无法重组。工厂将被捣毁，技术书籍将被烧掉，等等。</p><p>工业体系的崩溃不会纯粹是革命行动的结果，它不会那么难以抵御革命的攻击，除非它自身内部的发展问题导致了极为严重的困难。因此如果体系崩溃，那么它或是自发崩溃，或是部分自发、部分由革命者促发的崩溃。如果崩溃是突如其来的，许多人都会死去，因为世界人口已如此过分膨胀，离开了先进技术就无法养活自己。甚至即使崩溃足够缓慢，人口的减少可以主要通过出生率的降低而不是死亡率的提高而实现，非工业化的过程也多半是极度混乱和极度痛苦的。幻想通过平稳控制的有序方式逐步废除技术是天真的，特别是要考虑到技术爱好者们的负隅顽抗。那么，致力于体系的崩溃是否因此就十分残酷呢？也许是，也许不是。首先，除非体系本来就已经陷入了深重的困难，无论如何都很可能最终自行崩溃，否者单靠革命者是不可能强行使其崩溃的。而且体系发展得规模越大，崩溃的后果就越严重。因此加速体系崩溃的革命者或许反倒控制了灾难的规模。</p><p>其次，我们必须权衡斗争与死亡和丧失自由与尊严这两方面的得失。对于我们之中的许多人来说，自由与尊严比长寿和避免肉体痛苦更重要。再者，我们早晚会死，死于为生存或为某一事业而战，强于活得空虚而无目的。</p><p>第三，体系的存续所带来的痛苦并不一定就比体系崩溃所带来的痛苦更少。在全世界范围内，体系已经招致、并且正在招致的巨大痛苦曾使人类千百年与他人以及环境和睦相处的古代文化被与其解接触的工业社会所摧毁。其结果就是全方位的经济、环境、社会和心理问题。工业社会的侵扰所产生的影响之一，就是传统的人口控制在全球范围内一下子失去了平衡，因而产生了人口爆炸及其所有连带后果。接着就是心理疾病席卷了整个所谓“幸运”的西方社会。没有人知道臭氧层耗尽、温室效应及其他现在还不能预测的环境问题最终会为这个世界带来怎样的后果。而且就像核扩散已经显示的那样，我们无法防止新技术落入独裁者和不负责任的第三世界国家手中。愿意猜猜伊位克或北朝鲜将用遗传工程来干什么吗?</p><p>“嗨！”技术爱好者们会说，“科学能解决所有这些问题！我们将征服饥荒、消灭心理病痛，让每一个人都健康而快乐！”是的，是的。他们200年前就是这么说的。人们曾指望工业社会能够消灭贫穷，使每一个人都快乐，等等。实际结果却不是那么回事。技术爱好者对社会问题的理解简直是无可救药地天真（或自欺欺人）。他们没有意识到（或故意视而不见）这样一个事实：当巨大的变化，即使是看上去有利的变化，被引入一个社会时，将会引发一长串其他变化，这些变化之中的大都分是不可预见的其结果则是社会的混乱。因此，技术爱好者们在试图消灭贫穷和疾病，设计制造驯顺、快乐的人格等等时，很可能会创造出比现在还糟糕的社会体系。例如，科学家们吹嘘说他们能够创造出新的、经遗传工程改造的粮食植物以消灭饥荒。然而，这将会允许人口无限膨胀下去，而众所周知，拥挤会导致紧张和攻击性的增强。这仅仅是技术会导致的可预见问题中的一个例子。我们强调指出，历史经验告诉我们，技术进步给社会带来新问题的速度远比它解决旧问题的速度要快。因此技术爱好者们要经过一个漫长的试错时期才能够为他们的美丽新世界排除掉所有的故障（假设他们最终能做到的话）。而与此同时所产生的痛苦将会如此巨大，以至于体系生存下去所带来的痛苦不见得就比体系崩溃更少。技术己将人类带入了一条无法轻易逃脱的死胡同。</p><p>更好的办法是把这个腐朽的体系整个扔进垃圾堆，并勇敢地承受其后果。</p><p>现在的两个主要任务是在工业社会中促进社会紧张与不稳定，以及宣传一种反对技术和工业体系的意识形态。当体系变得足够紧张和不稳定时，一场反对技术的革命就有机会发动了。这一模式将十分类似于法国和俄国革命。在两国各自革命之前的几十年里，法国和俄国社会都显示出了越来越多的紧张与脆弱迹象。同时，提供一个与旧世界完全不同的新世界愿景的意识形态发展了起来。以俄国的情况为例，革命者积极从事于破坏旧秩序的工作。然后当旧体系面临着足够的额外紧张时（法国是财政危机，俄国是军事失败），它就会被革命一扫而光。我们预想的就是这样的道路。</p><p>大多数革命都有两个目标，一个目标是摧毁一个旧社会，另一个目标是建立革命者想像的新社会。法国和俄国的革命者没有能够成功地建立他们所梦想的新社会（这是十分幸运的事），但她们非常成功地摧毁了既存社会。</p><p>然而，一种意识形态如想争取到热情支持，除了负面理想外必须还有正面理想，决不能只破不立。我们的正面理想是自然，即野生自然，按照其本来面目运行的地球，不依赖于人类管理、摆脱人类干涉和控制的地球生灵。我们的野生自然也包括人类本性，即不受有组织社会管制、自主运行的个人，成为偶然性或自由意志或上帝（由你的宗教或哲学观念）的产物。</p><p>一个社会的经济与技术结构在决定一般人的生活方式方面远比政治结构更加重要。</p><p>我们不应主张无力或消极，我们应主张打破工业体系的权力，而这将大大增加个人和小群体的权力和自由。</p><p>（据称）贯穿整个历史，技术都是进步的，从未退步过，因此技术退步是不可能的。但这并非事实。对于“进步”的热情是现代社会形态的特殊现象，在大约十七世纪之前并不存在。</p></article>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <tags>
        <tag>摘录笔记：阮一峰</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo主题themes/主题文件夹 无法提交到自己Git的原因以及解决办法</title>
    <url>/2023/06/13/hexo%E4%B8%BB%E9%A2%98%E6%96%87%E4%BB%B6%E5%A4%B9%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<div id="readmore-container"><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>主要还是因为<code>themes/ocean</code>也是从仓库里拉取下来的 他关联到了作者的git仓库 所以提交不上去</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>只要删除对应主题文件夹的<code>.git</code>文件即可；<br>这样就可以在任意电脑clone文件，就可以发布你的博客文章了；</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>ocean</tag>
      </tags>
  </entry>
  <entry>
    <title>两行 js 实现 html 全自动翻译。 无需改动页面、无语言配置文件、无 API Key、对 SEO 友好！</title>
    <url>/2023/06/12/JS%E7%BD%91%E9%A1%B5%E5%85%A8%E8%87%AA%E5%8A%A8%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<div id="readmore-container"><h3 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h3><p>两行 js 实现 html 全自动翻译。 无需改动页面、无语言配置文件、无 API Key、对 SEO 友好！</p>
<h3 id="在线体验"><a href="#在线体验" class="headerlink" title="在线体验"></a>在线体验</h3><p><a href="http://res.zvo.cn/translate/demo.html">http://res.zvo.cn/translate/demo.html</a></p>
<h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>在你的网页最末尾，<code>&lt;/html&gt;</code> 之前，加入以下代码，会在页面的最底部出现选择语言的标签：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://res.zvo.cn/translate/translate.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">translate.<span class="title function_">setUseVersion2</span>(); <span class="comment">//设置使用v2.x 版本</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">translate.<span class="property">language</span>.<span class="title function_">setLocal</span>(<span class="string">&#x27;chinese_simplified&#x27;</span>); <span class="comment">//设置本地语种（当前网页的语种）。如果不设置，默认就是 &#x27;chinese_simplified&#x27; 简体中文。 可填写如 &#x27;english&#x27;、&#x27;chinese_simplified&#x27; 等，具体参见文档下方关于此的说明。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">translate.<span class="title function_">execute</span>();<span class="comment">//进行翻译 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <tags>
        <tag>js</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>测试是否可以创建中文</title>
    <url>/2023/06/09/%E6%B5%8B%E8%AF%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<div id="readmore-container"><p>经过测试，结论是可以创建中文.md</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <tags>
        <tag>中文</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员舍不得删除的软件/插件/工具推荐（持续更新）</title>
    <url>/2023/06/09/%E8%BD%AF%E4%BB%B6-%E6%8F%92%E4%BB%B6-%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<div id="readmore-container"><p>最近摸鱼，突然就想总结一下遇到的那些好用的工具助手之类的软件，同时欢迎路过的兄弟姐妹补充。</p>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul>
<li><p><a href="https://ttime.timerecord.cn/">TTime</a>：一款简洁、高效、高颜值的输入、截图、划词<strong>翻译软件</strong>。<br><a href="https://ttime.timerecord.cn/">QtScrcpy</a>：可以通过 USB &#x2F; 网络<strong>连接Android设备</strong>，并进行显示和控制。无需root权限。<br>同时支持 GNU&#x2F;Linux ，Windows 和 MacOS 三大主流桌面平台。<br>它专注于:</p>
<ul>
<li>精致 (仅显示设备屏幕)</li>
<li>性能 (30~60fps)</li>
<li>质量 (1920×1080以上)</li>
<li>低延迟 (35~70ms)</li>
<li>快速启动 (1s 内就可以看到第一帧图像)</li>
<li>非侵入性 (不在设备上安装任何软件)</li>
</ul>
</li>
<li><p><a href="https://github.com/docmirror/dev-sidecar/releases">dev-sidecar</a>：开发者边车，命名取自service-mesh的service-sidecar，意为为开发者打辅助的边车工具（以下简称ds）通过<strong>本地代理</strong>的方式将https请求代理到一些国内的<strong>加速通道</strong>上;简称<strong>github加速</strong>。github打不开可尝试  <a href="https://www.aliyundrive.com/s/fYxthYeWtHJ">阿里云盘 分享链接</a></p>
</li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul>
<li><a href="https://monica.im/?c=4C8VFNRV">monica</a>：您的 ChatGPT AI 智能助理适用于所有网站<strong>浏览器插件</strong>。</li>
<li><a href="https://github.com/adamyi/wechrome">WeChrome</a>: WeChrome 是用于解除微信网页版登录限制的 Chrome 插件。<br>如果你登录微信网页版时，出现如下提示<code>为了保护您的帐户，已暂停通过网络登录微信。</code>，可使用该插件来绕过限制。</li>
<li><a href="https://www.tampermonkey.net/index.php?locale=zh_CN">篡改猴 (Tampermonkey)</a> 是拥有 超过 1000 万用户 的最流行的浏览器扩展之一。 它适用于 Chrome、Microsoft Edge、Safari、Opera Next 和 Firefox。它允许用户自定义并增强您最喜爱的网页的功能。用户脚本是小型 JavaScript 程序，可用于向网页添加新功能或修改现有功能。使用 篡改猴，您可以轻松在任何网站上创建、<strong>管理和运行这些用户脚本</strong>!<img src="/2023/06/09/%E8%BD%AF%E4%BB%B6-%E6%8F%92%E4%BB%B6-%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/img.png" class="" title="以上是本人添加的部分脚本"></li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a href="https://www.007chatgpt.com/">零零七ChatGPT</a>：完全免费的一款chatgpt<strong>在线工具</strong>。</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <tags>
        <tag>软件</tag>
        <tag>工具</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 GitHub Pages + Hexo 搭建个人博客</title>
    <url>/2023/06/08/my-blog-build-remark/</url>
    <content><![CDATA[<div id="readmore-container"><img src="/2023/06/08/my-blog-build-remark/img.png" class="" title="头部">
<h1 id="PersonalBlog"><a href="#PersonalBlog" class="headerlink" title="PersonalBlog"></a>PersonalBlog</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>基于 Github Pages + Hexo 的方式，搭建个人博客。<br>本站参考链接<a href="https://my.oschina.net/u/5057806/blog/5602898">白嫖 GitHub Pages，轻松搭建个人博客</a></p>
<h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h4><p>软件架构说明<br>Hexo 是一个快速、简单且功能强大的博客框架。使用 Markdown 解析文档，Hexo 能在几秒内生成带有自定义主题并集成各项功能的网站页面。</p>
<h4 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h4><ol>
<li>全局安装 hexo-cli 工具</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v # 查看版本，目前最新版本为 4.3.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个项目 my-blog 并初始化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line">cd my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>生成网页文件 &amp; 本地启动</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate # 生成页面，此命令可以简写为 `hexo g`</span><br><span class="line">hexo server # 本地启动，可简写为 `hexo s`</span><br></pre></td></tr></table></figure>

<p>通过 hexo g 生成的页面文件在项目 public 目录下；<br>使用 hexo clean 命令可以清理生成的页面文件。当配置未生效时，建议执行清理命令。</p>
<ol start="4">
<li>本地访问</li>
</ol>
<p>浏览器访问：<a href="http://localhost:4000/">http://localhost:4000/</a> 会看到一个比较简陋的页面。</p>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol>
<li>创建「关于页」<br>首次使用主题的「关于页」需要手动创建。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<p>创建成功后修改 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。修改后的文件示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标题</span><br><span class="line">layout: about</span><br><span class="line">---</span><br><span class="line">这里写关于页的正文，支持 Markdown, HTML</span><br></pre></td></tr></table></figure>

<p>需要注意的是， layout: about 必须存在，并且不能修改成其他值，否则不会显示头像等样式。</p>
<ol start="2">
<li>创建文章<br>修改 _config.yml 文件。这项配置是为了在生成文章的同时，生成一个同名的资源目录用于存放图片等资源文件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>

<p>创建文件名为 my-blog-build-remark 文章。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post my-blog-build-remark</span><br></pre></td></tr></table></figure>

<p>设置文章的标题及其他元数据信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于 GitHub Pages + Hexo 搭建个人博客</span><br><span class="line">date: 2022-10-16 19:42:53</span><br><span class="line">tags: [&#x27;hexo&#x27;,&#x27;fluid&#x27;]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如上命令执行成功后，在 source&#x2F;_posts&#x2F; 目录下生成了一个 Markdown 文件和一个同名的资源目录。</p>
<p>在 source&#x2F;_posts&#x2F;my-blog-build-remark 目录中放置一个图片文件 posts-file-tree.png，整体目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source/_posts (main)&gt; tree</span><br><span class="line">.</span><br><span class="line">├── hello-world.md</span><br><span class="line">├── my-blog-build-remark</span><br><span class="line">│   └── posts-file-tree.png</span><br><span class="line">└── my-blog-build-remark.md</span><br></pre></td></tr></table></figure>

<p>然后在文章的 Markdown 文件里，通过以下方式即可引用对应的图片。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img posts-file-tree.png 目录结构 %&#125;</span><br></pre></td></tr></table></figure>

<p>图片的引用方式也不只一种，更多详细介绍可参考官方文档 (<a href="https://hexo.io/zh-cn/docs/asset-folders.html)%E3%80%82">https://hexo.io/zh-cn/docs/asset-folders.html)。</a></p>
<p>文章创建并编辑好之后，就可以通过 hexo g &amp;&amp; hexo s 命令启动服务，并在本地预览文章。</p>
<ol start="3">
<li>本地启动<br>执行如下命令重新生成页面，并启动 Hexo 服务。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h5 id="发布-GitHub-Pages"><a href="#发布-GitHub-Pages" class="headerlink" title="发布 GitHub Pages"></a>发布 GitHub Pages</h5><ol>
<li>安装 hexo-deployer-git。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改站点配置 _config.yml。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: &lt;repository url&gt; # https://github.com/&lt;GitHub用户名&gt;/&lt;GitHub用户名&gt;.github.io.git</span><br><span class="line">branch: [branch]</span><br><span class="line">token: [token]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>生成站点文件并推送至远程 GitHub 仓库。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>登入 Github，在库设置（Repository Settings）中将默认分支设置为 _config.yml 配置中的分支名称。<br>只需稍等片刻，个人博客站点就会显示在 Github Pages 中。</p>
<p>个人博客的主页访问地址：https:&#x2F;&#x2F;&lt;GitHub 用户名&gt;.github.io。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
</search>
