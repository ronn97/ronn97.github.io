<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--  bing搜索-->
  <meta name="msvalidate.01" content="C978CEE5B035402910AAC2FD1C19716D" />
  
  
  
  <meta name="description" content="个人博客">
  
  <title>
    
    没有梦想的程序员
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>


  
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4620209531301821" crossorigin="anonymous"></script>
  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="没有梦想的程序员" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">没有梦想的程序员</a></h1>
      <p>爱前端 | 爱挖坑 | 爱折腾 | 爱生活</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="没有梦想的程序员"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-ts-operator" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-operator/">TypeScript 类型运算符</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-operator/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><p>TypeScript 提供强大的类型运算能力，可以使用各种类型运算符，对已有的类型进行计算，得到新类型。</p>
<h2 id="keyof-运算符"><a href="#keyof-运算符" class="headerlink" title="keyof 运算符"></a>keyof 运算符</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>keyof 是一个单目运算符，接受一个对象类型作为参数，返回该对象的所有键名组成的联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = keyof <span class="title class_">MyObj</span>; <span class="comment">// &#x27;foo&#x27;|&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>keyof MyObj</code>返回<code>MyObj</code>的所有键名组成的联合类型，即<code>&#39;foo&#39;|&#39;bar&#39;</code>。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">b</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof T; <span class="comment">// 0 | &#x27;a&#x27; | &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于 JavaScript 对象的键名只有三种类型，所以对于任意对象的键名的联合类型就是<code>string|number|symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string | number | symbol</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>对于没有自定义键名的类型使用 keyof 运算符，返回<code>never</code>类型，表示不可能有这样类型的键名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof <span class="built_in">object</span>;  <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，由于<code>object</code>类型没有自身的属性，也就没有键名，所以<code>keyof object</code>返回<code>never</code>类型。</p>
<p>由于 keyof 返回的类型是<code>string|number|symbol</code>，如果有些场合只需要其中的一种类型，那么可以采用交叉类型的写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Capital</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="title class_">Capitalize</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyKeys</span>&lt;<span class="title class_">Obj</span> <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = <span class="title class_">Capital</span>&lt;keyof <span class="title class_">Obj</span>&gt;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Capital</code>只接受字符串作为类型参数，传入<code>keyof Obj</code>会报错，原因是这时的类型参数是<code>string|number|symbol</code>，跟字符串不兼容。采用下面的交叉类型写法，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyKeys</span>&lt;<span class="title class_">Obj</span> <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = <span class="title class_">Capital</span>&lt;<span class="built_in">string</span> &amp; keyof <span class="title class_">Obj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>string &amp; keyof Obj</code>等同于<code>string &amp; string|number|symbol</code>进行交集运算，最后返回<code>string</code>，因此<code>Capital&lt;T extends string&gt;</code>就不会报错了。</p>
<p>如果对象属性名采用索引形式，keyof 会返回属性名的索引类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string|number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof T;</span><br></pre></td></tr></table></figure>

<p>上面的示例二，<code>keyof T</code>返回的类型是<code>string|number</code>，原因是 JavaScript 属性名为字符串时，包含了属性名为数值的情况，因为数值属性名会自动转为字符串。</p>
<p>如果 keyof 运算符用于数组或元组类型，得到的结果可能出人意料。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = keyof [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// 返回 number | &quot;0&quot; | &quot;1&quot; | &quot;2&quot;</span></span><br><span class="line"><span class="comment">// | &quot;length&quot; | &quot;pop&quot; | &quot;push&quot; | ···</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，keyof 会返回数组的所有键名，包括数字键名和继承的键名。</p>
<p>对于联合类型，keyof 返回成员共有的键名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 &#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof (A | B);</span><br></pre></td></tr></table></figure>

<p>对于交叉类型，keyof 返回所有键名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">x</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 &#x27;a&#x27; | &#x27;x&#x27; | &#x27;b&#x27; | &#x27;y&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof (A &amp; B);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">keyof (A &amp; B) ≡ keyof A | keyof B</span><br></pre></td></tr></table></figure>

<p>keyof 取出的是键名组成的联合类型，如果想取出键值组成的联合类型，可以像下面这样写。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = keyof <span class="title class_">MyObj</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Values</span> = <span class="title class_">MyObj</span>[<span class="title class_">Keys</span>]; <span class="comment">// number|string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Keys</code>是键名组成的联合类型，而<code>MyObj[Keys]</code>会取出每个键名对应的键值类型，组成一个新的联合类型，即<code>number|string</code>。</p>
<h3 id="keyof-运算符的用途"><a href="#keyof-运算符的用途" class="headerlink" title="keyof 运算符的用途"></a>keyof 运算符的用途</h3><p>keyof 运算符往往用于精确表达对象的属性类型。</p>
<p>举例来说，取出对象的某个指定属性的值，JavaScript 版本可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">prop</span>(<span class="params">obj, key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数添加类型，只能写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">prop</span>(<span class="params"></span></span><br><span class="line"><span class="params">  obj: &#123; [p:string]: any &#125;,</span></span><br><span class="line"><span class="params">  key: string</span></span><br><span class="line"><span class="params"></span>):any &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的类型声明有两个问题，一是无法表示参数<code>key</code>与参数<code>obj</code>之间的关系，二是返回值类型只能写成<code>any</code>。</p>
<p>有了 keyof 以后，就可以解决这两个问题，精确表达返回值类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> prop&lt;<span class="title class_">Obj</span>, K <span class="keyword">extends</span> keyof <span class="title class_">Obj</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>:<span class="title class_">Obj</span>, <span class="attr">key</span>:K</span><br><span class="line">):<span class="title class_">Obj</span>[K] &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>K extends keyof Obj</code>表示<code>K</code>是<code>Obj</code>的一个属性名，传入其他字符串会报错。返回值类型<code>Obj[K]</code>就表示<code>K</code>这个属性值的类型。</p>
<p>keyof 的另一个用途是用于属性映射，即将一个类型的所有属性逐一映射成其他值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NewProps</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123; <span class="attr">foo</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于 &#123; foo: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">NewProps</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>NewProps</code>是类型<code>Obj</code>的映射类型，前者继承了后者的所有属性，但是把所有属性值类型都改成了<code>boolean</code>。</p>
<p>下面的例子是去掉 readonly 修饰符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]: <span class="title class_">Obj</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于 &#123; foo: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">Mutable</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[Prop in keyof Obj]</code>是<code>Obj</code>类型的所有属性名，<code>-readonly</code>表示去除这些属性的只读特性。对应地，还有<code>+readonly</code>的写法，表示添加只读属性设置。</p>
<p>下面的例子是让可选属性变成必有的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]-?: <span class="title class_">Obj</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  foo?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于 &#123; foo: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">Concrete</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[Prop in keyof Obj]</code>后面的<code>-?</code>表示去除可选属性设置。对应地，还有<code>+?</code>的写法，表示添加可选属性设置。</p>
<h2 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h2><p>JavaScript 语言中，<code>in</code>运算符用来确定对象是否包含某个属性名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> obj)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;found a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>in</code>运算符用来判断对象<code>obj</code>是否包含属性<code>a</code>。</p>
<p><code>in</code>运算符的左侧是一个字符串，表示属性名，右侧是一个对象。它的返回值是一个布尔值。</p>
<p>TypeScript 语言的类型运算中，<code>in</code>运算符有不同的用法，用来取出（遍历）联合类型的每一个成员类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> U = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> U]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[Prop in U]</code>表示依次取出联合类型<code>U</code>的每一个成员。</p>
<p>上一小节的例子也提到，<code>[Prop in keyof Obj]</code>表示取出对象<code>Obj</code>的每一个键名。</p>
<h2 id="方括号运算符"><a href="#方括号运算符" class="headerlink" title="方括号运算符"></a>方括号运算符</h2><p>方括号运算符（<code>[]</code>）用于取出对象的键值类型，比如<code>T[K]</code>会返回对象<code>T</code>的属性<code>K</code>的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">alive</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Age 的类型是 number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Person[&#39;age&#39;]</code>返回属性<code>age</code>的类型，本例是<code>number</code>。</p>
<p>方括号的参数如果是联合类型，那么返回的也是联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">alive</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number|string</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Person</span>[<span class="string">&#x27;age&#x27;</span>|<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// number|string|boolean</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Person</span>[keyof <span class="title class_">Person</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，方括号里面是属性名的联合类型，所以返回的也是对应的属性值的联合类型。</p>
<p>如果访问不存在的属性，会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="title class_">Person</span>[<span class="string">&#x27;notExisted&#x27;</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>方括号运算符的参数也可以是属性名的索引类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>:<span class="built_in">string</span>]: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Obj</span>[<span class="built_in">string</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Obj</code>的属性名是字符串的索引类型，所以可以写成<code>Obj[string]</code>，代表所有字符串属性名，返回的就是它们的类型<code>number</code>。</p>
<p>这个语法对于数组也适用，可以使用<code>number</code>作为方括号的参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyArray 的类型是 &#123; [key:number]: string &#125;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyArray</span> = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 (typeof MyArray)[number]</span></span><br><span class="line"><span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>MyArray</code>是一个数组，它的类型实际上是属性名的数值索引，而<code>typeof MyArray[number]</code>的<code>typeof</code>运算优先级高于方括号，所以返回的是所有数值键名的键值类型<code>string</code>。</p>
<p>注意，方括号里面不能有值的运算。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key]; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;g&#x27;</span> + <span class="string">&#x27;e&#x27;</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面两个示例，方括号里面都涉及值的运算，编译时不会进行这种运算，所以会报错。</p>
<h2 id="extends…-条件运算符"><a href="#extends…-条件运算符" class="headerlink" title="extends…?: 条件运算符"></a>extends…?: 条件运算符</h2><p>TypeScript 提供类似 JavaScript 的<code>?:</code>运算符这样的三元运算符，但多出了一个<code>extends</code>关键字。</p>
<p>条件运算符<code>extends...?:</code>可以根据当前类型是否符合某种条件，返回不同的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>

<p>上面式子中的<code>extends</code>用来判断，类型<code>T</code>是否可以赋值给类型<code>U</code>，即<code>T</code>是否为<code>U</code>的子类型，这里的<code>T</code>和<code>U</code>可以是任意类型。</p>
<p>如果<code>T</code>能够赋值给类型<code>U</code>，表达式的结果为类型<code>X</code>，否则结果为类型<code>Y</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="number">1</span> <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>1</code>是<code>number</code>的子类型，所以返回<code>true</code>。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">live</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">woof</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">RegExp</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Dog</code>是<code>Animal</code>的子类型，所以<code>T1</code>的类型是<code>number</code>。<code>RegExp</code>不是<code>Animal</code>的子类型，所以<code>T2</code>的类型是<code>string</code>。</p>
<p>一般来说，调换<code>extends</code>两侧类型，会返回相反的结果。举例来说，有两个类<code>Cat</code>和<code>Animal</code>，前者是后者的子类型，那么<code>Cat extends Animal</code>就为真，而<code>Animal extends Cat</code>就为伪。</p>
<p>如果需要判断的类型是一个联合类型，那么条件运算符会展开这个联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(A|B) <span class="keyword">extends</span> U ? X : Y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">(A <span class="keyword">extends</span> U ? X : Y) |</span><br><span class="line">(B <span class="keyword">extends</span> U ? X : Y)</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A|B</code>是一个联合类型，进行条件运算时，相当于<code>A</code>和<code>B</code>分别进行运算符，返回结果组成一个联合类型。</p>
<p>如果不希望联合类型被条件运算符展开，可以把<code>extends</code>两侧的操作数都放在方括号里面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string[]|number[]</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  [<span class="title class_">Type</span>] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (string | number)[]</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面的示例一，传入<code>ToArray&lt;Type&gt;</code>的类型参数是一个联合类型，所以会被展开，返回的也是联合类型。示例二是<code>extends</code>两侧的运算数都放在方括号里面，所以传入的联合类型不会展开，返回的是一个数组。</p>
<p>条件运算符还可以嵌套使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LiteralTypeName</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">bigint</span> ? <span class="string">&quot;bigint&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">  <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例是一个多重判断，返回一个字符串的值类型，对应当前类型。下面是它的用法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result1</span> = <span class="title class_">LiteralTypeName</span>&lt;<span class="number">123n</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;string&quot; | &quot;number&quot; | &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result2</span> = <span class="title class_">LiteralTypeName</span>&lt;<span class="literal">true</span> | <span class="number">1</span> | <span class="string">&#x27;a&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="infer-关键字"><a href="#infer-关键字" class="headerlink" title="infer 关键字"></a>infer 关键字</h2><p><code>infer</code>关键字用来定义泛型里面推断出来的类型参数，而不是外部传入的类型参数。</p>
<p>它通常跟条件运算符一起使用，用在<code>extends</code>关键字后面的父类型之中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>infer Item</code>表示<code>Item</code>这个参数是 TypeScript 自己推断出来的，不用显式传入，而<code>Flatten&lt;Type&gt;</code>则表示<code>Type</code>这个类型参数是外部传入的。<code>Type extends Array&lt;infer Item&gt;</code>则表示，如果参数<code>Type</code>是一个数组，那么就将该数组的成员类型推断为<code>Item</code>，即<code>Item</code>是从<code>Type</code>推断出来的。</p>
<p>一旦使用<code>Infer Item</code>定义了<code>Item</code>，后面的代码就可以直接调用<code>Item</code>了。下面是上例的泛型<code>Flatten&lt;Type&gt;</code>的用法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">string</span>[]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，第一个例子<code>Flatten&lt;string[]&gt;</code>传入的类型参数是<code>string[]</code>，可以推断出<code>Item</code>的类型是<code>string</code>，所以返回的是<code>string</code>。第二个例子<code>Flatten&lt;number&gt;</code>传入的类型参数是<code>number</code>，它不是数组，所以直接返回自身。</p>
<p>如果不用<code>infer</code>定义类型参数，那么就要传入两个类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>, <span class="title class_">Item</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure>

<p>上面是不使用<code>infer</code>的写法，每次调用<code>Fleatten</code>的时候，都要传入两个参数，就比较麻烦。</p>
<p>下面的例子使用<code>infer</code>，推断函数的参数类型和返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnPromise</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer A) =&gt; infer R </span><br><span class="line">  ? <span class="function">(<span class="params">...args: A</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;R&gt; </span><br><span class="line">  : T;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果<code>T</code>是函数，就返回这个函数的 Promise 版本，否则原样返回。<code>infer A</code>表示该函数的参数类型为<code>A</code>，<code>infer R</code>表示该函数的返回值类型为<code>R</code>。</p>
<p>如果不使用<code>infer</code>，就不得不把<code>ReturnPromise&lt;T&gt;</code>写成<code>ReturnPromise&lt;T, A, R&gt;</code>，这样就很麻烦，相当于开发者必须人肉推断编译器可以完成的工作。</p>
<p>下面是<code>infer</code>提取对象指定属性的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: infer M,</span><br><span class="line">    <span class="attr">b</span>: infer N</span><br><span class="line">  &#125; ? [M, N] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法示例</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">MyType</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span> &#125;&gt;;</span><br><span class="line"><span class="comment">// [string, number]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>infer</code>提取了参数对象的属性<code>a</code>和属性<code>b</code>的类型。</p>
<p>下面是<code>infer</code>通过正则匹配提取类型参数的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="string">&#x27;foo-bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Str</span> <span class="keyword">extends</span> <span class="string">`foo-<span class="subst">$&#123;infer rest&#125;</span>`</span> ? rest : <span class="built_in">never</span> <span class="comment">// &#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>rest</code>是从模板字符串提取的类型参数。</p>
<h2 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h2><p>函数返回布尔值的时候，可以使用<code>is</code>运算符，限定返回值与参数之间的关系。</p>
<p><code>is</code>运算符用来描述返回值属于<code>true</code>还是<code>false</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params"></span></span><br><span class="line"><span class="params">  pet: Fish|Bird</span></span><br><span class="line"><span class="params"></span>):pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isFish()</code>的返回值类型为<code>pet is Fish</code>，表示如果参数<code>pet</code>类型为<code>Fish</code>，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p><code>is</code>运算符总是用于描述函数的返回值类型，写法采用<code>parameterName is Type</code>的形式，即左侧为当前函数的参数名，右侧为某一种类型。它返回一个布尔值，表示左侧参数是否属于右侧的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isTypeA</span>(<span class="params">x: A|B</span>): x is A &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，返回值类型<code>x is A</code>可以准确描述函数体内部的运算逻辑。</p>
<p><code>is</code>运算符可以用于类型保护。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isCat</span>(<span class="params">a:<span class="built_in">any</span></span>): a is <span class="title class_">Cat</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">name</span> === <span class="string">&#x27;kitty&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="title class_">Cat</span>|<span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isCat</span>(x)) &#123;</span><br><span class="line">  x.<span class="title function_">meow</span>(); <span class="comment">// 正确，因为 x 肯定是 Cat 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isCat()</code>的返回类型是<code>a is Cat</code>，它是一个布尔值。后面的<code>if</code>语句就用这个返回值进行判断，从而起到类型保护的作用，确保<code>x</code>是 Cat 类型，从而<code>x.meow()</code>不会报错（假定<code>Cat</code>类型拥有<code>meow()</code>方法）。</p>
<p><code>is</code>运算符还有一种特殊用法，就是用在类（class）的内部，描述类的方法的返回值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="title function_">isStudent</span>():<span class="variable language_">this</span> is <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">isStudent</span>():<span class="variable language_">this</span> is <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>isStudent()</code>方法的返回值类型，取决于该方法内部的<code>this</code>是否为<code>Student</code>对象。如果是的，就返回布尔值<code>true</code>，否则返回<code>false</code>。</p>
<p>注意，<code>this is T</code>这种写法，只能用来描述方法的返回值类型，而不能用来描述属性的类型。</p>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>TypeScript 允许使用模板字符串，构建类型。</p>
<p>模板字符串的最大特点，就是内部可以引用其他类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Greeting</code>是一个模板字符串，里面引用了另一个字符串类型<code>world</code>，因此<code>Greeting</code>实际上是字符串<code>hello world</code>。</p>
<p>注意，模板字符串可以引用的类型一共6种，分别是 string、number、bigint、boolean、null、undefined。引用这6种以外的类型会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = &#123; n : <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="string">`<span class="subst">$&#123;Num&#125;</span> received`</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="string">`<span class="subst">$&#123;Obj&#125;</span> received`</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，模板字符串引用数值类型的别名<code>Num</code>是可以的，但是引用对象类型的别名<code>Obj</code>就会报错。</p>
<p>模板字符串里面引用的类型，如果是一个联合类型，那么它返回的也是一个联合类型，即模板字符串可以展开联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;A&#x27;</span>|<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;A_id&quot;|&quot;B_id&quot;</span></span><br><span class="line"><span class="keyword">type</span> U = <span class="string">`<span class="subst">$&#123;T&#125;</span>_id`</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>U</code>是一个模板字符串，里面引用了一个联合类型<code>T</code>，导致最后得到的也是一个联合类型。</p>
<p>如果模板字符串引用两个联合类型，它会交叉展开这两个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;A&#x27;</span>|<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> U = <span class="string">&#x27;1&#x27;</span>|<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;A1&#x27;|&#x27;A2&#x27;|&#x27;B1&#x27;|&#x27;B2&#x27;</span></span><br><span class="line"><span class="keyword">type</span> V = <span class="string">`<span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>T</code>和<code>U</code>都是联合类型，各自有两个成员，模板字符串里面引用了这两个类型，最后得到的就是一个4个成员的联合类型。</p>
<h2 id="satisfies-运算符"><a href="#satisfies-运算符" class="headerlink" title="satisfies 运算符"></a>satisfies 运算符</h2><p><code>satisfies</code>运算符用来检测某个值是否符合指定类型。有时候，不方便将某个值指定为某种类型，但是希望这个值符合类型条件，这时候就可以用<code>satisfies</code>运算符对其进行检测。<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator">TypeScript 4.9</a>添加了这个运算符。</p>
<p>举例来说，有一个对象的属性名拼写错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> palette = &#123;</span><br><span class="line">  <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">  <span class="attr">bleu</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>] <span class="comment">// 属性名拼写错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>palette</code>的属性名拼写错了，将<code>blue</code>拼成了<code>bleu</code>，我们希望通过指定类型，发现这个错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Colors</span> = <span class="string">&quot;red&quot;</span> | <span class="string">&quot;green&quot;</span> | <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">RGB</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">palette</span>: <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span>|<span class="variable constant_">RGB</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">  <span class="attr">bleu</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>] <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>palette</code>的类型被指定为<code>Record&lt;Colors, string|RGB&gt;</code>，这是一个类型工具，用来返回一个对象，详细介绍见《类型工具》一章。简单说，它的第一个类型参数指定对象的属性名，第二个类型参数指定对象的属性值。</p>
<p>本例的<code>Record&lt;Colors, string|RGB&gt;</code>，就表示变量<code>palette</code>的属性名应该符合类型<code>Colors</code>，属性值应该符合类型<code>string|RGB</code>，要么是字符串，要么是元组<code>RGB</code>。属性名<code>bleu</code>不符合类型<code>Colors</code>，所以就报错了。</p>
<p>这样的写法，虽然可以发现属性名的拼写错误，但是带来了新的问题。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greenComponent = palette.<span class="property">green</span>.<span class="title function_">substring</span>(<span class="number">1</span>, <span class="number">6</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>palette.green</code>属性调用<code>substring()</code>方法会报错，原因是这个方法只有字符串才有，而<code>palette.green</code>的类型是<code>srting|RGB</code>，除了字符串，还可能是元组<code>RGB</code>，而元组并不存在<code>substring()</code>方法，所以报错了。</p>
<p>如果要避免报错，要么精确给出变量<code>palette</code>每个属性的类型，要么对<code>palette.green</code>的值进行类型缩小。两种做法都比较麻烦，也不是很有必要。</p>
<p>这时就可以使用<code>satisfies</code>运算符，对<code>palette</code>进行类型检测，但是不改变 TypeScript 对<code>palette</code>的类型推断。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Colors</span> = <span class="string">&quot;red&quot;</span> | <span class="string">&quot;green&quot;</span> | <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">RGB</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> palette = &#123;</span><br><span class="line">  <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">  <span class="attr">bleu</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>] <span class="comment">// 报错</span></span><br><span class="line">&#125; satisfies <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span>|<span class="variable constant_">RGB</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greenComponent = palette.<span class="property">green</span>.<span class="title function_">substring</span>(<span class="number">1</span>); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>palette</code>的值后面增加了<code>satisfies Record&lt;Colors, string|RGB&gt;</code>，表示该值必须满足<code>Record&lt;Colors, string|RGB&gt;</code>这个条件，所以能够检测出属性名<code>bleu</code>的拼写错误。同时，它不会改变<code>palette</code>的类型推断，所以，TypeScript 知道<code>palette.green</code>是一个字符串，对其调用<code>substring()</code>方法就不会报错。</p>
<p><code>satisfies</code>也可以检测属性值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> palette = &#123;</span><br><span class="line">  <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">  <span class="attr">blue</span>: [<span class="number">0</span>, <span class="number">0</span>] <span class="comment">// 报错</span></span><br><span class="line">&#125; satisfies <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span>|<span class="variable constant_">RGB</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>blue</code>的值只有两个成员，不符合元组<code>RGB</code>必须有三个成员的条件，从而报错了。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-operator/" data-id="clm60yr06001hewwl0bpkd3sh" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-narrowing" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-narrowing/">TypeScript 类型缩小</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-narrowing/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><p>TypeScript 变量的值可以变，但是类型通常是不变的。唯一允许的改变，就是类型缩小，就是将变量值的范围缩得更小。</p>
<h2 id="手动类型缩小"><a href="#手动类型缩小" class="headerlink" title="手动类型缩小"></a>手动类型缩小</h2><p>如果一个变量属于联合类型，所以使用时一般需要缩小类型。</p>
<p>第一种方法是使用<code>if</code>判断。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getScore</span>(<span class="params">value: <span class="built_in">number</span>|<span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123; <span class="comment">// (A)</span></span><br><span class="line">    <span class="comment">// %inferred-type: number</span></span><br><span class="line">    value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123; <span class="comment">// (B)</span></span><br><span class="line">    <span class="comment">// %inferred-type: string</span></span><br><span class="line">    value;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unsupported value: &#x27;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个值是<code>any</code>或<code>unknown</code>，你又想对它进行处理，就必须先缩小类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseStringLiteral</span>(<span class="params">stringLiteral: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">unknown</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(stringLiteral);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;string&#x27;</span>) &#123; <span class="comment">// (A)</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string literal: &#x27;</span> + stringLiteral);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="literal">null</span> | <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">isbn</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTitle</span>(<span class="params">book: Book</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (book.<span class="property">title</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: null</span></span><br><span class="line">    book.<span class="property">title</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(Untitled)&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: string</span></span><br><span class="line">    book.<span class="property">title</span>;</span><br><span class="line">    <span class="keyword">return</span> book.<span class="property">title</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩小类型的前提是，需要先获取类型。获取类型的几种方法如下。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">value: <span class="built_in">Function</span>|<span class="built_in">Date</span>|<span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: Function</span></span><br><span class="line">    value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: Date</span></span><br><span class="line">    value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: number[]</span></span><br><span class="line">    value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><p>第二种方法是使用<code>switch</code>缩小类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getScore</span>(<span class="params">value: <span class="built_in">number</span>|<span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="comment">// %inferred-type: number</span></span><br><span class="line">      value;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">      <span class="comment">// %inferred-type: string</span></span><br><span class="line">      value;</span><br><span class="line">      <span class="keyword">return</span> value.<span class="property">length</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unsupported value: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>第三种方法是instanceof运算符。它能够检测实例对象与构造函数之间的关系。instanceof运算符的左操作数为实例对象，右操作数为构造函数，若构造函数的prototype属性值存在于实例对象的原型链上，则返回true；否则，返回false。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: <span class="built_in">Date</span> | <span class="built_in">RegExp</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">        x; <span class="comment">// Date</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">        x; <span class="comment">// RegExp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instanceof类型守卫同样适用于自定义构造函数，并对其实例对象进行类型细化。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: A | B</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (x <span class="keyword">instanceof</span> A) &#123;</span><br><span class="line">       x; <span class="comment">// A</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (x <span class="keyword">instanceof</span> B) &#123;</span><br><span class="line">       x; <span class="comment">// B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>第四种方法是使用in运算符。</p>
<p>in运算符是JavaScript中的关系运算符之一，用来判断对象自身或其原型链中是否存在给定的属性，若存在则返回true，否则返回false。in运算符有两个操作数，左操作数为待测试的属性名，右操作数为测试对象。</p>
<p>in类型守卫根据in运算符的测试结果，将右操作数的类型细化为具体的对象类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: A | B</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> x) &#123;</span><br><span class="line">        x; <span class="comment">// A</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x; <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">a</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123; <span class="attr">b</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickAB</span>(<span class="params">ab: A | B</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> ab) &#123;</span><br><span class="line"> ab <span class="comment">// Type is A</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ab <span class="comment">// Type is B</span></span><br><span class="line"> &#125;</span><br><span class="line"> ab <span class="comment">// Type is A | B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩小对象的属性，要用<code>in</code>运算符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FirstOrSecond</span> =</span><br><span class="line">  | &#123;<span class="attr">first</span>: <span class="built_in">string</span>&#125;</span><br><span class="line">  | &#123;<span class="attr">second</span>: <span class="built_in">string</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">firstOrSecond: FirstOrSecond</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;second&#x27;</span> <span class="keyword">in</span> firstOrSecond) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: &#123; second: string; &#125;</span></span><br><span class="line">    firstOrSecond;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">firstOrSecond: FirstOrSecond</span>) &#123;</span><br><span class="line">  <span class="comment">// @ts-expect-error: Property &#x27;second&#x27; does not exist on</span></span><br><span class="line">  <span class="comment">// type &#x27;FirstOrSecond&#x27;. [...]</span></span><br><span class="line">  <span class="keyword">if</span> (firstOrSecond.<span class="property">second</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符只能用于联合类型，不能用于检查一个属性是否存在。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">obj: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// %inferred-type: object</span></span><br><span class="line">    obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    obj.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特征属性"><a href="#特征属性" class="headerlink" title="特征属性"></a>特征属性</h3><p>对于不同对象之间的区分，还可以人为地为每一类对象设置一个特征属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UploadEvent</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;upload&#x27;</span>;</span><br><span class="line">    <span class="attr">filename</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">contents</span>: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DownloadEvent</span> &#123; <span class="attr">type</span>: <span class="string">&#x27;download&#x27;</span>; <span class="attr">filename</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AppEvent</span> = <span class="title class_">UploadEvent</span> | <span class="title class_">DownloadEvent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">e: AppEvent</span>) &#123;</span><br><span class="line"> <span class="keyword">switch</span> (e.<span class="property">type</span>) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;download&#x27;</span>:</span><br><span class="line"> e <span class="comment">// Type is DownloadEvent</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;upload&#x27;</span>:</span><br><span class="line"> e; <span class="comment">// Type is UploadEvent</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="any-类型的细化"><a href="#any-类型的细化" class="headerlink" title="any 类型的细化"></a>any 类型的细化</h2><p>TypeScript 推断变量类型时，会根据获知的信息，不断改变推断出来的类型，越来越细化。这种现象在<code>any</code>身上特别明显。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">range</span>(<span class="params"></span></span><br><span class="line"><span class="params">  start:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  limit:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> out = []; <span class="comment">// 类型为 any[]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; limit; i++) &#123;</span><br><span class="line">    out.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out; <span class="comment">// 类型为 number[]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面示例中，变量`</span>out<span class="string">`的类型一开始推断为`</span><span class="built_in">any</span>[]<span class="string">`，后来在里面放入数值，类型就变为`</span><span class="built_in">number</span>[]<span class="string">`。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">再看下面的例子。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>typescript</span><br><span class="line"><span class="keyword">const</span> result = []; <span class="comment">// 类型为 any[]</span></span><br><span class="line">result.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">result <span class="comment">// 类型为 string[]</span></span><br><span class="line">result.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">result <span class="comment">// 类型为 (string | number)[]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>result</code>随着成员类型的不同，而不断改变自己的类型。</p>
<p>注意，这种<code>any</code>类型的细化，只在打开了编译选项<code>noImplicitAny</code>时发生。</p>
<p>这时，如果在变量的推断类型还为<code>any</code>时（即没有任何写操作)，就去输出（或读取）该变量，则会报错，因为这时推断还没有完成，无法满足<code>noImplicitAny</code>的要求。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = []; <span class="comment">// 类型为 any[]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> result); <span class="comment">// 报错</span></span><br><span class="line">result.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 类型为 string[]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，只有运行完第三行，<code>result</code>的类型才能完成第一次推断，所以第二行读取<code>result</code>就会报错。</p>
<h2 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h2><p><code>is</code>运算符返回一个布尔值，用来判断左侧的值是否属于右侧的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInputElement</span>(<span class="params">el: HTMLElement</span>): el is <span class="title class_">HTMLInputElement</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElementContent</span>(<span class="params">el: HTMLElement</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isInputElement</span>(el)) &#123;</span><br><span class="line"> el; <span class="comment">// Type is HTMLInputElement</span></span><br><span class="line">    <span class="keyword">return</span> el.<span class="property">value</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> el; <span class="comment">// Type is HTMLElement</span></span><br><span class="line"> <span class="keyword">return</span> el.<span class="property">textContent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isDefined&lt;T&gt;(<span class="attr">x</span>: T | <span class="literal">undefined</span>): x is T &#123;</span><br><span class="line"> <span class="keyword">return</span> x !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-narrowing/" data-id="clm60yr07001jewwl4tp89gqr" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-npm" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-npm/">TypeScript 项目使用 npm 模块</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-npm/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>npm 模块都是 JavaScript 代码。即使模块是用 TypeScript 写的，还是必须编译成 JavaScript 再发布，保证模块可以在没有 TypeScript 的环境运行。</p>
<p>问题就来了，TypeScript 项目开发时，加载外部 npm 模块，如果拿不到该模块的类型信息，就会导致无法开发。所以，必须有一个方法，可以拿到模块的类型信息。</p>
<p>有些 npm 模块本身可能包含<code>.d.ts</code>文件甚至完整的 TypeScript 代码。它的<code>package.json</code>文件里面有一个<code>types</code>字段，指向一个<code>.d.ts</code>文件，这就是它的类型声明文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;left-pad&quot;</span>,</span><br><span class="line"> <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.3.0&quot;</span>,</span><br><span class="line"> <span class="string">&quot;description&quot;</span>: <span class="string">&quot;String left pad&quot;</span>,</span><br><span class="line"> <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line"> <span class="string">&quot;types&quot;</span>: <span class="string">&quot;index.d.ts&quot;</span>,</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个模块没有<code>.d.ts</code>文件，TypeScript 官方和社区就自发为常用模块添加类型描述，可以去<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/dt/search">官方网站</a>搜索，然后安装网站给出的 npm 类型模块，通常是<code>@types/[模块名]</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save lodash</span><br><span class="line">$ npm install --save @types/lodash</span><br></pre></td></tr></table></figure>

<p>lodash 的类型描述就是<code>@types/lodash</code>的文件<code>index.d.ts</code>。</p>
<h2 id="TS-模块转-npm-模块"><a href="#TS-模块转-npm-模块" class="headerlink" title="TS 模块转 npm 模块"></a>TS 模块转 npm 模块</h2><p>TS 代码放在<code>ts</code>子目录，编译出来的 CommonJS 代码放在<code>dist</code>子目录。</p>
<h2 id="如何写-TypeScript-模块"><a href="#如何写-TypeScript-模块" class="headerlink" title="如何写 TypeScript 模块"></a>如何写 TypeScript 模块</h2><p>首先，创建模块目录，然后在该目录里面新建一个<code>tsconfig.json</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2015&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&quot;declaration&quot;: true</code>：生成 .d.ts 文件，方便其他使用 TypeScript 的开发者加载你的库。</li>
<li><code>&quot;module&quot;: &quot;commonjs&quot;</code>：编译后的模块格式为<code>commonjs</code>，表示该模块供 Node.js 使用。如果供浏览器使用，则要写成<code>&quot;module&quot;: &quot;esnext&quot;</code>。</li>
<li><code>&quot;target&quot;: &quot;es2015&quot;</code>：生成的 JavaScript 代码版本为 ES2015，需要 Node.js 8 以上版本。</li>
<li><code>&quot;outDir&quot;: &quot;./dist&quot;</code>：编译后的文件放在<code>./dist</code>目录。</li>
<li><code>include</code>：指定需要编译的文件。</li>
</ul>
<p>然后，使用 TypeScript 编写仓库代码。可以在<code>src</code>子目录里面，编写一个入口文件<code>index.ts</code>。</p>
<p>最后，编写<code>package.json</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;hwrld&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Can log \&quot;hello world\&quot; and \&quot;goodbye world\&quot; to the console!&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;dist/index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;dist/index.d.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;/dist&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面的<code>&quot;types&quot;: &quot;dist/index.d.ts&quot;</code>字段指定类型声明文件，否则使用这个库的 TypeScript 开发者找不到类型声明文件。<code>files</code>属性指定打包进入 npm 模块的文件。</p>
<p>然后，就是编译和发布。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tsc</span><br><span class="line">$ npm publish</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.tsmean.com/articles/how-to-write-a-typescript-library/">How to Write a TypeScript Library</a>, by tsmean</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-npm/" data-id="clm60yr08001lewwl9sltg772" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-object" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-object/">TypeScript 的对象类型</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-object/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>除了原始类型，对象是 JavaScript 最基本的数据结构。TypeScript 对于对象类型有很多规则。</p>
<p>对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>obj</code>的类型就写在变量名后面，使用大括号描述，内部声明每个属性的属性名和类型。</p>
<p>属性的类型可以用分号结尾，也可以用逗号结尾。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性类型以分号结尾</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性类型以逗号结尾</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后一个属性后面，可以写分号或逗号，也可以不写。</p>
<p>一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">o1</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">o2</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">1</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>o1</code>缺少了属性<code>y</code>，变量<code>o2</code>多出了属性<code>z</code>，都会报错。</p>
<p>读写不存在的属性也会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">z</span>); <span class="comment">// 报错</span></span><br><span class="line">obj.<span class="property">z</span> = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，读写不存在的属性<code>z</code>都会报错。</p>
<p>同样地，也不能删除类型声明中存在的属性，修改属性值是可以的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sabrina&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myUser.<span class="property">name</span> <span class="comment">// 报错</span></span><br><span class="line">myUser.<span class="property">name</span> = <span class="string">&quot;Cynthia&quot;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面声明中，删除类型声明中存在的属性<code>name</code>会报错，但是可以修改它的值。</p>
<p>对象的方法使用函数类型描述。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 或者写成</span></span><br><span class="line">  <span class="comment">// add: (x:number, y:number) =&gt; number;</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>obj</code>有一个方法<code>add()</code>，需要定义它的参数类型和返回值类型。</p>
<p>对象类型可以使用方括号读取属性的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">User</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象类型<code>User</code>使用方括号，读取了属性<code>name</code>的类型（<code>string</code>）。</p>
<p>除了<code>type</code>命令可以为对象类型声明一个别名，TypeScript 还提供了<code>interface</code>命令，可以把对象类型提炼为一个接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，写法一是<code>type</code>命令的用法，写法二是<code>interface</code>命令的用法。<code>interface</code>命令的详细解释，以及与<code>type</code>命令的区别，详见《Interface》一章。</p>
<p>注意，TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="title function_">toString</span>(): <span class="built_in">string</span>; <span class="comment">// 继承的属性</span></span><br><span class="line">  <span class="attr">prop</span>: <span class="built_in">number</span>; <span class="comment">// 自身的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyInterface</span> = &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="attr">prop</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>obj</code>只写了<code>prop</code>属性，但是不报错。因为它可以继承原型上面的<code>toString()</code>方法。</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>y</code>是可选的。</p>
<p>可选属性等同于允许赋值为<code>undefined</code>，下面两种写法是等效的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>|<span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>User</code>的可选属性<code>lastName</code>可以是字符串，也可以是<code>undefined</code>，即可选属性可以赋值为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="literal">undefined</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，可选属性<code>y</code>赋值为<code>undefined</code>，不会报错。</p>
<p>同样地，读取一个没有赋值的可选属性时，返回<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">string</span>,</span><br><span class="line">  y?: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line">obj.<span class="property">y</span>.<span class="title function_">toLowerCase</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行会报错，因为<code>obj.y</code>返回<code>undefined</code>，无法对其调用<code>toLowerCase()</code>。</p>
<p>所以，读取可选属性之前，必须检查一下是否为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user</span>:&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">firstName</span>: <span class="string">&#x27;Foo&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user.<span class="property">lastName</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>lastName</code>是可选属性，需要判断是否为<code>undefined</code>以后，才能使用。建议使用下面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> firstName = (user.<span class="property">firstName</span> === <span class="literal">undefined</span>)</span><br><span class="line">  ? <span class="string">&#x27;Foo&#x27;</span> : user.<span class="property">firstName</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = (user.<span class="property">lastName</span> === <span class="literal">undefined</span>)</span><br><span class="line">  ? <span class="string">&#x27;Bar&#x27;</span> : user.<span class="property">lastName</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> firstName = user.<span class="property">firstName</span> ?? <span class="string">&#x27;Foo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = user.<span class="property">lastName</span> ?? <span class="string">&#x27;Bar&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，写法一使用三元运算符<code>?:</code>，判断是否为<code>undefined</code>，并设置默认值。写法二使用 Null 判断运算符<code>??</code>，与写法一的作用完全相同。</p>
<p>TypeScript 提供编译设置<code>ExactOptionalPropertyTypes</code>，只要同时打开这个设置和<code>strictNullChecks</code>，可选属性就不能设为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开 ExactOptionsPropertyTypes 和 strictNullChecks</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="literal">undefined</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，打开了这两个设置以后，可选属性就不能设为<code>undefined</code>了。</p>
<p>注意，可选属性与允许设为<code>undefined</code>的必选属性是不等价的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">x</span>:<span class="built_in">number</span>, y?:<span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>|<span class="literal">undefined</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ObjA</span>:A = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ObjB</span>:B = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>y</code>如果是一个可选属性，那就可以省略不写；如果是允许设为<code>undefined</code>的必选属性，一旦省略就会报错，必须显式写成<code>&#123; x: 1, y: undefined &#125;</code>。</p>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>属性名前面加上<code>readonly</code>关键字，表示这个属性是只读属性，不能修改。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">prop</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>prop</code>属性是只读属性，不能修改它的值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">person</span>:&#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125; = &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">21</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行修改了只读属性<code>age</code>，就报错了。</p>
<p>只读属性只能在对象初始化期间赋值，此后就不能修改该属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">p.<span class="property">x</span> = <span class="number">100</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Point</code>的属性<code>x</code>和<code>y</code>都带有修饰符<code>readonly</code>，表示这两个属性只能在初始化期间赋值，后面再修改就会报错。</p>
<p>注意，如果属性值是一个对象，<code>readonly</code>修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">resident</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">h</span>:<span class="title class_">Home</span> = &#123;</span><br><span class="line">  <span class="attr">resident</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Vicky&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">h.<span class="property">resident</span>.<span class="property">age</span> = <span class="number">32</span>; <span class="comment">// 正确</span></span><br><span class="line">h.<span class="property">resident</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Kate&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span> </span><br><span class="line">&#125; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>h.resident</code>是只读属性，它的值是一个对象。修改这个对象的<code>age</code>属性是可以的，但是整个替换掉<code>h.resident</code>属性会报错。</p>
<p>另一个需要注意的地方是，如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyPerson</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">w</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Vicky&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">r</span>:<span class="title class_">ReadonlyPerson</span> = w;</span><br><span class="line"></span><br><span class="line">w.<span class="property">age</span> += <span class="number">1</span>;</span><br><span class="line">r.<span class="property">age</span> <span class="comment">// 43</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>w</code>和<code>r</code>指向同一个对象，其中<code>w</code>是可写的，<code>r</code>是只读的。那么，对<code>w</code>的属性修改，会影响到<code>r</code>。</p>
<p>如果希望属性值是只读的，除了声明时加上<code>readonly</code>关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言<code>as const</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sabrina&quot;</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">myUser.<span class="property">name</span> = <span class="string">&quot;Cynthia&quot;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象后面加了只读断言<code>as const</code>，就变成只读对象了，不能修改属性了。</p>
<p>注意，上面的<code>as const</code>属于 TypeScript 的类型推断，如果变量明确地声明了类型，那么 TypeScript 会以声明的类型为准。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">myUser</span>:&#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sabrina&quot;</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">myUser.<span class="property">name</span> = <span class="string">&quot;Cynthia&quot;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，根据变量<code>myUser</code>的类型声明，<code>name</code>不是只读属性，但是赋值时又使用只读断言<code>as const</code>。这时会以声明的类型为准，因为<code>name</code>属性可以修改。</p>
<h2 id="属性名的索引类型"><a href="#属性名的索引类型" class="headerlink" title="属性名的索引类型"></a>属性名的索引类型</h2><p>如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。</p>
<p>索引类型里面，最常见的就是属性名的字符串索引。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>MyObj</code>的属性名类型就采用了表达式形式，写在方括号里面。<code>[property: string]</code>的<code>property</code>表示属性名，这个是可以随便起的，它的类型是<code>string</code>，即属性名类型为<code>string</code>。也就是说，不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明。</p>
<p>JavaScript 对象的属性名（即上例的<code>property</code>）的类型有三种可能，除了上例的<code>string</code>，还有<code>number</code>和<code>symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">symbol</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象属性名的类型分别为<code>number</code>和<code>symbol</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  [<span class="attr">n</span>:<span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象类型<code>MyArr</code>的属性名是<code>[n:number]</code>，就表示它的属性名都是数值，比如<code>0</code>、<code>1</code>、<code>2</code>。</p>
<p>对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引。但是，数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">boolean</span>; <span class="comment">// 报错</span></span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>MyType</code>同时有两种属性名索引，但是数值索引与字符串索引冲突了，所以报错了。由于字符属性名的值类型是<code>string</code>，数值属性名的值类型只有同样为<code>string</code>，才不会报错。</p>
<p>同样地，可以既声明属性名索引，也声明具体的单个属性名。如果单个属性名符合属性名索引的范围，两者不能有冲突，否则报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">boolean</span>; <span class="comment">// 报错</span></span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性名<code>foo</code>符合属性名的字符串索引，但是两者的属性值类型不一样，所以报错了。</p>
<p>属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。另外，属性名的数值索引不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及<code>length</code>属性，因为类型里面没有定义这些东西。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  [<span class="attr">n</span>:<span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，读取<code>arr.length</code>属性会报错，因为类型<code>MyArr</code>没有这个属性。</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值用于直接从对象中提取属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, price&#125; = product;</span><br></pre></td></tr></table></figure>

<p>上面语句从对象<code>product</code>提取了三个属性，并声明属性名的同名变量。</p>
<p>解构赋值的类型写法，跟为对象声明类型是一样的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, price&#125;:&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span></span><br><span class="line">&#125; = product;</span><br></pre></td></tr></table></figure>

<p>注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: foo, <span class="attr">y</span>: bar &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> foo = obj.<span class="property">x</span>;</span><br><span class="line"><span class="keyword">let</span> bar = obj.<span class="property">y</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，冒号不是表示属性<code>x</code>和<code>y</code>的类型，而是为这两个属性指定新的变量名。如果要为<code>x</code>和<code>y</code>指定类型，不得不写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: foo, <span class="attr">y</span>: bar &#125;</span><br><span class="line">  : &#123; <span class="attr">x</span>: <span class="built_in">string</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125; = obj;</span><br></pre></td></tr></table></figure>

<p>这一点要特别小心，TypeScript 里面很容易搞糊涂。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  shape: Shape,</span></span><br><span class="line"><span class="params">  xPos: <span class="built_in">number</span> = <span class="number">100</span>,</span></span><br><span class="line"><span class="params">  yPos: <span class="built_in">number</span> = <span class="number">100</span></span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myShape = shape; <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">let</span> x = xPos; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>draw()</code>的参数是一个对象解构，里面的冒号很像是为变量指定类型，其实是为对应的属性指定新的变量名。所以，TypeScript 就会解读成，函数体内不存在变量<code>shape</code>，而是属性<code>shape</code>的值被赋值给了变量<code>Shape</code>。</p>
<h2 id="结构类型原则"><a href="#结构类型原则" class="headerlink" title="结构类型原则"></a>结构类型原则</h2><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structural typing）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>A</code>只有一个属性<code>x</code>，类型为<code>number</code>。对象<code>B</code>满足这个特征，因此兼容对象<code>A</code>，只要可以使用<code>A</code>的地方，就可以使用<code>B</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> B = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">A</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; = B; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>和<code>B</code>并不是同一个类型，但是<code>B</code>可以赋值给<code>A</code>，因为<code>B</code>满足<code>A</code>的结构特征。</p>
<p>根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查这个值的结构是否符合要求（即“结构类型”）。</p>
<p>TypeScript 之所以这样设计，是为了符合 JavaScript 的行为。JavaScript 并不关心对象是否严格相似，只要某个对象具有所要求的属性，就可以正确运行。</p>
<p>如果类型 B 可以赋值给类型 A，TypeScript 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。</p>
<p>这种设计有时会导致令人惊讶的结果。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myObj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">obj:myObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">const</span> v = obj[n]; <span class="comment">// 报错</span></span><br><span class="line">    sum += <span class="title class_">Math</span>.<span class="title function_">abs</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>getSum()</code>要求传入参数的类型是<code>myObj</code>，但是实际上所有与<code>myObj</code>兼容的对象都可以传入。这会导致<code>const v = obj[n]</code>这一行报错，原因是<code>obj[n]</code>取出的属性值不一定是数值（<code>number</code>），使得变量<code>v</code>的类型被推断为<code>any</code>。如果项目设置为不允许变量类型推断为<code>any</code>，代码就会报错。写成下面这样，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">obj:MyObj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(obj.<span class="property">x</span>) + <span class="title class_">Math</span>.<span class="title function_">abs</span>(obj.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例就不会报错，因为函数体内部只使用了属性<code>x</code>和<code>y</code>，这两个属性有明确的类型声明，保证<code>obj.x</code>和<code>obj.y</code>肯定是数值。虽然与<code>MyObj</code>兼容的任何对象都可以传入函数<code>getSum()</code>，但是只要不使用其他属性，就不会有类型报错。</p>
<h2 id="严格字面量检查"><a href="#严格字面量检查" class="headerlink" title="严格字面量检查"></a>严格字面量检查</h2><p>如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）。如果字面量的结构跟类型定义的不一样（比如多出了未定义的属性），就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">1</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，等号右边是一个对象的字面量，这时会触发严格字面量检查。只要有类型声明中不存在的属性（本例是<code>z</code>），就会导致报错。</p>
<p>如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPoint = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = myPoint; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，等号右边是一个变量，就不会触发严格字面量检查，从而不报错。</p>
<p>TypeScript 对字面量进行严格检查的目的，主要是防止拼写错误。一般来说，字面量大多数来自手写，容易出现拼写错误，或者误用 API。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>:<span class="built_in">string</span>;</span><br><span class="line">  darkMode?:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的网页&#x27;</span>,</span><br><span class="line">  <span class="attr">darkmode</span>: <span class="literal">true</span>, <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>darkMode</code>拼写错了，成了<code>darkmode</code>。如果没有严格字面量规则，就不会报错，因为<code>darkMode</code>是可选属性，根据结构类型原则，任何对象只要有<code>title</code>属性，都认为符合<code>Options</code>类型。</p>
<p>规避严格字面量检查，可以使用中间变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myOptions = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的网页&#x27;</span>,</span><br><span class="line">  <span class="attr">darkmode</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = myOptions;</span><br></pre></td></tr></table></figure>

<p>上面示例中，创建了一个中间变量<code>myOptions</code>，就不会触发严格字面量规则，因为这时变量<code>obj</code>的赋值，不属于直接字面量赋值。</p>
<p>如果你确认字面量没有错误，也可以使用类型断言规避严格字面量检查。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的网页&#x27;</span>,</span><br><span class="line">  <span class="attr">darkmode</span>: <span class="literal">true</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">Options</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例使用类型断言<code>as Options</code>，告诉编译器，字面量符合 Options 类型，就能规避这条规则。</p>
<p>如果允许字面量有多余属性，可以像下面这样在类型里面定义一个通用属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">baz</span>: <span class="number">2</span> &#125;;  <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型声明里面，有一个属性的字符串索引（<code>[x: string]</code>），导致任何字符串属性名都是合法的。</p>
<p>由于严格字面量检查，字面量对象传入函数必须很小心，不能有多余的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computeDistance</span>(<span class="params">point: Point</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">computeDistance</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;); <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">computeDistance</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象字面量传入函数<code>computeDistance()</code>时，不能有多余的属性，否则就通不过严格字面量检查。</p>
<p>编译器选项<code>suppressExcessPropertyErrors</code>，可以关闭多余属性检查。下面是它在 tsconfig.json 文件里面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;suppressExcessPropertyErrors&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小可选属性规则"><a href="#最小可选属性规则" class="headerlink" title="最小可选属性规则"></a>最小可选属性规则</h2><p>根据“结构类型”原则，如果一个对象的所有属性都是可选的，那么其他对象跟它都是结构类似的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">  a?:<span class="built_in">number</span>;</span><br><span class="line">  b?:<span class="built_in">number</span>;</span><br><span class="line">  c?:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Options</code>的所有属性都是可选的，所以它可以是一个空对象，也就意味着任意对象都满足<code>Options</code>的结构。</p>
<p>为了避免这种情况，TypeScript 2.4 引入了一个“最小可选属性规则”，也称为<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection">“弱类型检测”</a>（weak type detection）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">  a?:<span class="built_in">number</span>;</span><br><span class="line">  b?:<span class="built_in">number</span>;</span><br><span class="line">  c?:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">d</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = opts; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>opts</code>与类型<code>Options</code>没有共同属性，赋值给该类型的变量就会报错。</p>
<p>报错原因是，如果某个类型的所有属性都是可选的，那么该类型的对象必须至少存在一个可选属性，不能所有可选属性都不存在。这就叫做“最小可选属性规则”。</p>
<p>如果想规避这条规则，要么在类型里面增加一条索引属性（<code>[propName: string]: someType</code>），要么使用类型断言（<code>opts as Options</code>）。</p>
<h2 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h2><p>空对象是 TypeScript 的一种特殊值，也是一种特殊类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="number">123</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>obj</code>的值是一个空对象，然后对<code>obj.prop</code>赋值就会报错。</p>
<p>原因是这时 TypeScript 会推断变量<code>obj</code>的类型为空对象，实际执行的是下面的代码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;&#125; = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>空对象没有自定义属性，所以对自定义属性赋值就会报错。空对象只能使用继承的属性，即继承自原型对象<code>Object.prototype</code>的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="title function_">toString</span>() <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>toString()</code>方法是一个继承自原型对象的方法，TypeScript 允许在空对象上使用。</p>
<p>回到本节开始的例子，这种写法其实在 JavaScript 很常见：先声明一个空对象，然后向空对象添加属性。但是，TypeScript 不允许动态添加属性，所以对象不能分步生成，必须生成时一次性声明所有属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;&#125;;</span><br><span class="line">pt.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">pt.<span class="property">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果确实需要分步声明，一个比较好的方法是，使用扩展运算符（<code>...</code>）合成一个新对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pt0 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> pt1 = &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> pt2 = &#123; <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  ...pt0, ...pt1, ...pt2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>pt</code>是三个部分合成的，这样既可以分步声明，也符合 TypeScript 静态声明的要求。</p>
<p>空对象作为类型，其实是<code>Object</code>类型的简写形式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">d</span>:&#123;&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// let d:Object;</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;;</span><br><span class="line">d = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">d = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">d = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，各种类型的值（除了<code>null</code>和<code>undefined</code>）都可以赋值给空对象类型，跟<code>Object</code>类型的行为是一样的。</p>
<p>因为<code>Object</code>可以接受各种类型的值，而空对象是<code>Object</code>类型的简写，所以它不会有严格字面量检查，赋值时总是允许多余的属性，只是不能读取这些属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Empty</span> &#123; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">Empty</span> = &#123;<span class="attr">myProp</span>: <span class="number">1</span>, <span class="attr">anotherProp</span>: <span class="number">2</span>&#125;; <span class="comment">// 正确</span></span><br><span class="line">b.<span class="property">myProp</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>b</code>的类型是空对象，视同<code>Object</code>类型，不会有严格字面量检查，但是读取多余的属性会报错。</p>
<p>如果想强制使用没有任何属性的对象，可以采用下面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">WithoutProperties</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">never</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="title class_">WithoutProperties</span> = &#123; <span class="attr">prop</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的示例中，<code>[key: string]: never</code>表示字符串属性名是不存在的，因此其他对象进行赋值时就会报错。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-object/" data-id="clm60yr0b001newwl7ct9h4cn" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-symbol" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-symbol/">TypeScript 的 symbol 类型</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-symbol/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Symbol 是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个 Symbol 值都是独一无二的，与其他任何值都不相等。</p>
<p>Symbol 值通过<code>Symbol()</code>函数生成。在 TypeScript 里面，Symbol 的类型使用<code>symbol</code>表示。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">x === y <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>和<code>y</code>的类型都是<code>symbol</code>，且都用<code>Symbol()</code>生成，但是它们是不相等的。</p>
<h2 id="unique-symbol"><a href="#unique-symbol" class="headerlink" title="unique symbol"></a>unique symbol</h2><p><code>symbol</code>类型包含所有的 Symbol 值，但是无法表示某一个具体的 Symbol 值。</p>
<p>比如，<code>5</code>是一个具体的数值，就用<code>5</code>这个字面量来表示，这也是它的值类型。但是，Symbol 值不存在字面量，必须通过变量来引用，所以写不出只包含单个 Symbol 值的那种值类型。</p>
<p>为了解决这个问题，TypeScript 设计了<code>symbol</code>的一个子类型<code>unique symbol</code>，它表示单个的、某个具体的 Symbol 值。</p>
<p>因为<code>unique symbol</code>表示单个值，所以这个类型的变量是不能修改值的，只能用<code>const</code>命令声明，不能用<code>let</code>声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>let</code>命令声明的变量，不能是<code>unique symbol</code>类型，会报错。</p>
<p><code>const</code>命令为变量赋值 Symbol 值时，变量类型默认就是<code>unique symbol</code>，所以类型可以省略不写。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>每个声明为<code>unique symbol</code>类型的变量，它们的值都是不一样的，其实属于两个值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型虽然都是<code>unique symbol</code>，但其实是两个值类型。不同类型的值肯定是不相等的，所以最后一行就报错了。</p>
<p>由于 Symbol 类似于字符串，可以参考下面的例子来理解。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="string">&#x27;hello&#x27;</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="string">&#x27;world&#x27;</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>b</code>都是字符串，但是属于不同的值类型，不能使用严格相等运算符进行比较。</p>
<p>而且，由于变量<code>a</code>和<code>b</code>是两个类型，就不能把一个赋值给另一个。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:unique <span class="built_in">symbol</span> = a; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型都是<code>unique symbol</code>，但是其实类型不同，所以把<code>a</code>赋值给<code>b</code>会报错。</p>
<p>上例变量<code>b</code>的类型，如果要写成与变量<code>a</code>同一个<code>unique symbol</code>值类型，只能写成类型为<code>typeof a</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="keyword">typeof</span> a = a; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>不过我们知道，相同参数的<code>Symbol.for()</code>方法会返回相同的 Symbol 值。TypeScript 目前无法识别这种情况，所以可能出现多个 unique symbol 类型的变量，等于同一个 Symbol 值的情况。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>b</code>是两个不同的值类型，但是它们的值其实是相等的。</p>
<p>unique symbol 类型是 symbol 类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="built_in">symbol</span> = a; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:unique <span class="built_in">symbol</span> = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，unique symbol 类型（变量<code>a</code>）赋值给 symbol 类型（变量<code>b</code>）是可以的，但是 symbol 类型（变量<code>b</code>）赋值给 unique symbol 类型（变量<code>c</code>）会报错。</p>
<p>unique symbol 类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。如果要把某一个特定的 Symbol 值当作属性名，那么它的类型只能是 unique symbol，不能是 symbol。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  [x]: <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br><span class="line">  [y]: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>y</code>当作属性名，但是<code>y</code>的类型是 symbol，不是固定不变的值，导致报错。</p>
<p><code>unique symbol</code>类型也可以用作类（class）的属性值，但只能赋值给类的<code>readonly static</code>属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="attr">foo</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态只读属性<code>foo</code>的类型就是<code>unique symbol</code>。注意，这时<code>static</code>和<code>readonly</code>两个限定符缺一不可，这是为了保证这个属性是固定不变的。</p>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>如果变量声明时没有给出类型，TypeScript 会推断某个 Symbol 值变量的类型。</p>
<p><code>let</code>命令声明的变量，推断类型为 symbol。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型为 symbol</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p><code>const</code>命令声明的变量，推断类型为 unique symbol。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型为 unique symbol</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>但是，<code>const</code>命令声明的变量，如果赋值为另一个 symbol 类型的变量，则推断类型为 symbol。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为 symbol</span></span><br><span class="line"><span class="keyword">const</span> y = x;</span><br></pre></td></tr></table></figure>

<p><code>let</code>命令声明的变量，如果赋值为另一个 unique symbol 类型的变量，则推断类型还是 symbol。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为 symbol</span></span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-symbol/" data-id="clm60yr0b001pewwl62tx5nht" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-react" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-react/">TypeScript 的 React 支持</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-react/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><p>JSX 是 React 库引入的一种语法，可以在 JavaScript 脚本中直接书写 HTML 风格的标签。</p>
<p>TypeScript 支持 JSX 语法，但是必须将脚本后缀名改成<code>.tsx</code>。</p>
<p><code>.tsx</code>文件中，类型断言一律使用<code>as</code>形式，因为尖括号的写法会与 JSX 冲突。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> x = foo <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用</span></span><br><span class="line"><span class="keyword">var</span> x = &lt;<span class="built_in">any</span>&gt;foo;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>被断言为类型<code>any</code>，在<code>.tsx</code>文件中只能使用第一种写法，不使用第二种写法。</p>
<h2 id="React-库"><a href="#React-库" class="headerlink" title="React 库"></a>React 库</h2><p>TypeScript 使用 React 库必须引入 React 的类型定义。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;react.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">Props</span>, &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">MyComponent</span> name=<span class="string">&quot;bar&quot;</span> /&gt;; <span class="comment">// OK</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">name</span>=<span class="string">&#123;0&#125;</span> /&gt;</span></span>; <span class="comment">// error, `name` is not a number</span></span><br></pre></td></tr></table></figure>

<h2 id="内置元素"><a href="#内置元素" class="headerlink" title="内置元素"></a>内置元素</h2><p>内置元素使用<code>JSX.IntrinsicElements</code>接口。默认情况下，内置元素不进行类型检查。但是，如果给出了接口定义，就会进行类型检查。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;foo /&gt;; <span class="comment">// ok</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bar</span> /&gt;</span></span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>&lt;bar /&gt;</code>不符合接口定义，所以报错。</p>
<p>一种解决办法就是，在接口中定义一个通用元素。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">    [<span class="attr">elemName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中， 元素名可以是任意字符串。</p>
<h2 id="组件的写法"><a href="#组件的写法" class="headerlink" title="组件的写法"></a>组件的写法</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FooProp</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">X</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">Y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">AnotherComponent</span>(<span class="params">prop: &#123; name: <span class="built_in">string</span> &#125;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentFoo</span>(<span class="params">prop: FooProp</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">AnotherComponent</span> <span class="attr">name</span>=<span class="string">&#123;prop.name&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">prop: &#123; value: <span class="built_in">string</span> &#125;, context: &#123; color: <span class="built_in">string</span> &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-react/" data-id="clm60yr0c001rewwl2drtekme" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-tsc" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-tsc/">tsc 命令行编译器</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-tsc/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>tsc 是 TypeScript 官方的命令行编译器，用来检查代码，并将其编译成 JavaScript 代码。</p>
<p>tsc 默认使用当前目录下的配置文件<code>tsconfig.json</code>，但也可以接受独立的命令行参数。命令行参数会覆盖<code>tsconfig.json</code>，比如命令行指定了所要编译的文件，那么 tsc 就会忽略<code>tsconfig.json</code>的<code>files</code>属性。</p>
<p>tsc 的基本用法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 tsconfig.json 的配置</span></span><br><span class="line">$ tsc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只编译 index.ts</span></span><br><span class="line">$ tsc index.ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 src 目录的所有 .ts 文件</span></span><br><span class="line">$ tsc src/*.ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译配置文件</span></span><br><span class="line">$ tsc --project tsconfig.production.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只生成类型声明文件，不编译出 JS 文件</span></span><br><span class="line">$ tsc index.js --declaration --emitDeclarationOnly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个 TS 文件编译成单个 JS 文件</span></span><br><span class="line">$ tsc app.ts util.ts --target esnext --outfile index.js</span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>tsc 的命令行参数，大部分与 tsconfig.json 的属性一一对应。</p>
<p>下面只是按照首字母排序，简单罗列出主要的一些参数，详细解释可以参考《tsconfig.json 配置文件》一章。</p>
<p><code>--all</code>：输出所有可用的参数。</p>
<p><code>--allowJs</code>：允许 TS 脚本加载 JS 模块，编译时将 JS 一起拷贝到输出目录。</p>
<p><code>--allowUnreachableCode</code>：如果 TS 脚本有不可能运行到的代码，不报错。</p>
<p><code>--allowUnusedLabels</code>：如果 TS 脚本有没有用到的标签，不报错。</p>
<p><code>--alwaysStrict</code>：总是在编译产物的头部添加<code>use strict</code>。</p>
<p><code>--baseUrl</code>：指定非相对位置的模块定位的基准 URL。</p>
<p><code>--build</code>：启用增量编译。</p>
<p><code>--checkJs</code>：对 JS 脚本进行类型检查。</p>
<p><code>--declaration</code>：为 TS 脚本生成一个类型生成文件。</p>
<p><code>--declarationDir</code>：指定生成的类型声明文件的所在目录。</p>
<p><code>--declarationMap</code>：为<code>.d.ts</code>文件生成 SourceMap 文件。</p>
<p><code>--diagnostics</code>：构建后输出编译性能信息。</p>
<p><code>--emitBOM</code>：在编译输出的 UTF-8 文件头部加上 BOM 标志。</p>
<p><code>--emitDeclarationOnly</code>：只编译输出类型声明文件，不输出 JS 文件。</p>
<p><code>--esModuleInterop</code>：更容易使用 import 命令加载 CommonJS 模块。</p>
<p><code>--exactOptionalPropertyTypes</code>：不允许将可选属性设置为<code>undefined</code>。</p>
<p><code>--experimentalDecorators</code>：支持早期的装饰器语法。</p>
<p><code>--explainFiles</code>：输出进行编译的文件信息。</p>
<p><code>--forceConsistentCasingInFileNames</code>：文件名大小写敏感，默认打开。</p>
<p><code>--help</code>：输出帮助信息。</p>
<p><code>--importHelpers</code>：从外部库（比如 tslib）输入辅助函数。</p>
<p><code>--incremental</code>：启用增量构建。</p>
<p><code>--init</code>：在当前目录创建一个全新的<code>tsconfig.json</code>文件，里面是预设的设置。</p>
<p><code>--inlineSourceMap</code>：SourceMap 信息嵌入 JS 文件，而不是生成独立的<code>.js.map</code>文件。</p>
<p><code>--inlineSources</code>：将 TypeScript 源码作为 SourceMap 嵌入编译出来的 JS 文件。</p>
<p><code>--isolatedModules</code>：确保每个模块能够独立编译，不依赖其他输入的模块。</p>
<p><code>--jsx</code>：设置如何处理 JSX 文件。</p>
<p><code>--lib</code>：设置目标环境需要哪些内置库的类型描述。</p>
<p><code>--listEmittedFiles</code>：编译后输出编译产物的文件名。</p>
<p><code>--listFiles</code>：编译过程中，列出读取的文件名。</p>
<p><code>--listFilesOnly</code>：列出编译所要处理的文件，然后停止编译。</p>
<p><code>--locale</code>：指定编译时输出的语言，不影响编译结果。</p>
<p><code>--mapRoot</code>：指定 SourceMap 文件的位置。</p>
<p><code>--module</code>：指定编译生成的模块格式。</p>
<p><code>--moduleResolution</code>：指定如何根据模块名找到模块的位置。</p>
<p><code>--moduleSuffixes</code>：指定模块文件的后缀名。</p>
<p><code>--newLine</code>：指定编译产物的换行符，可以设为<code>crlf</code>或者<code>lf</code>。</p>
<p><code>--noEmit</code>：不生成编译产物，只进行类型检查。</p>
<p><code>--noEmitHelpers</code>：不在编译产物中加入辅助函数。</p>
<p><code>--noEmitOnError</code>：一旦报错，就停止编译，没有编译产物。</p>
<p><code>--noFallthroughCasesInSwitch</code>：Switch 结构的<code>case</code>分支必须有终止语句（比如<code>break</code>）。</p>
<p><code>--noImplicitAny</code>：类型推断只要为<code>any</code>类型就报错。</p>
<p><code>--noImplicitReturns</code>：函数内部没有显式返回语句（比如<code>return</code>）就报错。</p>
<p><code>--noImplicitThis</code>：如果<code>this</code>关键字是<code>any</code>类型，就报错。</p>
<p><code>--noImplicitUseStrict</code>：编译产生的 JS 文件头部不添加<code>use strict</code>语句。</p>
<p><code>--noResolve</code>：不进行模块定位，除非该模块是由命令行传入。</p>
<p><code>--noUnusedLocals</code>：如果有未使用的局部变量就报错。</p>
<p><code>--noUnusedParameters</code>：如果有未使用的函数参数就报错。</p>
<p><code>--outDir</code>：指定编译产物的存放目录。</p>
<p><code>--outFile</code>：所有编译产物打包成一个指定文件。</p>
<p><code>--preserveConstEnums</code>：不将<code>const enum</code>结构在生成的代码中，替换成常量。</p>
<p><code>--preserveWatchOutput</code>： watch 模式下不清屏。</p>
<p><code>--pretty</code>：美化显示编译时的终端输出。这是默认值，但是可以关闭<code>--pretty false</code>。</p>
<p><code>--project</code>（或者<code>-p</code>）：指定编译配置文件，或者该文件所在的目录。</p>
<p><code>--removeComments</code>：编译结果中移除代码注释。</p>
<p><code>--resolveJsonModule</code>：允许加载 JSON 文件。</p>
<p><code>--rootDir</code>：指定加载文件所在的根目录，该目录里面的目录结构会被复制到输出目录。</p>
<p><code>--rootDirs</code>：允许模块定位时，多个目录被当成一个虚拟目录。</p>
<p><code>--skipDefaultLibCheck</code>：跳过 TypeScript 内置类型声明文件的类型检查。</p>
<p><code>--skipLibCheck</code>：跳过<code>.d.ts</code>类型声明文件的类型检查。这样可以加快编译速度。</p>
<p><code>--showConfig</code>：终端输出编译配置信息，而不进行配置。</p>
<p><code>--sourcemap</code>：为编译产生的 JS 文件生成 SourceMap 文件（.map 文件）。</p>
<p><code>--sourceRoot</code>：指定 SourceMap 文件里面的 TypeScript 源码根目录位置。</p>
<p><code>--strict</code>：打开 TypeScript 严格检查模式。</p>
<p><code>--strictBindCallApply</code>：bind, call、apply 这三个函数的类型，匹配原始函数。</p>
<p><code>--strictFunctionTypes</code>：如果函数 B 的参数是函数 A 参数的子类型，那么函数 B 不能替代函数 A。</p>
<p><code>--strictNullChecks</code>：对<code>null</code>和<code>undefined</code>进行严格类型检查。</p>
<p><code>--strictPropertyInitialization</code>：类的属性必须进行初始值，但是允许在构造函数里面赋值。</p>
<p><code>--suppressExcessPropertyErrors</code>：关闭对象字面量的多余参数的报错。</p>
<p><code>--target</code>：指定编译出来的 JS 代码的版本，TypeScript 还会在编译时自动加入对应的库类型声明文件。</p>
<p><code>--traceResolution</code>：编译时在终端输出模块解析（moduleResolution）的具体步骤。</p>
<p><code>--typeRoots</code>：设置类型模块所在的目录，替代默认的<code>node_modules/@types</code>。</p>
<p><code>--types</code>：设置<code>typeRoots</code>目录下需要包括在编译之中的类型模块。</p>
<p><code>--version</code>：终端输出 tsc 的版本号。</p>
<p><code>--watch</code>（或者<code>-w</code>）：进入观察模式，只要文件有修改，就会自动重新编译。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-tsc/" data-id="clm60yr0d001tewwl4r7vas24" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-tsconfig.json" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-tsconfig.json/">tsconfig.json</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-tsconfig.json/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>tsconfig.json</code>是 TypeScript 项目的配置文件，放在项目的根目录。反过来说，如果一个目录里面有<code>tsconfig.json</code>，TypeScript 就认为这是项目的根目录。</p>
<p>如果项目源码是 JavaScript，但是想用 TypeScript 处理，那么配置文件的名字是<code>jsconfig.json</code>，它跟<code>tsconfig</code>的写法是一样的。</p>
<p><code>tsconfig.json</code>文件主要供<code>tsc</code>编译器使用，它的命令行参数<code>--project</code>或<code>-p</code>可以指定<code>tsconfig.json</code>的位置（目录或文件皆可）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc -p ./dir</span><br></pre></td></tr></table></figure>

<p>如果不指定配置文件的位置，<code>tsc</code>就会在当前目录下搜索<code>tsconfig.json</code>文件，如果不存在，就到上一级目录搜索，直到找到为止。</p>
<p><code>tsconfig.json</code>文件的格式，是一个 JSON 对象，最简单的情况可以只放置一个空对象<code>&#123;&#125;</code>。下面是一个示例。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./built&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./src/**/*&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>本章后面会详细介绍<code>tsconfig.json</code>的各个属性，这里简单说一下，上面示例的四个属性的含义。</p>
<ul>
<li>include：指定哪些文件需要编译。</li>
<li>allowJs：指定源目录的 JavaScript 文件是否原样拷贝到编译后的目录。</li>
<li>outDir：指定编译产物存放的目录。</li>
<li>target：指定编译产物的 JS 版本。</li>
</ul>
<p><code>tsconfig.json</code>文件可以不必手写，使用 tsc 命令的<code>--init</code>参数自动生成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --init</span><br></pre></td></tr></table></figure>

<p>上面命令生成的<code>tsconfig.json</code>文件，里面会有一些默认配置。</p>
<p>你也可以使用别人预先写好的 tsconfig.json 文件，npm 的<code>@tsconfig</code>名称空间下面有很多模块，都是写好的<code>tsconfig.json</code>样本，比如 <code>@tsconfig/recommended</code>和<code>@tsconfig/node16</code>。</p>
<p>这些模块需要安装，以<code>@tsconfig/deno</code>为例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev @tsconfig/deno</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ yarn add --dev @tsconfig/deno</span><br></pre></td></tr></table></figure>

<p>安装以后，就可以在<code>tsconfig.json</code>里面引用这个模块，相当于继承它的设置，然后进行扩展。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@tsconfig/deno/tsconfig.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>@tsconfig</code>空间下包含的完整 tsconfig 文件目录，可以查看 <a target="_blank" rel="noopener" href="https://github.com/tsconfig/bases/tree/main/bases">GitHub</a>。</p>
<p><code>tsconfig.json</code>的一级属性并不多，只有很少几个，但是<code>compilerOptions</code>属性有很多二级属性。下面先逐一介绍一级属性，然后再介绍<code>compilerOptions</code>的二级属性，按照首字母排序。</p>
<h2 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h2><p><code>exclude</code>属性是一个数组，必须与<code>include</code>属性一起使用，用来从编译列表中去除指定的文件。它也支持使用与<code>include</code>属性相同的通配符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;**/*&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;**/*.spec.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p><code>tsconfig.json</code>可以继承另一个<code>tsconfig.json</code>文件的配置。如果一个项目有多个配置，可以把共同的配置写成<code>tsconfig.base.json</code>，其他的配置文件继承该文件，这样便于维护和修改。</p>
<p><code>extends</code>属性用来指定所要继承的配置文件。它可以是本地文件。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../tsconfig.base.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>extends</code>属性指定的路径不是以<code>./</code>或<code>../</code>开头，那么编译器将在<code>node_modules</code>目录下查找指定的配置文件。</p>
<p><code>extends</code>属性也可以继承已发布的 npm 模块里面的 tsconfig 文件。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@tsconfig/node12/tsconfig.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>extends</code>指定的<code>tsconfig.json</code>会先加载，然后加载当前的<code>tsconfig.json</code>。如果两者有重名的属性，后者会覆盖前者。</p>
<h2 id="files"><a href="#files" class="headerlink" title="files"></a>files</h2><p><code>files</code>属性指定编译的文件列表，如果其中有一个文件不存在，就会报错。</p>
<p>它是一个数组，排在前面的文件先编译。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [<span class="string">&quot;a.ts&quot;</span>, <span class="string">&quot;b.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该属性必须逐一列出文件，不支持文件匹配。如果文件较多，建议使用<code>include</code>和<code>exclude</code>属性。</p>
<h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p><code>include</code>属性指定所要编译的文件列表，既支持逐一列出文件，也支持通配符。文件位置相对于当前配置文件而定。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;src/**/*&quot;</span>, <span class="string">&quot;tests/**/*&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>include</code>属性支持三种通配符。</p>
<ul>
<li><code>?</code>：指代单个字符</li>
<li><code>*</code>：指代任意字符，不含路径分隔符</li>
<li><code>**</code>：指定任意目录层级。</li>
</ul>
<p>如果不指定文件后缀名，默认包括<code>.ts</code>、<code>.tsx</code>和<code>.d.ts</code>文件。如果打开了<code>allowJs</code>，那么还包括<code>.js</code>和<code>.jsx</code>。</p>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><code>references</code>属性是一个数组，数组成员为对象，适合一个大项目由许多小项目构成的情况，用来设置需要引用的底层项目。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;references&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;path&quot;</span>: <span class="string">&quot;../pkg1&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;path&quot;</span>: <span class="string">&quot;../pkg2/tsconfig.json&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>references</code>数组成员对象的<code>path</code>属性，既可以是含有文件<code>tsconfig.json</code>的目录，也可以直接是该文件。</p>
<p>与此同时，引用的底层项目的<code>tsconfig.json</code>必须启用<code>composite</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;composite&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="compileOptions"><a href="#compileOptions" class="headerlink" title="compileOptions"></a>compileOptions</h2><p><code>compilerOptions</code>属性用来定制编译行为。这个属性可以省略，这时编译器将使用默认设置。</p>
<h3 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h3><p><code>allowJs</code>允许 TypeScript 项目加载 JS 脚本。编译时，也会将 JS 文件，一起拷贝到输出目录。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a>alwaysStrict</h3><p><code>alwaysStrict</code>确保脚本以 ECMAScript 严格模式进行解析，因此脚本头部不用写<code>&quot;use strict&quot;</code>。它的值是一个布尔值，默认为<code>true</code>。</p>
<h3 id="allowSyntheticDefaultImports"><a href="#allowSyntheticDefaultImports" class="headerlink" title="allowSyntheticDefaultImports"></a>allowSyntheticDefaultImports</h3><p><code>allowSyntheticDefaultImports</code>允许<code>import</code>命令默认加载没有<code>default</code>输出的模块。</p>
<p>比如，打开这个设置，就可以写<code>import React from &quot;react&quot;;</code>，而不是<code>import * as React from &quot;react&quot;;</code>。</p>
<h3 id="allowUnreachableCode"><a href="#allowUnreachableCode" class="headerlink" title="allowUnreachableCode"></a>allowUnreachableCode</h3><p><code>allowUnreachableCode</code>设置是否允许存在不可能执行到的代码。它的值有三种可能。</p>
<ul>
<li><code>undefined</code>： 默认值，编辑器显示警告。</li>
<li><code>true</code>：忽略不可能执行到的代码。</li>
<li><code>false</code>：编译器报错。</li>
</ul>
<h3 id="allowUnusedLabels"><a href="#allowUnusedLabels" class="headerlink" title="allowUnusedLabels"></a>allowUnusedLabels</h3><p><code>allowUnusedLabels</code>设置是否允许存在没有用到的代码标签（label）。它的值有三种可能。</p>
<ul>
<li><code>undefined</code>： 默认值，编辑器显示警告。</li>
<li><code>true</code>：忽略没有用到的代码标签。</li>
<li><code>false</code>：编译器报错。</li>
</ul>
<h3 id="baseUrl"><a href="#baseUrl" class="headerlink" title="baseUrl"></a>baseUrl</h3><p><code>baseUrl</code>的值为字符串，指定 TypeScript 项目的基准目录。</p>
<p>由于默认是以 tsconfig.json 的位置作为基准目录，所以一般情况不需要使用该属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>baseUrl</code>为当前目录<code>./</code>。那么，当遇到下面的语句，TypeScript 将以<code>./</code>为起点，寻找<code>hello/world.ts</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; helloWorld &#125; <span class="keyword">from</span> <span class="string">&quot;hello/world&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="checkJs"><a href="#checkJs" class="headerlink" title="checkJs"></a>checkJs</h3><p><code>checkJS</code>设置对 JS 文件同样进行类型检查。打开这个属性，也会自动打开<code>allowJs</code>。它等同于在 JS 脚本的头部添加<code>// @ts-check</code>命令。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="composite"><a href="#composite" class="headerlink" title="composite"></a>composite</h3><p><code>composite</code>打开某些设置，使得 TypeScript 项目可以进行增量构建，往往跟<code>incremental</code>属性配合使用。</p>
<h3 id="declaration"><a href="#declaration" class="headerlink" title="declaration"></a>declaration</h3><p><code>declaration</code>设置编译时是否为每个脚本生成类型声明文件<code>.d.ts</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="declarationDir"><a href="#declarationDir" class="headerlink" title="declarationDir"></a>declarationDir</h3><p><code>declarationDir</code>设置生成的<code>.d.ts</code>文件所在的目录。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;declarationDir&quot;</span>: <span class="string">&quot;./types&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="declarationMap"><a href="#declarationMap" class="headerlink" title="declarationMap"></a>declarationMap</h3><p><code>declarationMap</code>设置生成<code>.d.ts</code>类型声明文件的同时，还会生成对应的 Source Map 文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;declarationMap&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emitBOM"><a href="#emitBOM" class="headerlink" title="emitBOM"></a>emitBOM</h3><p><code>emitBOM</code>设置是否在编译结果的文件头添加字节顺序标志 BOM，默认值是<code>false</code>。</p>
<h3 id="emitDeclarationOnly"><a href="#emitDeclarationOnly" class="headerlink" title="emitDeclarationOnly"></a>emitDeclarationOnly</h3><p><code>emitDeclarationOnly</code>设置编译后只生成<code>.d.ts</code>文件，不生成<code>.js</code>文件。</p>
<h3 id="esModuleInterop"><a href="#esModuleInterop" class="headerlink" title="esModuleInterop"></a>esModuleInterop</h3><p><code>esModuleInterop</code>修复了一些 CommonJS 和 ES6 模块之间的兼容性问题。</p>
<p>如果<code>module</code>属性为<code>node16</code>或<code>nodenext</code>，则<code>esModuleInterop</code>默认为<code>true</code>，其他情况默认为<code>false</code>。</p>
<p>打开这个属性，使用<code>import</code>命令加载 CommonJS 模块时，TypeScript 会严格检查兼容性问题是否存在。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span></span><br><span class="line"><span class="title function_">moment</span>(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，根据 ES6 规范，<code>import * as moment</code>里面的<code>moment</code>是一个对象，不能当作函数调用，所以第二行报错了。</p>
<p>解决方法就是改写上面的语句，改成加载默认接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span></span><br><span class="line"><span class="title function_">moment</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>打开<code>esModuleInterop</code>以后，如果将上面的代码编译成 CommonJS 模块格式，就会加入一些辅助函数，保证编译后的代码行为正确。</p>
<p>注意，打开<code>esModuleInterop</code>，将自动打开<code>allowSyntheticDefaultImports</code>。</p>
<h3 id="exactOptionalPropertyTypes"><a href="#exactOptionalPropertyTypes" class="headerlink" title="exactOptionalPropertyTypes"></a>exactOptionalPropertyTypes</h3><p><code>exactOptionalPropertyTypes</code>设置可选属性不能赋值为<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开 exactOptionalPropertyTypes</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  foo?: <span class="string">&#x27;A&#x27;</span> | <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">foo</span>: <span class="string">&#x27;A&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span> = <span class="literal">undefined</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>foo</code>是可选属性，打开<code>exactOptionalPropertyTypes</code>以后，该属性就不能显式赋值为<code>undefined</code>。</p>
<h3 id="forceConsistentCasingInFileNames"><a href="#forceConsistentCasingInFileNames" class="headerlink" title="forceConsistentCasingInFileNames"></a>forceConsistentCasingInFileNames</h3><p><code>forceConsistentCasingInFileNames</code>设置文件名是否为大小写敏感，默认为<code>true</code>。</p>
<h3 id="incremental"><a href="#incremental" class="headerlink" title="incremental"></a>incremental</h3><p><code>incremental</code>让 TypeScript 项目构建时产生文件<code>tsbuildinfo</code>，从而完成增量构建。</p>
<h3 id="inlineSourceMap"><a href="#inlineSourceMap" class="headerlink" title="inlineSourceMap"></a>inlineSourceMap</h3><p><code>inlineSourceMap</code>设置将 SourceMap 文件写入编译后的 JS 文件中，否则会单独生成一个<code>.js.map</code>文件。</p>
<h3 id="inlineSources"><a href="#inlineSources" class="headerlink" title="inlineSources"></a>inlineSources</h3><p><code>inlineSources</code>设置将原始的<code>.ts</code>代码嵌入编译后的 JS 中。</p>
<p>它要求<code>sourceMap</code>或<code>inlineSourceMap</code>至少打开一个。</p>
<h3 id="isolatedModules"><a href="#isolatedModules" class="headerlink" title="isolatedModules"></a>isolatedModules</h3><p><code>isolatedModules</code>设置如果当前 TypeScript 脚本作为单个模块编译，是否会因为缺少其他脚本的类型信息而报错，主要便于非官方的编译工具（比如 Babel）正确编译单个脚本。</p>
<h3 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h3><p><code>jsx</code>设置如何处理<code>.tsx</code>文件。它可以取以下五个值。</p>
<ul>
<li><code>preserve</code>：保持 jsx 语法不变，输出的文件名为<code>.jsx</code>。</li>
<li><code>react</code>：将<code>&lt;div /&gt;</code>编译成<code>React.createElement(&quot;div&quot;)</code>，输出的文件名为<code>.js</code>。</li>
<li><code>react-native</code>：保持 jsx 语法不变，输出的文件后缀名为<code>.js</code>。</li>
<li><code>react-jsx</code>：将<code>&lt;div /&gt;</code>编译成<code>_jsx(&quot;div&quot;)</code>，输出的文件名为<code>.js</code>。</li>
<li><code>react-jsxdev</code>：跟<code>react-jsx</code>类似，但是为<code>_jsx()</code>加上更多的开发调试项，输出的文件名为<code>.js</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p><code>lib</code>值是一个数组，描述项目需要加载的 TypeScript 内置类型描述文件，跟三斜线指令<code>/// &lt;reference lib=&quot;&quot; /&gt;</code>作用相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;dom&quot;</span>, <span class="string">&quot;es2021&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 内置的类型描述文件，主要有以下一些，完整的清单可以参考 <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/tree/main/src/lib">TypeScript 源码</a>。</p>
<ul>
<li>ES5</li>
<li>ES2015</li>
<li>ES6</li>
<li>ES2016</li>
<li>ES7</li>
<li>ES2017</li>
<li>ES2018</li>
<li>ES2019</li>
<li>ES2020</li>
<li>ES2021</li>
<li>ES2022</li>
<li>ESNext</li>
<li>DOM</li>
<li>WebWorker</li>
<li>ScriptHost</li>
</ul>
<h3 id="listEmittedFiles"><a href="#listEmittedFiles" class="headerlink" title="listEmittedFiles"></a>listEmittedFiles</h3><p><code>listEmittedFiles</code>设置编译时在终端显示，生成了哪些文件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;listEmittedFiles&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listFiles"><a href="#listFiles" class="headerlink" title="listFiles"></a>listFiles</h3><p><code>listFiles</code>设置编译时在终端显示，参与本次编译的文件列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;listFiles&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mapRoot"><a href="#mapRoot" class="headerlink" title="mapRoot"></a>mapRoot</h3><p><code>mapRoot</code>指定 SourceMap 文件的位置，而不是默认的生成位置。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;mapRoot&quot;</span>: <span class="string">&quot;https://my-website.com/debug/sourcemaps/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p><code>module</code>指定编译产物的模块格式。它的默认值与<code>target</code>属性有关，如果<code>target</code>是<code>ES3</code>或<code>ES5</code>，它的默认值是<code>commonjs</code>，否则就是<code>ES6/ES2015</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>它可以取以下值：none、commonjs、amd、umd、system、es6&#x2F;es2015、es2020、es2022、esnext、node16、nodenext。</p>
<h3 id="moduleResolution"><a href="#moduleResolution" class="headerlink" title="moduleResolution"></a>moduleResolution</h3><p><code>moduleResolution</code>确定模块路径的算法，即如何查找模块。它可以取以下四种值。</p>
<ul>
<li><code>node</code>：采用 Node.js 的 CommonJS 模块算法。</li>
<li><code>node16</code>或<code>nodenext</code>：采用 Node.js 的 ECMAScript 模块算法，从 TypeScript 4.7 开始支持。</li>
<li><code>classic</code>：TypeScript 1.6 之前的算法，新项目不建议使用。</li>
<li><code>bundler</code>：TypeScript 5.0 新增的选项，表示当前代码会被其他打包器（比如 Webpack、Vite、esbuild、Parcel、rollup、swc）处理，从而放宽加载规则，它要求<code>module</code>设为<code>es2015</code>或更高版本，详见加入该功能的 <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51669">PR 说明</a>。</li>
</ul>
<p>它的默认值与<code>module</code>属性有关，如果<code>module</code>为<code>AMD</code>、<code>UMD</code>、<code>System</code>或<code>ES6/ES2015</code>，默认值为<code>classic</code>；如果<code>module</code>为<code>node16</code>或<code>nodenext</code>，默认值为这两个值；其他情况下,默认值为<code>Node</code>。</p>
<h3 id="moduleSuffixes"><a href="#moduleSuffixes" class="headerlink" title="moduleSuffixes"></a>moduleSuffixes</h3><p><code>moduleSuffixes</code>指定模块的后缀名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;moduleSuffixes&quot;</span>: [<span class="string">&quot;.ios&quot;</span>, <span class="string">&quot;.native&quot;</span>, <span class="string">&quot;&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的设置使得 TypeScript 对于语句<code>import * as foo from &quot;./foo&quot;;</code>，会搜索以下脚本<code>./foo.ios.ts</code>、<code>./foo.native.ts</code>和<code>./foo.ts</code>。</p>
<h3 id="newLine"><a href="#newLine" class="headerlink" title="newLine"></a>newLine</h3><p><code>newLine</code>设置换行符为<code>CRLF</code>（Windows）还是<code>LF</code>（Linux）。</p>
<h3 id="noEmit"><a href="#noEmit" class="headerlink" title="noEmit"></a>noEmit</h3><p><code>noEmit</code>设置是否产生编译结果。如果不生成，TypeScript 编译就纯粹作为类型检查了。</p>
<h3 id="noEmitHelpers"><a href="#noEmitHelpers" class="headerlink" title="noEmitHelpers"></a>noEmitHelpers</h3><p><code>noEmitHelpers</code>设置在编译结果文件不插入 TypeScript 辅助函数，而是通过外部引入辅助函数来解决，比如 NPM 模块<code>tslib</code>。</p>
<h3 id="noEmitOnError"><a href="#noEmitOnError" class="headerlink" title="noEmitOnError"></a>noEmitOnError</h3><p><code>noEmitOnError</code>指定一旦编译报错，就不生成编译产物，默认为<code>false</code>。</p>
<h3 id="noFallthroughCasesInSwitch"><a href="#noFallthroughCasesInSwitch" class="headerlink" title="noFallthroughCasesInSwitch"></a>noFallthroughCasesInSwitch</h3><p><code>noFallthroughCasesInSwitch</code>设置是否对没有<code>break</code>语句（或者<code>return</code>和<code>throw</code>语句）的 switch 分支报错，即<code>case</code>代码里面必须有终结语句（比如<code>break</code>）。</p>
<h3 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h3><p><code>noImplicitAny</code>设置当一个表达式没有明确的类型描述、且编译器无法推断出具体类型时，是否允许将它推断为<code>any</code>类型。</p>
<p>它是一个布尔值，默认为<code>true</code>，即只要推断出<code>any</code>类型就报错。</p>
<h3 id="noImplicitReturns"><a href="#noImplicitReturns" class="headerlink" title="noImplicitReturns"></a>noImplicitReturns</h3><p><code>noImplicitReturns</code>设置是否要求函数任何情况下都必须返回一个值，即函数必须有<code>return</code>语句。</p>
<h3 id="noImplicitThis"><a href="#noImplicitThis" class="headerlink" title="noImplicitThis"></a>noImplicitThis</h3><p><code>noImplicitThis</code>设置如果<code>this</code>被推断为<code>any</code>类型是否报错。</p>
<h3 id="noUnusedLocals"><a href="#noUnusedLocals" class="headerlink" title="noUnusedLocals"></a>noUnusedLocals</h3><p><code>noUnusedLocals</code>设置是否允许未使用的局部变量。</p>
<h3 id="noUnusedParameters"><a href="#noUnusedParameters" class="headerlink" title="noUnusedParameters"></a>noUnusedParameters</h3><p><code>noUnusedParameters</code>设置是否允许未使用的函数参数。</p>
<h3 id="outDir"><a href="#outDir" class="headerlink" title="outDir"></a>outDir</h3><p><code>outDir</code>指定编译产物的存放目录。如果不指定，编译出来的<code>.js</code>文件存放在对应的<code>.ts</code>文件的相同位置。</p>
<h3 id="outFile"><a href="#outFile" class="headerlink" title="outFile"></a>outFile</h3><p><code>outFile</code>设置将所有非模块的全局文件，编译在同一个文件里面。它只有在<code>module</code>属性为<code>None</code>、<code>System</code>、<code>AMD</code>时才生效，并且不能用来打包 CommonJS 或 ES6 模块。</p>
<h3 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h3><p><code>paths</code>设置模块名和模块路径的映射，也就是 TypeScript 如何导入<code>require</code>或<code>imports</code>语句加载的模块。</p>
<p><code>paths</code>基于<code>baseUrl</code>进行加载，所以必须同时设置后者。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;b&quot;</span>: [<span class="string">&quot;bar/b&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它还可以使用通配符“*”。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@bar/*&quot;</span>: [<span class="string">&quot;bar/*&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preserveConstEnums"><a href="#preserveConstEnums" class="headerlink" title="preserveConstEnums"></a>preserveConstEnums</h3><p><code>preserveConstEnums</code>将<code>const enum</code>结构保留下来，不替换成常量值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;preserveConstEnums&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pretty"><a href="#pretty" class="headerlink" title="pretty"></a>pretty</h3><p><code>pretty</code>设置美化输出终端的编译信息，默认为<code>true</code>。</p>
<h3 id="removeComments"><a href="#removeComments" class="headerlink" title="removeComments"></a>removeComments</h3><p><code>removeComments</code>移除 TypeScript 脚本里面的注释，默认为<code>false</code>。</p>
<h3 id="resolveJsonModule"><a href="#resolveJsonModule" class="headerlink" title="resolveJsonModule"></a>resolveJsonModule</h3><p><code>resolveJsonModule</code>允许 import 命令导入 JSON 文件。</p>
<h3 id="rootDir"><a href="#rootDir" class="headerlink" title="rootDir"></a>rootDir</h3><p><code>rootDir</code>设置源码脚本所在的目录，主要跟编译后的脚本结构有关。<code>rootDir</code>对应目录下的所有脚本，会成为输出目录里面的顶层脚本。</p>
<h3 id="rootDirs"><a href="#rootDirs" class="headerlink" title="rootDirs"></a>rootDirs</h3><p><code>rootDirs</code>把多个不同目录，合并成一个目虚拟目录，便于模块定位。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;rootDirs&quot;</span>: [<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;foo&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>rootDirs</code>将<code>bar</code>和<code>foo</code>组成一个虚拟目录。</p>
<h3 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h3><p><code>sourceMap</code>设置编译时是否生成 SourceMap 文件。</p>
<h3 id="sourceRoot"><a href="#sourceRoot" class="headerlink" title="sourceRoot"></a>sourceRoot</h3><p><code>sourceRoot</code>在 SourceMap 里面设置 TypeScript 源文件的位置。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;sourceRoot&quot;</span>: <span class="string">&quot;https://my-website.com/debug/source/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h3><p><code>strict</code>用来打开 TypeScript 的严格检查。它的值是一个布尔值，默认是关闭的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设置相当于同时打开以下的一系列设置。</p>
<ul>
<li>alwaysStrict</li>
<li>strictNullChecks</li>
<li>strictBindCallApply</li>
<li>strictFunctionTypes</li>
<li>strictPropertyInitialization</li>
<li>noImplicitAny</li>
<li>noImplicitThis</li>
<li>useUnknownInCatchVaria</li>
</ul>
<p>打开<code>strict</code>的时候，允许单独关闭其中一项。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="strictBindCallApply"><a href="#strictBindCallApply" class="headerlink" title="strictBindCallApply"></a>strictBindCallApply</h3><p><code>strictBindCallApply</code>设置是否对函数的<code>call()</code>、<code>bind()</code>、<code>apply()</code>这三个方法进行类型检查。</p>
<p>如果不打开<code>strictBindCallApply</code>编译选项，编译器不会对以上三个方法进行类型检查，参数类型都是<code>any</code>，传入任何参数都不会产生编译错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strictBindCallApply:false</span></span><br><span class="line"><span class="keyword">const</span> n = fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 以上不报错</span></span><br></pre></td></tr></table></figure>

<h3 id="strictFunctionTypes"><a href="#strictFunctionTypes" class="headerlink" title="strictFunctionTypes"></a>strictFunctionTypes</h3><p><code>strictFunctionTypes</code>允许对函数更严格的参数检查。具体来说，如果函数 B 的参数是函数 A 参数的子类型，那么函数 B 不能替代函数 A。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + x.<span class="title function_">toLowerCase</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumberFunc</span> = <span class="function">(<span class="params">ns:<span class="built_in">string</span>|<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开 strictFunctionTypes，下面代码会报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func</span>:<span class="title class_">StringOrNumberFunc</span> = fn;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>fn()</code>的参数是<code>StringOrNumberFunc</code>参数的子集，因此<code>fn</code>不能替代<code>StringOrNumberFunc</code>。</p>
<h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h3><p><code>strictNullChecks</code>设置对<code>null</code>和<code>undefined</code>进行严格类型检查。如果打开<code>strict</code>属性，这一项就会自动设为<code>true</code>，否则为<code>false</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> value:string;</span><br><span class="line"></span><br><span class="line">// strictNullChecks:<span class="literal">false</span></span><br><span class="line">// 下面语句不报错</span><br><span class="line">value = null;</span><br></pre></td></tr></table></figure>

<p>它可以理解成只要打开，就需要显式检查<code>null</code>或<code>undefined</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">x:<span class="built_in">string</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + x.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strictPropertyInitialization"><a href="#strictPropertyInitialization" class="headerlink" title="strictPropertyInitialization"></a>strictPropertyInitialization</h3><p><code>strictPropertyInitialization</code>设置类的实例属性都必须初始化，包括以下几种情况。</p>
<ul>
<li>设为<code>undefined</code>类型</li>
<li>显式初始化</li>
<li>构造函数中赋值</li>
</ul>
<p>注意，使用该属性的同时，必须打开<code>strictNullChecks</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strictPropertyInitialization：true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="comment">// 报错，属性 username 没有初始化</span></span><br><span class="line">  <span class="attr">username</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  username = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">username</span>:<span class="built_in">string</span>|<span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法三</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">username</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">username:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">username</span> = username;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> username:<span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法四：赋值断言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  username!:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">username:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initialize</span>(username);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">initialize</span>(<span class="params">username:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">username</span> = username;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="suppressExcessPropertyErrors"><a href="#suppressExcessPropertyErrors" class="headerlink" title="suppressExcessPropertyErrors"></a>suppressExcessPropertyErrors</h3><p><code>suppressExcessPropertyErrors</code>关闭对象字面量的多余参数的报错。</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p><code>target</code>指定编译出来的 JavaScript 代码的 ECMAScript 版本，比如<code>es2021</code>，默认是<code>es3</code>。</p>
<p>它可以取以下值。</p>
<ul>
<li>es3</li>
<li>es5</li>
<li>es6&#x2F;es2015</li>
<li>es2016</li>
<li>es2017</li>
<li>es2018</li>
<li>es2019</li>
<li>es2020</li>
<li>es2021</li>
<li>es2022</li>
<li>esnext</li>
</ul>
<p>注意，如果编译的目标版本过老，比如<code>&quot;target&quot;: &quot;es3&quot;</code>，有些语法可能无法编译，<code>tsc</code>命令会报错。</p>
<h3 id="traceResolution"><a href="#traceResolution" class="headerlink" title="traceResolution"></a>traceResolution</h3><p><code>traceResolution</code>设置编译时，在终端输出模块解析的具体步骤。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;traceResolution&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeRoots"><a href="#typeRoots" class="headerlink" title="typeRoots"></a>typeRoots</h3><p><code>typeRoots</code>设置类型模块所在的目录，默认是<code>node_modules/@types</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [<span class="string">&quot;./typings&quot;</span>, <span class="string">&quot;./vendor/types&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><p><code>types</code>设置<code>typeRoots</code>目录下需要包括在编译之中的类型模块。默认情况下，该目录下的所有类型模块，都会自动包括在编译之中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;types&quot;</span>: [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;jest&quot;</span>, <span class="string">&quot;express&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useUnknownInCatchVariables"><a href="#useUnknownInCatchVariables" class="headerlink" title="useUnknownInCatchVariables"></a>useUnknownInCatchVariables</h3><p><code>useUnknownInCatchVariables</code>设置<code>catch</code>语句捕获的<code>try</code>抛出的返回值类型，从<code>any</code>变成<code>unknown</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">someExternalFunction</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  err; <span class="comment">// 类型 any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，默认情况下，<code>catch</code>语句的参数<code>err</code>类型是<code>any</code>，即可以是任何值。</p>
<p>打开<code>useUnknownInCatchVariables</code>以后，<code>err</code>的类型抛出的错误将是<code>unknown</code>类型。这带来的变化就是使用<code>err</code>之前，必须缩小它的类型，否则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">someExternalFunction</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mariusschulz.com/blog/strict-property-initialization-in-typescript">Strict Property Initialization in TypeScript</a>, Marius Schulz</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-tsconfig.json/" data-id="clm60yr0e001vewwlbq19gihm" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-tuple" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-tuple/">TypeScript 的元组类型</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-tuple/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。</p>
<p>由于成员的类型可以不一样，所以元组必须明确声明每个成员的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s</span>:[<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>]</span><br><span class="line">  = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组<code>s</code>的前两个成员的类型是<code>string</code>，最后一个成员的类型是<code>boolean</code>。</p>
<p>元组类型的写法，与上一章的数组有一个重大差异。数组的成员类型写在方括号外面（<code>number[]</code>），元组的成员类型是写在方括号里面（<code>[number]</code>）。TypeScript 的区分方法就是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">t</span>:[<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>和<code>t</code>的值都是<code>[1]</code>，但是它们的类型是不一样的。<code>a</code>是一个数组，成员类型<code>number</code>写在方括号外面；<code>t</code>是一个元组，成员类型<code>number</code>写在方括号里面。</p>
<p>使用元组时，必须明确给出类型声明（上例的<code>[number]</code>），不能省略，否则 TypeScript 会把一个值自动推断为数组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 的类型被推断为 (number | boolean)[]</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>的值其实是一个元组，但是 TypeScript 会将其推断为一个联合类型的数组，即<code>a</code>的类型为<code>(number | boolean)[]</code>。所以，元组必须显式给出类型声明。</p>
<p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:[<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组<code>a</code>的第二个成员是可选的，可以省略。</p>
<p>注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myTuple = [</span><br><span class="line">  <span class="built_in">number</span>,</span><br><span class="line">  <span class="built_in">number</span>,</span><br><span class="line">  <span class="built_in">number</span>?,</span><br><span class="line">  <span class="built_in">string</span>?</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组<code>myTuple</code>的最后两个成员是可选的。也就是说，它的成员数量可能有两个、三个和四个。</p>
<p>由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:[<span class="built_in">string</span>, <span class="built_in">string</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line">x[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>是一个只有两个成员的元组，如果对第三个成员赋值就报错了。</p>
<p>但是，使用扩展运算符（<code>...</code>），可以表示不限成员数量的元组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NamedNums</span> = [</span><br><span class="line">  <span class="built_in">string</span>,</span><br><span class="line">  ...<span class="built_in">number</span>[]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="title class_">NamedNums</span> = [<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">NamedNums</span> = [<span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组类型<code>NamedNums</code>的第一个成员是字符串，后面的成员使用扩展运算符来展开一个数组，从而实现了不定数量的成员。</p>
<p>扩展运算符（<code>...</code>）用在元组的任意位置都可以，它的后面只能是一个数组或元组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];</span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t3 = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，扩展运算符分别在元组的尾部、中部和头部，<code>...</code>的后面是一个数组<code>boolean[]</code>。</p>
<p>如果不确定元组成员的类型和数量，可以写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [...<span class="built_in">any</span>[]];</span><br></pre></td></tr></table></figure>

<p>上面示例中，元组<code>Tuple</code>可以放置任意数量和类型的成员。但是这样写，也就失去了使用元组和 TypeScript 的意义。</p>
<p>元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = [</span><br><span class="line">  <span class="attr">red</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">green</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">blue</span>: <span class="built_in">number</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:<span class="title class_">Color</span> = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Color</code>是一个元组，它有三个成员。每个成员都有一个名字，写在具体类型的前面，使用冒号分隔。这几个名字可以随便取，没有实际作用，只是用来说明每个成员的含义。</p>
<p>元组可以通过方括号，读取成员类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Tuple</span>[<span class="number">1</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Tuple[1]</code>返回1号位置的成员类型。</p>
<p>由于元组的成员都是数值索引，即索引类型都是<code>number</code>，所以可以像下面这样读取。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="title class_">Date</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TupleEl</span> = <span class="title class_">Tuple</span>[<span class="built_in">number</span>];  <span class="comment">// string|number|Date</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Tuple[number]</code>表示元组<code>Tuple</code>的所有数值索引的成员类型，所以返回<code>string|number|Date</code>，即这个类型是三种值的联合类型。</p>
<h2 id="只读元组"><a href="#只读元组" class="headerlink" title="只读元组"></a>只读元组</h2><p>元组也可以是只读的，不允许修改，有两种写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">type</span> t = <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">string</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">type</span> t = <span class="title class_">Readonly</span>&lt;[<span class="built_in">number</span>, <span class="built_in">string</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种写法都可以得到只读元组，其中写法二是一个泛型，用到了工具类型<code>Readonly&lt;T&gt;</code>。</p>
<p>跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而只读元组不能替代元组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:t2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:t1 = x; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>t1</code>是只读元组，类型<code>t2</code>是普通元组。<code>t2</code>类型可以赋值给<code>t1</code>类型，反过来就会报错。</p>
<p>由于只读元组不能替代元组，所以会产生一些令人困惑的报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distanceFromOrigin</span>(<span class="params">[x, y]:[<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(x**<span class="number">2</span> + y**<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point = [<span class="number">3</span>, <span class="number">4</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">distanceFromOrigin</span>(point); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>distanceFromOrigin()</code>的参数是一个元组，传入只读元组就会报错，因为只读元组不能替代元组。</p>
<p>读者可能注意到了，上例中<code>[3, 4] as const</code>的写法，在上一章讲到，生成的是只读数组，其实生成的同时也是只读元组。因为它生成的实际上是一个只读的“值类型”<code>readonly [3, 4]</code>，把它解读成只读数组或只读元组都可以。</p>
<p>上面示例报错的解决方法，就是使用类型断言，在最后一行将传入的参数断言为普通元组，详见《类型断言》一章。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">distanceFromOrigin</span>(</span><br><span class="line">  point <span class="keyword">as</span> [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="成员数量的推断"><a href="#成员数量的推断" class="headerlink" title="成员数量的推断"></a>成员数量的推断</h2><p>如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">point: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (point.<span class="property">length</span> === <span class="number">3</span>) &#123;  <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例会报错，原因是 TypeScript 发现元组<code>point</code>的长度是<code>2</code>，不可能等于<code>3</code>，这个判断无意义。</p>
<p>如果包含了可选成员，TypeScript 会推断出可能的成员数量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span></span><br><span class="line"><span class="params">  point:[<span class="built_in">number</span>, <span class="built_in">number</span>?, <span class="built_in">number</span>?]</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (point.<span class="property">length</span> === <span class="number">4</span>) &#123;  <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例会报错，原因是 TypeScript 发现<code>point.length</code>的类型是<code>1|2|3</code>，不可能等于<code>4</code>。</p>
<p>如果使用了扩展运算符，TypeScript 就无法推断出成员数量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">myTuple</span>:[...<span class="built_in">string</span>[]]</span><br><span class="line">  = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myTuple.<span class="property">length</span> === <span class="number">4</span>) &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>myTuple</code>只有三个成员，但是 TypeScript 推断不出它的成员数量，因为它的类型用到了扩展运算符，TypeScript 把<code>myTuple</code>当成数组看待，而数组的成员数量是不确定的。</p>
<p>一旦扩展运算符使得元组的成员数量无法推断，TypeScript 内部就会把该元组当成数组处理。</p>
<h2 id="扩展运算符与成员数量"><a href="#扩展运算符与成员数量" class="headerlink" title="扩展运算符与成员数量"></a>扩展运算符与成员数量</h2><p>扩展运算符（<code>...</code>）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。</p>
<p>这导致如果函数调用时，使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(...arr) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例会报错，原因是函数<code>add()</code>只能接受两个参数，但是传入的是<code>...arr</code>，TypeScript 认为转换后的参数个数是不确定的。</p>
<p>有些函数可以接受任意数量的参数，这时使用扩展运算符就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>console.log()</code>可以接受任意数量的参数，所以传入<code>...arr</code>就不会报错。</p>
<p>解决这个问题的一个方法，就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:[<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(...arr) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>arr</code>是一个拥有两个成员的元组，所以 TypeScript 能够确定<code>...arr</code>可以匹配函数<code>add()</code>的参数数量，就不会报错了。</p>
<p>另一种写法是使用<code>as const</code>断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<p>上面这种写法也可以，因为 TypeScript 会认为<code>arr</code>的类型是<code>readonly [1, 2]</code>，这是一个只读的值类型，可以当作数组，也可以当作元组。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-tuple/" data-id="clm60yr0f001xewwlddj48272" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-ts-type-operations" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2023/09/05/ts-type-operations/">类型运算</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-type-operations/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <div id="readmore-container"><h2 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h2><p>改变成员类型的顺序不影响联合类型的结果类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>对部分类型成员使用分组运算符不影响联合类型的结果类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = (<span class="built_in">boolean</span> | <span class="built_in">string</span>) | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">boolean</span> | (<span class="built_in">string</span> | <span class="built_in">number</span>);</span><br></pre></td></tr></table></figure>

<p>联合类型的成员类型可以进行化简。假设有联合类型“U &#x3D; T0 | T1”，如果T1是T0的子类型，那么可以将类型成员T1从联合类型U中消去。最后，联合类型U的结果类型为“U &#x3D; T0”。例如，有联合类型“boolean | true | false”。其中，true类型和false类型是boolean类型的子类型，因此可以将true类型和false类型从联合类型中消去。最终，联合类型“boolean | true | false”的结果类型为boolean类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="built_in">boolean</span> | <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以T0等同于 T1</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">boolean</span>;</span><br></pre></td></tr></table></figure>

<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>&amp;</code>的优先级高于<code>|</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &amp; B | C &amp; D</span><br><span class="line"><span class="comment">// 该类型等同于如下类型：</span></span><br><span class="line">(A &amp; B) | (C &amp; D)</span><br></pre></td></tr></table></figure>

<p>分配律</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &amp; (B | C) </span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">(A &amp; B) | (A &amp; C)</span><br></pre></td></tr></table></figure>

<p>一个稍微复杂的类型等式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(A | B) &amp; (C | D) ≡ A &amp; C | A &amp; D | B &amp; C | B &amp; D</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T = (<span class="built_in">string</span> | <span class="number">0</span>) &amp; (<span class="built_in">number</span> | <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">T = (<span class="built_in">string</span> &amp; <span class="built_in">number</span>) | (<span class="built_in">string</span> &amp; <span class="string">&#x27;a&#x27;</span>) | (<span class="number">0</span> &amp; <span class="built_in">number</span>) | (<span class="number">0</span> &amp; <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">T = <span class="built_in">never</span> | <span class="string">&#x27;a&#x27;</span> | <span class="number">0</span> | <span class="built_in">never</span>;</span><br><span class="line">T = <span class="string">&#x27;a&#x27;</span> | <span class="number">0</span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> extend&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U): T &amp; U &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  for (let id in first) &#123;</span><br><span class="line">    (&lt;T&gt;result)[id] = first[id];</span><br><span class="line">  &#125;</span><br><span class="line">  for (let id in second) &#123;</span><br><span class="line">    if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;U&gt;result)[id] = second[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x = extend(&#123; a: &#x27;hello&#x27; &#125;, &#123; b: 42 &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><p>never 可以视为空集。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NeverIntersection</span> = <span class="built_in">never</span> &amp; <span class="built_in">string</span>; <span class="comment">// Type: never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NeverUnion</span> = <span class="built_in">never</span> | <span class="built_in">string</span>; <span class="comment">// Type: string</span></span><br></pre></td></tr></table></figure>

<p>很适合在交叉类型中用作过滤。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OnlyStrings</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? T : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RedOrBlue</span> = <span class="title class_">OnlyStrings</span>&lt;<span class="string">&quot;red&quot;</span> | <span class="string">&quot;blue&quot;</span> | <span class="number">0</span> | <span class="literal">false</span>&gt;;</span><br><span class="line"><span class="comment">// Equivalent to: &quot;red&quot; | &quot;blue&quot;</span></span><br></pre></td></tr></table></figure>

<p>范例：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play#example/conditional-types">https://www.typescriptlang.org/play#example/conditional-types</a></p>
<h2 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a>unknown 类型</h2><p>在联合类型中，unknown吸收所有类型。这意味着如果任何组成类型是unknown，则联合类型的计算结果为unknown。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In an intersection everything absorbs unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T00</span> = <span class="built_in">unknown</span> &amp; <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T01</span> = <span class="built_in">unknown</span> &amp; <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T02</span> = <span class="built_in">unknown</span> &amp; <span class="literal">null</span> &amp; <span class="literal">undefined</span>; <span class="comment">// null &amp; undefined (which becomes never)</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T03</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">string</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T04</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">string</span>[]; <span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T05</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">unknown</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T06</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">any</span>; <span class="comment">// any</span></span><br><span class="line"><span class="comment">// In a union an unknown absorbs everything</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T10</span> = <span class="built_in">unknown</span> | <span class="literal">null</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T11</span> = <span class="built_in">unknown</span> | <span class="literal">undefined</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T12</span> = <span class="built_in">unknown</span> | <span class="literal">null</span> | <span class="literal">undefined</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T13</span> = <span class="built_in">unknown</span> | <span class="built_in">string</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T14</span> = <span class="built_in">unknown</span> | <span class="built_in">string</span>[]; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T15</span> = <span class="built_in">unknown</span> | <span class="built_in">unknown</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T16</span> = <span class="built_in">unknown</span> | <span class="built_in">any</span>; <span class="comment">// any</span></span><br><span class="line"><span class="comment">// Type variable and unknown in union and intersection</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T20</span>&lt;T&gt; = T &amp; &#123;&#125;; <span class="comment">// T &amp; &#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T21</span>&lt;T&gt; = T | &#123;&#125;; <span class="comment">// T | &#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T22</span>&lt;T&gt; = T &amp; <span class="built_in">unknown</span>; <span class="comment">// T</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T23</span>&lt;T&gt; = T | <span class="built_in">unknown</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="comment">// unknown in conditional types</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T30</span>&lt;T&gt; = <span class="built_in">unknown</span> <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// Deferred</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T31</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">unknown</span> ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// Deferred (so it distributes)</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T32</span>&lt;T&gt; = <span class="built_in">never</span> <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T33</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">never</span> ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// Deferred</span></span><br></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType1</span> = <span class="built_in">unknown</span> | <span class="literal">null</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType2</span> = <span class="built_in">unknown</span> | <span class="literal">undefined</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType3</span> = <span class="built_in">unknown</span> | <span class="built_in">string</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType4</span> = <span class="built_in">unknown</span> | <span class="built_in">number</span>[]; <span class="comment">// unknown</span></span><br></pre></td></tr></table></figure>

<p>该规则的一个例外是any。如果至少有一种构成类型是any，则联合类型的计算结果为any：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionType5</span> = <span class="built_in">unknown</span> | <span class="built_in">any</span>; <span class="comment">// any</span></span><br></pre></td></tr></table></figure>

<p>在交叉类型中，每种类型都吸收unknown. 这意味着与任何类型相交unknown不会改变结果类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType1</span> = <span class="built_in">unknown</span> &amp; <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType2</span> = <span class="built_in">unknown</span> &amp; <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType3</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">string</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType4</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">number</span>[]; <span class="comment">// number[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType5</span> = <span class="built_in">unknown</span> &amp; <span class="built_in">any</span>; <span class="comment">// any</span></span><br></pre></td></tr></table></figure>

<p>除非使用<code>as</code>断言，首先缩小类型<code>unknown</code>类型的范围，然后才可以用于其他类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">value</span>: <span class="built_in">unknown</span> = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">someString</span>: <span class="built_in">string</span> = value <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">const</span> otherString = someString.<span class="title function_">toUpperCase</span>(); <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>如果类型是多个值的联合，甚至可以产生插值的效果。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EmailLocaleIDs</span> = <span class="string">&quot;welcome_email&quot;</span> | <span class="string">&quot;email_heading&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooterLocaleIDs</span> = <span class="string">&quot;footer_title&quot;</span> | <span class="string">&quot;footer_sendoff&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 type AllLocaleIDs = &quot;welcome_email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AllLocaleIDs</span> = <span class="string">`<span class="subst">$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;</span>_id`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Brightness</span> = <span class="string">&quot;dark&quot;</span> | <span class="string">&quot;light&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&quot;blue&quot;</span> | <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BrightnessAndColor</span> = <span class="string">`<span class="subst">$&#123;Brightness&#125;</span>-<span class="subst">$&#123;Color&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// Equivalent to: &quot;dark-red&quot; | &quot;light-red&quot; | &quot;dark-blue&quot; | &quot;light-blue&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果交叉类型中存在多个相同的成员类型，那么相同的成员类型将被合并为单一成员类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">boolean</span> &amp; <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="built_in">boolean</span> &amp; <span class="built_in">boolean</span> &amp; <span class="built_in">boolean</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，T0、T1和T2都表示同一种类型boolean。</p>
<p>改变成员类型的顺序不影响交叉类型的结果类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">    <span class="title function_">click</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Focusable</span> &#123;</span><br><span class="line">    <span class="title function_">focus</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Clickable</span> &amp; <span class="title class_">Focusable</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Focusable</span> &amp; <span class="title class_">Clickable</span>;</span><br></pre></td></tr></table></figure>
<p>注意，当交叉类型涉及调用签名重载或构造签名重载时便失去了“加法交换律”的性质。因为交叉类型中成员类型的顺序将决定重载签名的顺序，进而将影响重载签名的解析顺序。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">    <span class="title function_">register</span>(<span class="attr">x</span>: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Focusable</span> &#123;</span><br><span class="line">    <span class="title function_">register</span>(<span class="attr">x</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClickableAndFocusable</span> = <span class="title class_">Clickable</span> &amp; <span class="title class_">Focusable</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FocusableAndFocusable</span> = <span class="title class_">Focusable</span> &amp; <span class="title class_">Clickable</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span></span><br><span class="line"><span class="params">    clickFocus: ClickableAndFocusable,</span></span><br><span class="line"><span class="params">    focusClick: FocusableAndFocusable</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">void</span> = clickFocus.<span class="title function_">register</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">boolean</span> = focusClick.<span class="title function_">register</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例第8行和第9行使用不同的成员类型顺序定义了两个交叉类型。第15行，调用“register()”方法的返回值类型为void，说明在ClickableAndFocusable类型中，Clickable接口中定义的“register()”方法具有更高的优先级。第16行，调用“register()”方法的返回值类型为boolean，说明FocusableAndFocusable类型中Focusable接口中定义的“register()”方法具有更高的优先级。此例也说明了调用签名重载的顺序与交叉类型中成员类型的定义顺序是一致的。</p>
<p>对部分类型成员使用分组运算符不影响交叉类型的结果类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">  <span class="title function_">click</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Focusable</span> &#123;</span><br><span class="line">  <span class="title function_">focus</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Scrollable</span> &#123;</span><br><span class="line">  <span class="title function_">scroll</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = (<span class="title class_">Clickable</span> &amp; <span class="title class_">Focusable</span>) &amp; <span class="title class_">Scrollable</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Clickable</span> &amp; (<span class="title class_">Focusable</span> &amp; <span class="title class_">Scrollable</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例的T0和T1类型是同一种类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Combined</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span> &#125; &amp; &#123; <span class="attr">b</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Conflicting</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span> &#125; &amp; &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>只要交叉类型I中任意一个成员类型包含了属性签名M，那么交叉类型I也包含属性签名M。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交叉类型如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若交叉类型的属性签名M在所有成员类型中都是可选属性，那么该属性签名在交叉类型中也是可选属性。否则，属性签名M是一个必选属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    y?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    x?: <span class="built_in">boolean</span>;</span><br><span class="line">    y?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交叉类型如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    y?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-type-operations/" data-id="clm60yr0g001zewwl3fpv35n6" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>没有梦想的程序员 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="没有梦想的程序员"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/TS%E6%95%99%E7%A8%8B">TS教程</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
      <li class="nav-item">
        <div id="translate"></div>
      </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

<!--添加多语言翻译效果-->
<script src="https://res.zvo.cn/translate/translate.js"></script>
<script>
  translate.setUseVersion2(); //设置使用v2.x 版本
  translate.language.setLocal('chinese_simplified'); //设置本地语种（当前网页的语种）。如果不设置，默认自动识别当前网页显示文字的语种。 可填写如 'english'、'chinese_simplified' 等，具体参见文档下方关于此的说明。
  translate.execute();//进行翻译
</script>
</html>