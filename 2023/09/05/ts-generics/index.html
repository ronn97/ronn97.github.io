<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--  bing搜索-->
  <meta name="msvalidate.01" content="C978CEE5B035402910AAC2FD1C19716D" />
  
  
  
  <meta name="description" content="个人博客">
  
  <title>
    TypeScript 泛型 |
    
    没有梦想的程序员
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>


  
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4620209531301821" crossorigin="anonymous"></script>
  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="没有梦想的程序员" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-ts-generics" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    TypeScript 泛型
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-generics/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有些时候，函数返回值的类型与参数类型是相关的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFirst</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>getFirst()</code>总是返回参数数组的第一个成员。参数数组是什么类型，返回值就是什么类型。</p>
<p>这个函数的类型声明只能写成下面这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的类型声明，就反映不出参数与返回值之间的类型关系。</p>
<p>为了解决这个问题，TypeScript 就引入了“泛型”（generics）。泛型的特点就是带有“类型参数”（type parameter）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getFirst&lt;T&gt;(<span class="attr">arr</span>:T[]):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>getFirst()</code>的函数名后面尖括号的部分<code>&lt;T&gt;</code>，就是类型参数，参数要放在一对尖括号（<code>&lt;&gt;</code>）里面。本例只有一个类型参数<code>T</code>，可以将其理解为类型声明需要的变量，需要在调用时传入具体的参数类型。</p>
<p>上例的函数<code>getFirst()</code>的参数类型是<code>T[]</code>，返回值类型是<code>T</code>，就清楚地表示了两者之间的关系。比如，输入的参数类型是<code>number[]</code>，那么 T 的值就是<code>number</code>，因此返回值类型也是<code>number</code>。</p>
<p>函数调用时，需要提供类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getFirst&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>上面示例中，调用函数<code>getFirst()</code>时，需要在函数名后面使用尖括号，给出类型参数<code>T</code>的值，本例是<code>&lt;number&gt;</code>。</p>
<p>不过为了方便，函数调用时，往往省略不写类型参数的值，让 TypeScript 自己推断。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getFirst</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>上面示例中，TypeScript 会从实际参数<code>[1, 2, 3]</code>，推断出类型参数 T 的值为<code>number</code>。</p>
<p>有些复杂的使用场景，TypeScript 可能推断不出类型参数的值，这时就必须显式给出了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comb&lt;T&gt;(<span class="attr">arr1</span>:T[], <span class="attr">arr2</span>:T[]):T[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两个参数<code>arr1</code>、<code>arr2</code>和返回值都是同一个类型。如果不给出类型参数的值，下面的调用会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">comb</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例会报错，TypeScript 认为两个参数不是同一个类型。但是，如果类型参数是一个联合类型，就不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comb&lt;<span class="built_in">number</span>|<span class="built_in">string</span>&gt;([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数是一个联合类型，使得两个参数都符合类型参数，就不报错了。这种情况下，类型参数是不能省略不写的。</p>
<p>类型参数的名字，可以随便取，但是必须为合法的标识符。习惯上，类型参数的第一个字符往往采用大写字母。一般会使用<code>T</code>（type 的第一个字母）作为类型参数的名字。如果有多个类型参数，则使用 T 后面的 U、V 等字母命名，各个参数之间使用逗号（“,”）分隔。</p>
<p>下面是多个类型参数的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> map&lt;T, U&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[],</span><br><span class="line">  <span class="attr">f</span>:<span class="function">(<span class="params">arg:T</span>) =&gt;</span> U</span><br><span class="line">):U[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法实例</span></span><br><span class="line">map&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>],</span><br><span class="line">  <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">parseInt</span>(n)</span><br><span class="line">); <span class="comment">// 返回 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面示例将数组的实例方法<code>map()</code>改写成全局函数，它有两个类型参数<code>T</code>和<code>U</code>。含义是，原始数组的类型为<code>T[]</code>，对该数组的每个成员执行一个处理函数<code>f</code>，将类型<code>T</code>转成类型<code>U</code>，那么就会得到一个类型为<code>U[]</code>的数组。</p>
<p>总之，泛型可以理解成一段类型逻辑，需要类型参数来表达。有了类型参数以后，可以在输入类型与输出类型之间，建立一一对应关系。</p>
<h2 id="泛型的写法"><a href="#泛型的写法" class="headerlink" title="泛型的写法"></a>泛型的写法</h2><p>泛型主要用在四个场合：函数、接口、类和别名。</p>
<h3 id="函数的泛型写法"><a href="#函数的泛型写法" class="headerlink" title="函数的泛型写法"></a>函数的泛型写法</h3><p>上一节提到，<code>function</code>关键字定义的泛型函数，类型参数放在尖括号中，写在函数名后面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;T&gt;(<span class="attr">arg</span>:T):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么对于变量形式定义的函数，泛型有下面两种写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:&lt;T&gt;<span class="function">(<span class="params">arg:T</span>) =&gt;</span> T = id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:&#123; &lt;T&gt;(<span class="attr">arg</span>:T): T &#125; = id;</span><br></pre></td></tr></table></figure>

<h3 id="接口的泛型写法"><a href="#接口的泛型写法" class="headerlink" title="接口的泛型写法"></a>接口的泛型写法</h3><p>interface 也可以采用泛型的写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">box</span>:<span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，使用泛型接口时，需要给出类型参数的值（本例是<code>string</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">compareTo</span>(<span class="attr">value</span>:T): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;<span class="title class_">Rectangle</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">compareTo</span>(<span class="attr">value</span>:<span class="title class_">Rectangle</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，先定义了一个泛型接口，然后将这个接口用于一个类。</p>
<p>泛型接口还有第二种写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">  &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>:<span class="title class_">Type</span>): <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>:<span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:<span class="title class_">Fn</span> = id;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Fn</code>的类型参数<code>Type</code>的具体类型，需要函数<code>id</code>在使用时提供。所以，最后一行的赋值语句不需要给出<code>Type</code>的具体类型。</p>
<p>此外，第二种写法还有一个差异之处。那就是它的类型参数定义在某个方法之中，其他属性和方法不能使用该类型参数。前面的第一种写法，类型参数定义在整个接口，接口内部的所有属性和方法都可以使用该类型参数。</p>
<h3 id="类的泛型写法"><a href="#类的泛型写法" class="headerlink" title="类的泛型写法"></a>类的泛型写法</h3><p>泛型类的类型参数写在类名后面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;K, V&gt; &#123;</span><br><span class="line">  <span class="attr">key</span>: K;</span><br><span class="line">  <span class="attr">value</span>: V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是继承泛型类的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>A</code>有一个类型参数<code>T</code>，使用时必须给出<code>T</code>的类型，所以类<code>B</code>继承时要写成<code>A&lt;any&gt;</code>。</p>
<p>泛型也可以用在类表达式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Container</span> = <span class="keyword">class</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> data:T</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，新建实例时，需要同时给出类型参数<code>T</code>和类参数<code>data</code>的值。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="title class_">NumType</span>&gt; &#123;</span><br><span class="line">  value!: <span class="title class_">NumType</span>;</span><br><span class="line">  add!: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> C&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">foo.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">foo.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，先新建类<code>C</code>的实例<code>foo</code>，然后再定义实例的<code>value</code>属性和<code>add()</code>方法。类的定义中，属性和方法后面的感叹号是非空断言，告诉 TypeScript 它们都是非空的，后面会赋值。</p>
<p>JavaScript 的类本质上是一个构造函数，因此也可以把泛型类写成构造函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyClass</span>&lt;T&gt; = <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法实例</span></span><br><span class="line"><span class="keyword">function</span> createInstance&lt;T&gt;(</span><br><span class="line">  <span class="title class_">AnyClass</span>: <span class="title class_">MyClass</span>&lt;T&gt;,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">):T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnyClass</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>createInstance()</code>的第一个参数<code>AnyClass</code>是构造函数（也可以是一个类），它的类型是<code>MyClass&lt;T&gt;</code>，这里的<code>T</code>是<code>createInstance()</code>的类型参数，在该函数调用时再指定具体类型。</p>
<p>注意，泛型类描述的是类的实例，不包括静态属性和静态方法，因为这两者定义在类的本身。因此，它们不能引用类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">data</span>: T;  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> value:T</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性<code>data</code>引用了类型参数<code>T</code>，这是不可以的，因为类型参数只能用于实例属性和实例方法，所以报错了。</p>
<h3 id="类型别名的泛型写法"><a href="#类型别名的泛型写法" class="headerlink" title="类型别名的泛型写法"></a>类型别名的泛型写法</h3><p>type 命令定义的类型别名，也可以使用泛型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Nullable</span>&lt;T&gt; = T | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Nullable&lt;T&gt;</code>是一个泛型，只要传入一个类型，就可以得到这个类型与<code>undefined</code>和<code>null</code>的一个联合类型。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="title class_">Container</span>&lt;<span class="built_in">number</span>&gt; = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Container</span>&lt;<span class="built_in">string</span>&gt; = &#123; <span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>下面是定义树形结构的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型别名<code>Tree</code>内部递归引用了<code>Tree</code>自身。</p>
<h2 id="类型参数的默认值"><a href="#类型参数的默认值" class="headerlink" title="类型参数的默认值"></a>类型参数的默认值</h2><p>类型参数可以设置默认值。使用时，如果没有给出类型参数的值，就会使用默认值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getFirst&lt;T = <span class="built_in">string</span>&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[]</span><br><span class="line">):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>T = string</code>表示类型参数的默认值是<code>string</code>。调用<code>getFirst()</code>时，如果不给出<code>T</code>的值，TypeScript 就认为<code>T</code>等于<code>string</code>。</p>
<p>但是，因为 TypeScript 会从实际参数推断出<code>T</code>的值，从而覆盖掉默认值，所以下面的代码不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getFirst</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，实际参数是<code>[1, 2, 3]</code>，TypeScript 推断 T 等于<code>number</code>，从而覆盖掉默认值<code>string</code>。</p>
<p>类型参数的默认值，往往用在类中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T = <span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="attr">list</span>:T[] = []</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">t:T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类<code>Generic</code>有一个类型参数<code>T</code>，默认值为<code>string</code>。这意味着，属性<code>list</code>默认是一个字符串数组，方法<code>add()</code>的默认参数是一个字符串。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Generic</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">add</span>(<span class="number">4</span>) <span class="comment">// 报错</span></span><br><span class="line">g.<span class="title function_">add</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，新建<code>Generic</code>的实例<code>g</code>时，没有给出类型参数<code>T</code>的值，所以<code>T</code>就等于<code>string</code>。因此，向<code>add()</code>方法传入一个数值会报错，传入字符串就不会。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">add</span>(<span class="number">4</span>) <span class="comment">// 正确</span></span><br><span class="line">g.<span class="title function_">add</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，新建实例<code>g</code>时，给出了类型参数<code>T</code>的值是<code>number</code>，因此<code>add()</code>方法传入数值不会报错，传入字符串会报错。</p>
<p>一旦类型参数有默认值，就表示它是可选参数。如果有多个类型参数，可选参数必须在必选参数之后。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T = <span class="built_in">boolean</span>, U&gt; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">&lt;T, U = <span class="built_in">boolean</span>&gt; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，依次有两个类型参数<code>T</code>和<code>U</code>。如果<code>T</code>是可选参数，<code>U</code>不是，就会报错。</p>
<h2 id="数组的泛型表示"><a href="#数组的泛型表示" class="headerlink" title="数组的泛型表示"></a>数组的泛型表示</h2><p>《数组》一章提到过，数组类型有一种表示方法是<code>Array&lt;T&gt;</code>。这就是泛型的写法，<code>Array</code>是 TypeScript 原生的一个类型接口，<code>T</code>是它的类型参数。声明数组时，需要提供<code>T</code>的值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面的示例中，<code>Array&lt;number&gt;</code>就是一个泛型，类型参数的值是<code>number</code>，表示该数组的全部成员都是数值。</p>
<p>同样的，如果数组成员都是字符串，那么类型就写成<code>Array&lt;string&gt;</code>。事实上，在 TypeScript 内部，数组类型的另一种写法<code>number[]</code>、<code>string[]</code>，只是<code>Array&lt;number&gt;</code>、<code>Array&lt;string&gt;</code>的简写形式。</p>
<p>在 TypeScript 内部，<code>Array</code>是一个泛型接口，类型定义基本是下面的样子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pop</span>(): <span class="title class_">Type</span>|<span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">push</span>(...<span class="attr">items</span>:<span class="title class_">Type</span>[]): <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>push()</code>方法的参数<code>item</code>的类型是<code>Type[]</code>，跟<code>Array()</code>的参数类型<code>Type</code>保持一致，表示只能添加同类型的成员。调用<code>push()</code>的时候，TypeScript 就会检查两者是否一致。</p>
<p>其他的 TypeScript 内部数据结构，比如<code>Map</code>、<code>Set</code>和<code>Promise</code>，其实也是泛型接口，完整的写法是<code>Map&lt;K, V&gt;</code>、<code>Set&lt;T&gt;</code>和<code>Promise&lt;T&gt;</code>。</p>
<p>TypeScript 默认还提供一个<code>ReadonlyArray&lt;T&gt;</code>接口，表示只读数组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params"></span></span><br><span class="line"><span class="params">  values:ReadonlyArray&lt;<span class="built_in">string</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  values.<span class="title function_">push</span>(<span class="string">&#x27;hello!&#x27;</span>);  <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数<code>values</code>的类型是<code>ReadonlyArray&lt;string&gt;</code>，表示不能修改这个数组，所以函数体内部新增数组成员就会报错。因此，如果不希望函数内部改动参数数组，就可以将该参数数组声明为<code>ReadonlyArray&lt;T&gt;</code>类型。</p>
<h2 id="类型参数的约束条件"><a href="#类型参数的约束条件" class="headerlink" title="类型参数的约束条件"></a>类型参数的约束条件</h2><p>很多类型参数并不是无限制的，对于传入的类型存在约束条件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;<span class="title class_">Type</span>&gt;(<span class="attr">a</span>:<span class="title class_">Type</span>, <span class="attr">b</span>:<span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数 Type 有一个隐藏的约束条件：它必须存在<code>length</code>属性。如果不满足这个条件，就会报错。</p>
<p>TypeScript 提供了一种语法，允许在类型参数上面写明约束条件，如果不满足条件，编译时就会报错。这样也可以有良好的语义，对类型参数进行说明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(</span><br><span class="line">  <span class="attr">a</span>: T,</span><br><span class="line">  <span class="attr">b</span>: T</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>T extends &#123; length: number &#125;</code>就是约束条件，表示类型参数 T 必须满足<code>&#123; length: number &#125;</code>，否则就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">comp</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">comp</span>(<span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>) <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">comp</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，只要传入的参数类型不满足约束条件，就会报错。</p>
<p>类型参数的约束条件采用下面的形式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">TypeParameter</span> <span class="keyword">extends</span> <span class="title class_">ConstraintType</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上面语法中，<code>TypeParameter</code>表示类型参数，<code>extends</code>是关键字，这是必须的，<code>ConstraintType</code>表示类型参数要满足的条件，即类型参数应该是<code>ConstraintType</code>的子类型。</p>
<p>类型参数可以同时设置约束条件和默认值，前提是默认值必须满足约束条件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span>&lt;A <span class="keyword">extends</span> <span class="built_in">string</span>, B <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&#x27;world&#x27;</span>&gt;</span><br><span class="line">  =  [A, B];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Fn</span>&lt;<span class="string">&#x27;hello&#x27;</span>&gt; <span class="comment">// [&quot;hello&quot;, &quot;world&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数<code>A</code>和<code>B</code>都有约束条件，并且<code>B</code>还有默认值。所以，调用<code>Fn</code>的时候，可以只给出<code>A</code>的值，不给出<code>B</code>的值。</p>
<p>另外，上例也可以看出，泛型本质上是一个类型函数，通过输入参数，获得结果，两者是一一对应关系。</p>
<p>如果有多个类型参数，一个类型参数的约束条件，可以引用其他参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T, U <span class="keyword">extends</span> T&gt;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">&lt;T <span class="keyword">extends</span> U, U&gt;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>U</code>的约束条件引用<code>T</code>，或者<code>T</code>的约束条件引用<code>U</code>，都是正确的。</p>
<p>但是，约束条件不能引用类型参数自身。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> T&gt;               <span class="comment">// 报错</span></span><br><span class="line">&lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> T&gt;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>T</code>的约束条件不能是<code>T</code>自身。同理，多个类型参数也不能互相约束（即<code>T</code>的约束条件是<code>U</code>、<code>U</code>的约束条件是<code>T</code>），因为互相约束就意味着约束条件就是类型参数自身。</p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>泛型有一些使用注意点。</p>
<p><strong>（1）尽量少用泛型。</strong></p>
<p>泛型虽然灵活，但是会加大代码的复杂性，使其变得难读难写。一般来说，只要使用了泛型，类型声明通常都不太易读，容易写得很复杂。因此，可以不用泛型就不要用。</p>
<p><strong>（2）类型参数越少越好。</strong></p>
<p>多一个类型参数，多一道替换步骤，加大复杂性。因此，类型参数越少越好。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> filter&lt;</span><br><span class="line">  T,</span><br><span class="line">  <span class="title class_">Fn</span> <span class="keyword">extends</span> (<span class="attr">arg</span>:T) =&gt; <span class="built_in">boolean</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[],</span><br><span class="line">  <span class="attr">func</span>:<span class="title class_">Fn</span></span><br><span class="line">): T[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例有两个类型参数，但是第二个类型参数<code>Fn</code>是不必要的，完全可以直接写在函数参数的类型声明里面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> filter&lt;T&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[],</span><br><span class="line">  <span class="attr">func</span>:<span class="function">(<span class="params">arg:T</span>) =&gt;</span> <span class="built_in">boolean</span></span><br><span class="line">): T[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数简化成了一个，效果与前一个示例是一样的。</p>
<p><strong>（3）类型参数需要出现两次。</strong></p>
<p>如果类型参数在定义后只出现一次，那么很可能是不必要的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> greet&lt;<span class="title class_">Str</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(</span><br><span class="line">  <span class="attr">s</span>:<span class="title class_">Str</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型参数<code>Str</code>只在函数声明中出现一次（除了它的定义部分），这往往表明这个类型参数是不必要。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例把前面的类型参数省略了，效果与前一个示例是一样的。</p>
<p>也就是说，只有当类型参数用到两次或两次以上，才是泛型的适用场合。</p>
<p><strong>（4）泛型可以嵌套。</strong></p>
<p>类型参数可以是另一个泛型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span>|<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span>|<span class="title class_">Type</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">OrNull</span>&lt;<span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行的泛型<code>OrNull</code>的类型参数，就是另一个泛型<code>OneOrMany</code>。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-generics/" data-id="clm60yqzv0011ewwl11z10ysk" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2023/09/05/ts-enum/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      TypeScript 的 Enum 类型
      
    </div>
  </a>
  
  
  <a href="/2023/09/05/ts-function/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">TypeScript 的函数类型</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>没有梦想的程序员 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="没有梦想的程序员"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/TS%E6%95%99%E7%A8%8B">TS教程</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
      <li class="nav-item">
        <div id="translate"></div>
      </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

<!--添加多语言翻译效果-->
<script src="https://res.zvo.cn/translate/translate.js"></script>
<script>
  translate.setUseVersion2(); //设置使用v2.x 版本
  translate.language.setLocal('chinese_simplified'); //设置本地语种（当前网页的语种）。如果不设置，默认自动识别当前网页显示文字的语种。 可填写如 'english'、'chinese_simplified' 等，具体参见文档下方关于此的说明。
  translate.execute();//进行翻译
</script>
</html>