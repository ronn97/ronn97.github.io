<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--  bing搜索-->
  <meta name="msvalidate.01" content="C978CEE5B035402910AAC2FD1C19716D" />
  
  
  
  <meta name="description" content="个人博客">
  
  <title>
    TypeScript 的 interface 接口 |
    
    没有梦想的程序员
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>


  
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4620209531301821" crossorigin="anonymous"></script>
  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="没有梦想的程序员" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-ts-interface" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    TypeScript 的 interface 接口
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-interface/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，定义了一个接口<code>Person</code>，它指定一个对象模板，拥有三个属性<code>firstName</code>、<code>lastName</code>和<code>age</code>。任何实现这个接口的对象，都必须部署这三个属性，并且必须符合规定的类型。</p>
<p>实现该接口很简单，只要指定它作为对象的类型即可。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Smith&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>p</code>的类型就是接口<code>Person</code>，所以必须符合<code>Person</code>指定的结构。</p>
<p>方括号运算符可以取出 interface 某个属性的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Foo</span>[<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Foo[&#39;a&#39;]</code>返回属性<code>a</code>的类型，所以类型<code>A</code>就是<code>string</code>。</p>
<p>interface 可以表示对象的各种语法，它的成员有5种形式。</p>
<ul>
<li>对象属性</li>
<li>对象的属性索引</li>
<li>对象方法</li>
<li>函数</li>
<li>构造函数</li>
</ul>
<p>（1）对象属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>和<code>y</code>都是对象的属性，分别使用冒号指定每个属性的类型。</p>
<p>属性之间使用分号或逗号分隔，最后一个属性结尾的分号或逗号可以省略。</p>
<p>如果属性是可选的，就在属性名后面加一个问号。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  x?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果属性是只读的，需要加上<code>readonly</code>修饰符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象的属性索引</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[prop: string]</code>就是属性的字符串索引，表示属性名只要是字符串，都符合类型要求。</p>
<p>属性索引共有<code>string</code>、<code>number</code>和<code>symbol</code>三种类型。</p>
<p>一个接口中，最多只能定义一个字符串索引。字符串索引会约束该类型中所有名字为字符串的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">boolean</span>;      <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性索引指定所有名称为字符串的属性，它们的属性值必须是数值（<code>number</code>）。属性<code>a</code>的值为布尔值就报错了。</p>
<p>属性的数值索引，其实是指定数组的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:A = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>[prop: number]</code>表示属性名的类型是数值，所以可以用数组对变量<code>obj</code>赋值。</p>
<p>同样的，一个接口中最多只能定义一个数值索引。数值索引会约束所有名称为数值的属性。</p>
<p>如果一个 interface 同时定义了字符串索引和数值索引，那么数值索引必须服从于字符串索引。因为在 JavaScript 中，数值属性名最终是自动转换成字符串属性名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数值索引的属性值类型与字符串索引不一致，就会报错。数值索引必须兼容字符串索引的类型声明。</p>
<p>（3）对象的方法</p>
<p>对象的方法共有三种写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">f</span>: <span class="function">(<span class="params">x: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">  <span class="attr">f</span>: &#123; (<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性名可以采用表达式，所以下面的写法也是可以的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [f](<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型方法可以重载。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 里面的函数重载，不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params"></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params">x: <span class="built_in">boolean</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x?:<span class="built_in">boolean</span>|<span class="built_in">string</span>, y?:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">number</span>|<span class="built_in">boolean</span>|<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">undefined</span> &amp;&amp; y === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;boolean&#x27;</span> &amp;&amp; y === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong parameters&#x27;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = &#123;</span><br><span class="line">  <span class="attr">f</span>: <span class="title class_">MyFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>A</code>的方法<code>f()</code>有函数重载，需要额外定义一个函数<code>MyFunc()</code>实现这个重载，然后部署接口<code>A</code>的对象<code>a</code>的属性<code>f</code>等于函数<code>MyFunc()</code>就可以了。</p>
<p>（4）函数</p>
<p>interface 也可以用来声明独立的函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">  (<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>:<span class="title class_">Add</span> = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>Add</code>声明了一个函数类型。</p>
<p>（5）构造函数</p>
<p>interface 内部可以使用<code>new</code>关键字，表示构造函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ErrorConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (message?: <span class="built_in">string</span>): <span class="title class_">Error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>ErrorConstructor</code>内部有<code>new</code>命令，表示它是一个构造函数。</p>
<p>TypeScript 里面，构造函数特指具有<code>constructor</code>属性的类，详见《Class》一章。</p>
<h2 id="interface-的继承"><a href="#interface-的继承" class="headerlink" title="interface 的继承"></a>interface 的继承</h2><p>interface 可以继承其他类型，主要有下面几种情况。</p>
<h3 id="interface-继承-interface"><a href="#interface-继承-interface" class="headerlink" title="interface 继承 interface"></a>interface 继承 interface</h3><p>interface 可以使用<code>extends</code>关键字，继承其他 interface。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Circle</code>继承了<code>Shape</code>，所以<code>Circle</code>其实有两个属性<code>name</code>和<code>radius</code>。这时，<code>Circle</code>是子接口，<code>Shape</code>是父接口。</p>
<p><code>extends</code>关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性。</p>
<p>interface 允许多重继承。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Style</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Style</span>, <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Circle</code>同时继承了<code>Style</code>和<code>Shape</code>，所以拥有三个属性<code>color</code>、<code>name</code>和<code>radius</code>。</p>
<p>多重接口继承，实际上相当于多个父接口的合并。</p>
<p>如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。注意，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Bar</code>继承了<code>Foo</code>，但是两者的同名属性<code>id</code>的类型不兼容，导致报错。</p>
<p>多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_">Foo</span>, <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Baz</code>同时继承了<code>Foo</code>和<code>Bar</code>，但是后两者的同名属性<code>id</code>有类型冲突，导致报错。</p>
<h3 id="interface-继承-type"><a href="#interface-继承-type" class="headerlink" title="interface 继承 type"></a>interface 继承 type</h3><p>interface 可以继承<code>type</code>命令定义的对象类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CountryWithPop</span> <span class="keyword">extends</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  <span class="attr">population</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>CountryWithPop</code>继承了<code>type</code>命令定义的<code>Country</code>对象，并且新增了一个<code>population</code>属性。</p>
<p>注意，如果<code>type</code>命令定义的类型不是对象，interface 就无法继承。</p>
<h3 id="interface-继承-class"><a href="#interface-继承-class" class="headerlink" title="interface 继承 class"></a>interface 继承 class</h3><p>interface 还可以继承 class，即继承该类的所有成员。关于 class 的详细解释，参见下一章。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">y</span>():<span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>B</code>继承了<code>A</code>，因此<code>B</code>就具有属性<code>x</code>、<code>y()</code>和<code>z</code>。</p>
<p>实现<code>B</code>接口的对象就需要实现这些属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:B = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，对象<code>b</code>就实现了接口<code>B</code>，而接口<code>B</code>又继承了类<code>A</code>。</p>
<p>某些类拥有私有成员和保护成员，interface 可以继承这样的类，但是意义不大。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">y</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:B = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> B &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>A</code>有私有成员和保护成员，<code>B</code>继承了<code>A</code>，但无法用于对象，因为对象不能实现这些成员。这导致<code>B</code>只能用于其他 class，而这时其他 class 与<code>A</code>之间不构成父类和子类的关系，使得<code>x</code>与<code>y</code>无法部署。</p>
<h2 id="接口合并"><a href="#接口合并" class="headerlink" title="接口合并"></a>接口合并</h2><p>多个同名接口会合并成一个接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两个<code>Box</code>接口会合并成一个接口，同时有<code>height</code>、<code>width</code>和<code>length</code>三个属性。</p>
<p>这样的设计主要是为了兼容 JavaScript 的行为。JavaScript 开发者常常对全局对象或者外部库，添加自己的属性和方法。那么，只要使用 interface 给出这些自定义属性和方法的类型，就能自动跟原始的 interface 合并，使得扩展外部类型非常方便。</p>
<p>举例来说，Web 网页开发经常会对<code>windows</code>对象和<code>document</code>对象添加自定义属性，但是 TypeScript 会报错，因为原始定义没有这些属性。解决方法就是把自定义属性写成 interface，合并进原始定义。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>Document</code>增加了一个自定义属性<code>foo</code>，从而就可以在<code>document</code>对象上使用自定义属性。</p>
<p>同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>A</code>的属性<code>a</code>有两个类型声明，彼此是冲突的，导致报错。</p>
<p>同名接口合并时，如果同名方法有不同的类型声明，那么会发生函数重载。而且，后面的定义比前面的定义具有更高的优先级。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Animal</span>): <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Sheep</span>): <span class="title class_">Sheep</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Dog</span>): <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Cat</span>): <span class="title class_">Cat</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Dog</span>): <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Cat</span>): <span class="title class_">Cat</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Sheep</span>): <span class="title class_">Sheep</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Animal</span>): <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>clone()</code>方法有不同的类型声明，会发生函数重载。这时，越靠后的定义，优先级越高，排在函数重载的越前面。比如，<code>clone(animal: Animal)</code>是最先出现的类型声明，就排在函数重载的最后，属于<code>clone()</code>函数最后匹配的类型。</p>
<p>这个规则有一个例外。同名方法之中，如果有一个参数是字面量类型，字面量类型有更高的优先级。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="string">&#x27;foo&#x27;</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="string">&#x27;foo&#x27;</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>f()</code>方法有一个类型声明的参数<code>x</code>是字面量类型，这个类型声明的优先级最高，会排在函数重载的最前面。</p>
<p>一个实际的例子是 Document 对象的<code>createElement()</code>方法，它会根据参数的不同，而生成不同的 HTML 节点对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">any</span>): <span class="title class_">Element</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;div&quot;</span>): <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;span&quot;</span>): <span class="title class_">HTMLSpanElement</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;canvas&quot;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;canvas&quot;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;div&quot;</span>): <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;span&quot;</span>): <span class="title class_">HTMLSpanElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">any</span>): <span class="title class_">Element</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>createElement()</code>方法的函数重载，参数为字面量的类型声明会排到最前面，返回具体的 HTML 节点对象。类型越不具体的参数，排在越后面，返回通用的 HTML 节点对象。</p>
<p>如果两个 interface 组成的联合类型存在同名属性，那么该属性的类型也是联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">area</span>: <span class="built_in">bigint</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="attr">area</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">s</span>: <span class="title class_">Circle</span> | <span class="title class_">Rectangle</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="property">area</span>;   <span class="comment">// bigint | number</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，接口<code>Circle</code>和<code>Rectangle</code>组成一个联合类型<code>Circle | Rectangle</code>。因此，这个联合类型的同名属性<code>area</code>，也是一个联合类型。本例中的<code>declare</code>命令表示变量<code>s</code>的具体定义，由其他脚本文件给出，详见《declare 命令》一章。</p>
<h2 id="interface-与-type-的异同"><a href="#interface-与-type-的异同" class="headerlink" title="interface 与 type 的异同"></a>interface 与 type 的异同</h2><p><code>interface</code>命令与<code>type</code>命令作用类似，都可以表示对象类型。</p>
<p>很多对象类型既可以用 interface 表示，也可以用 type 表示。而且，两者往往可以换用，几乎所有的 interface 命令都可以改写为 type 命令。</p>
<p>它们的相似之处，首先表现在都能为对象类型起名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coutry</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是<code>type</code>命令和<code>interface</code>命令，分别定义同一个类型。</p>
<p><code>class</code>命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用<code>type</code>或<code>interface</code>。</p>
<p>interface 与 type 的区别有下面几点。</p>
<p>（1）<code>type</code>能够表示非对象类型，而<code>interface</code>只能表示对象类型（包括数组、函数等）。</p>
<p>（2）<code>interface</code>可以继承其他类型，<code>type</code>不支持继承。</p>
<p>继承的主要作用是添加属性，<code>type</code>定义的对象类型如果想要添加属性，只能使用<code>&amp;</code>运算符，重新定义一个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bear</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>Bear</code>在<code>Animal</code>的基础上添加了一个属性<code>honey</code>。</p>
<p>上例的<code>&amp;</code>运算符，表示同时具备两个类型的特征，因此可以起到两个对象类型合并的作用。</p>
<p>作为比较，<code>interface</code>添加属性，采用的是继承的写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bear</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承时，type 和 interface 是可以换用的。interface 可以继承 type。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type 也可以继承 interface。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Foo</span> &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>（3）同名<code>interface</code>会自动合并，同名<code>type</code>则会报错。也就是说，TypeScript 不允许使用<code>type</code>多次定义同一个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">foo</span>:<span class="built_in">number</span> &#125;; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">bar</span>:<span class="built_in">number</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>type</code>两次定义了类型<code>A</code>，导致两行都会报错。</p>
<p>作为比较，<code>interface</code>则会自动合并。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">foo</span>:<span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">bar</span>:<span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>interface</code>把类型<code>A</code>的两个定义合并在一起。</p>
<p>这表明，interface 是开放的，可以添加属性，type 是封闭的，不能添加属性，只能定义新的 type。</p>
<p>（4）<code>interface</code>不能包含属性映射（mapping），<code>type</code>可以，详见《映射》一章。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PointCopy1</span> = &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> keyof <span class="title class_">Point</span>]: <span class="title class_">Point</span>[<span class="title class_">Key</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PointCopy2</span> &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> keyof <span class="title class_">Point</span>]: <span class="title class_">Point</span>[<span class="title class_">Key</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（5）<code>this</code>关键字只能用于<code>interface</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">num</span>:<span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">num</span>:<span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，type 命令声明的方法<code>add()</code>，返回<code>this</code>就报错了。interface 命令没有这个问题。</p>
<p>下面是返回<code>this</code>的实际对象的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">num:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> += num;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）type 可以扩展原始数据类型，interface 不行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyStr</span> = <span class="built_in">string</span> &amp; &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;new&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyStr</span> <span class="keyword">extends</span> <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;new&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，type 可以扩展原始数据类型 string，interface 就不行。</p>
<p>（7）<code>interface</code>无法表达某些复杂类型（比如交叉类型和联合类型），但是<code>type</code>可以。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AorB</span> = A | B;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AorBwithName</span> = <span class="title class_">AorB</span> &amp; &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型<code>AorB</code>是一个联合类型，<code>AorBwithName</code>则是为<code>AorB</code>添加一个属性。这两种运算，<code>interface</code>都没法表达。</p>
<p>综上所述，如果有复杂的类型运算，那么没有其他选择只能使用<code>type</code>；一般情况下，<code>interface</code>灵活性比较高，便于扩充类型或自动合并，建议优先使用。</p>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-interface/" data-id="clm60yqzx0017ewwl24g3gi5m" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2023/09/05/ts-function/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      TypeScript 的函数类型
      
    </div>
  </a>
  
  
  <a href="/2023/09/05/ts-mapping/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">TypeScript 的类型映射</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>没有梦想的程序员 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="没有梦想的程序员"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/TS%E6%95%99%E7%A8%8B">TS教程</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
      <li class="nav-item">
        <div id="translate"></div>
      </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

<!--添加多语言翻译效果-->
<script src="https://res.zvo.cn/translate/translate.js"></script>
<script>
  translate.setUseVersion2(); //设置使用v2.x 版本
  translate.language.setLocal('chinese_simplified'); //设置本地语种（当前网页的语种）。如果不设置，默认自动识别当前网页显示文字的语种。 可填写如 'english'、'chinese_simplified' 等，具体参见文档下方关于此的说明。
  translate.execute();//进行翻译
</script>
</html>