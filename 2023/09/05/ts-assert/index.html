<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!--  bing搜索-->
  <meta name="msvalidate.01" content="C978CEE5B035402910AAC2FD1C19716D" />
  
  
  
  <meta name="description" content="个人博客">
  
  <title>
    TypeScript 的类型断言 |
    
    没有梦想的程序员
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>


  
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4620209531301821" crossorigin="anonymous"></script>
  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="没有梦想的程序员" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-ts-assert" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    TypeScript 的类型断言
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/09/05/ts-assert/" class="article-date">
  <time datetime="2023-09-05T02:50:55.000Z" itemprop="datePublished">2023-09-05</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/TS%E6%95%99%E7%A8%8B/">TS教程</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <div id="readmore-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于没有类型声明的值，TypeScript 会进行类型推断，很多时候得到的结果，未必是开发者想要的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错，原因是 TypeScript 推断变量<code>foo</code>的类型是<code>string</code>，而变量<code>bar</code>的类型是<code>&#39;a&#39;|&#39;b&#39;|&#39;c&#39;</code>，前者是后者的父类型。父类型不能赋值给子类型，所以就报错了。</p>
<p>TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。</p>
<p>这种做法的实质是，允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。</p>
<p>回到上面的例子，解决方法就是进行类型断言，在赋值时断言变量<code>foo</code>的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo <span class="keyword">as</span> T; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行的<code>foo as T</code>表示告诉编译器，变量<code>foo</code>的类型断言为<code>T</code>，所以这一行不再需要类型推断了，编译器直接把<code>foo</code>的类型当作<code>T</code>，就不会报错了。</p>
<p>总之，类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。</p>
<p>类型断言有两种语法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法一：&lt;类型&gt;值</span></span><br><span class="line">&lt;<span class="title class_">Type</span>&gt;value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法二：值 as 类型</span></span><br><span class="line">value <span class="keyword">as</span> <span class="title class_">Type</span></span><br></pre></td></tr></table></figure>

<p>上面两种语法是等价的，<code>value</code>表示值，<code>Type</code>表示类型。早期只有语法一，后来因为 TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突，就引入了语法二。目前，推荐使用语法二。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = &lt;T&gt;foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法二</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo <span class="keyword">as</span> T;</span><br></pre></td></tr></table></figure>

<p>上面示例是两种类型断言的语法，其中的语法一因为跟 JSX 语法冲突，使用时必须关闭 TypeScript 的 React 支持，否则会无法识别。由于这个原因，现在一般都使用语法二。</p>
<p>下面看一个例子。《对象》一章提到过，对象类型有严格字面量检查，如果存在额外的属性会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，等号右侧是一个对象字面量，多出了属性<code>y</code>，导致报错。解决方法就是使用类型断言，可以用两种不同的断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p0</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; =</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; =</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种类型断言都是正确的。第一种断言将类型改成与等号左边一致，第二种断言使得等号右边的类型是左边类型的子类型，子类型可以赋值给父类型，同时因为存在类型断言，就没有严格字面量检查了，所以不报错。</p>
<p>下面是一个网页编程的实际例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username) &#123;</span><br><span class="line">  (username <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>).<span class="property">value</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>username</code>的类型是<code>HTMLElement | null</code>，排除了<code>null</code>的情况以后，HTMLElement 类型是没有<code>value</code>属性的。如果<code>username</code>是一个输入框，那么就可以通过类型断言，将它的类型改成<code>HTMLInputElement</code>，就可以读取<code>value</code>属性。</p>
<p>注意，上例的类型断言的圆括号是必需的，否则<code>username</code>会被断言成<code>HTMLInputElement.value</code>，从而报错。</p>
<p>类型断言不应滥用，因为它改变了 TypeScript 的类型检查，很可能埋下错误的隐患。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">data</span>:<span class="built_in">object</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">data.<span class="property">length</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">(data <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;).<span class="property">length</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>data</code>是一个对象，没有<code>length</code>属性。但是通过类型断言，可以将它的类型断言为数组，这样使用<code>length</code>属性就能通过类型检查。但是，编译后的代码在运行时依然会报错，所以类型断言可以让错误的代码通过编译。</p>
<p>类型断言的一大用处是，指定 unknown 类型的变量的具体类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">value</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="built_in">string</span> = value; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="built_in">string</span> = value <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，unknown 类型的变量<code>value</code>不能直接赋值给其他类型的变量，但是可以将它断言为其他类型，这样就可以赋值给别的变量了。</p>
<p>另外，类型断言也适合指定联合类型的值的具体类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="built_in">number</span>|<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="built_in">number</span> = s1 <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s1</code>是联合类型，可以断言其为联合类型里面的一种具体类型，再将其赋值给变量<code>s2</code>。</p>
<h2 id="类型断言的条件"><a href="#类型断言的条件" class="headerlink" title="类型断言的条件"></a>类型断言的条件</h2><p>类型断言并不意味着，可以把某个值断言为任意类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>n</code>是数值，无法把它断言成字符串，TypeScript 会报错。</p>
<p>类型断言的使用前提是，值的实际类型与断言的类型必须满足一个条件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr <span class="keyword">as</span> T</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>expr</code>是实际的值，<code>T</code>是类型断言，它们必须满足下面的条件：<code>expr</code>是<code>T</code>的子类型，或者<code>T</code>是<code>expr</code>的子类型。</p>
<p>也就是说，类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。</p>
<p>但是，如果真的要断言成一个完全无关的类型，也是可以做到的。那就是连续进行两次类型断言，先断言成 unknown 类型或 any 类型，然后再断言为目标类型。因为<code>any</code>类型和<code>unknown</code>类型是所有其他类型的父类型，所以可以作为两种完全无关的类型的中介。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者写成 &lt;T&gt;&lt;unknown&gt;expr</span></span><br><span class="line">expr <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> T</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>expr</code>连续进行了两次类型断言，第一次断言为<code>unknown</code>类型，第二次断言为<code>T</code>类型。这样的话，<code>expr</code>就可以断言成任意类型<code>T</code>，而不报错。</p>
<p>下面是本小节开头那个例子的改写。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，通过两次类型断言，变量<code>n</code>的类型就从数值，变成了完全无关的字符串，从而赋值时不会报错。</p>
<h2 id="as-const-断言"><a href="#as-const-断言" class="headerlink" title="as const 断言"></a>as const 断言</h2><p>如果没有声明变量类型，let 命令声明的变量，会被类型推断为 TypeScript 内置的基本类型之一；const 命令声明的变量，则被推断为值类型常量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型推断为基本类型 string</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断为字符串 “JavaScript”</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s1</code>的类型被推断为<code>string</code>，变量<code>s2</code>的类型推断为值类型<code>JavaScript</code>。后者是前者的子类型，相当于 const 命令有更强的限定作用，可以缩小变量的类型范围。</p>
<p>有些时候，let 变量会出现一些意想不到的报错，变更成 const 变量就能消除报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> =</span><br><span class="line">  |<span class="string">&#x27;JavaScript&#x27;</span></span><br><span class="line">  |<span class="string">&#x27;TypeScript&#x27;</span></span><br><span class="line">  |<span class="string">&#x27;Python&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setLang</span>(<span class="params">language:Lang</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setLang</span>(s); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错，原因是函数<code>setLang()</code>的参数<code>language</code>类型是<code>Lang</code>，这是一个联合类型。但是，传入的字符串<code>s</code>的类型被推断为<code>string</code>，属于<code>Lang</code>的父类型。父类型不能替代子类型，导致报错。</p>
<p>一种解决方法就是把 let 命令改成 const 命令。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这样的话，变量<code>s</code>的类型就是值类型<code>JavaScript</code>，它是联合类型<code>Lang</code>的子类型，传入函数<code>setLang()</code>就不会报错。</p>
<p>另一种解决方法是使用类型断言。TypeScript 提供了一种特殊的类型断言<code>as const</code>，用于告诉编译器，推断类型时，可以将这个值推断为常量，即把 let 变量断言为 const 变量，从而把内置的基本类型变更为值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="title function_">setLang</span>(s);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>s</code>虽然是用 let 命令声明的，但是使用了<code>as const</code>断言以后，就等同于是用 const 命令声明的，变量<code>s</code>的类型会被推断为值类型<code>JavaScript</code>。</p>
<p>使用了<code>as const</code>断言以后，let 变量就不能再改变值了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">s = <span class="string">&#x27;Python&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，let 命令声明的变量<code>s</code>，使用<code>as const</code>断言以后，就不能改变值了，否则报错。</p>
<p>注意，<code>as const</code>断言只能用于字面量，不能用于变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="title function_">setLang</span>(s <span class="keyword">as</span> <span class="keyword">const</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>as const</code>断言用于变量<code>s</code>，就报错了。下面的写法可以更清晰地看出这一点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1 <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>as const</code>也不能用于表达式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = (<span class="string">&#x27;Java&#x27;</span> + <span class="string">&#x27;Script&#x27;</span>) <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>as const</code>用于表达式，导致报错。</p>
<p><code>as const</code>也可以写成前置的形式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置形式</span></span><br><span class="line">expr <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置形式</span></span><br><span class="line">&lt;<span class="keyword">const</span>&gt;expr</span><br></pre></td></tr></table></figure>

<p><code>as const</code>断言可以用于整个对象，也可以用于对象的单个属性，这时它的类型缩小效果是不一样的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: number; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: 1; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型是 &#123; readonly x: 1; readonly y: 2; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第二种写法是对属性<code>x</code>缩小类型，第三种写法是对整个对象缩小类型。</p>
<p>总之，<code>as const</code>会将字面量的类型断言为不可变类型，缩小成 TypeScript 允许的最小类型。</p>
<p>下面是数组的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 的类型推断为 number[]</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a2 的类型推断为 readonly [1, 2, 3]</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组字面量使用<code>as const</code>断言后，类型推断就变成了只读元组。</p>
<p>由于<code>as const</code>会将数组变成只读元组，所以很适合用于函数的 rest 参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>nums</code>的类型推断为<code>number[]</code>，导致使用扩展运算符<code>...</code>传入函数<code>add()</code>会报错，因为<code>add()</code>只能接受两个参数，而<code>...nums</code>并不能保证参数的个数。</p>
<p>事实上，对于固定参数个数的函数，如果传入的参数包含扩展运算符，那么扩展运算符只能用于元组。只有当函数定义使用了 rest 参数，扩展运算符才能用于数组。</p>
<p>解决方法就是使用<code>as const</code>断言，将数组变成元组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，使用<code>as const</code>断言后，变量<code>nums</code>的类型会被推断为<code>readonly [1, 2]</code>，使用扩展运算符展开后，正好符合函数<code>add()</code>的参数类型。</p>
<p>Enum 成员也可以使用<code>as const</code>断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  X,</span><br><span class="line">  Y,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> e1 = <span class="title class_">Foo</span>.<span class="property">X</span>;            <span class="comment">// Foo</span></span><br><span class="line"><span class="keyword">let</span> e2 = <span class="title class_">Foo</span>.<span class="property">X</span> <span class="keyword">as</span> <span class="keyword">const</span>;   <span class="comment">// Foo.X</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，如果不使用<code>as const</code>断言，变量<code>e1</code>的类型被推断为整个 Enum 类型；使用了<code>as const</code>断言以后，变量<code>e2</code>的类型被推断为 Enum 的某个成员，这意味着它不能变更为其他成员。</p>
<h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><p>对于那些可能为空的变量（即可能等于<code>undefined</code>或<code>null</code>），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号<code>!</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?:<span class="built_in">number</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="title function_">validateNumber</span>(x); <span class="comment">// 自定义函数，确保 x 是数值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x!.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateNumber</span>(<span class="params">e?:<span class="built_in">number</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> e !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>的参数<code>x</code>的类型是<code>number|null</code>，即可能为空。如果为空，就不存在<code>x.toFixed()</code>方法，这样写会报错。但是，开发者可以确认，经过<code>validateNumber()</code>的前置检验，变量<code>x</code>肯定不会为空，这时就可以使用非空断言，为函数体内部的变量<code>x</code>加上后缀<code>!</code>，<code>x!.toFixed()</code>编译就不会报错了。</p>
<p>非空断言在实际编程中很有用，有时可以省去一些额外的判断。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getElementById()</code>有可能返回空值<code>null</code>，即变量<code>root</code>可能为空，这时对它调用<code>addEventListener()</code>方法就会报错，通不过编译。但是，开发者如果可以确认<code>root</code>元素肯定会在网页中存在，这时就可以使用非空断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getElementById()</code>方法加上后缀<code>!</code>，表示这个方法肯定返回非空结果。</p>
<p>不过，非空断言会造成安全隐患，只有在确定一个表达式的值不为空时才能使用。比较保险的做法还是手动检查一下是否为空。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unable to find DOM element #root&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果<code>root</code>为空会抛错，比非空断言更保险一点。</p>
<p>非空断言还可以用于赋值断言。TypeScript 有一个编译设置，要求类的属性必须初始化（即有初始值），如果不对属性赋值就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性<code>x</code>和<code>y</code>会报错，因为 TypeScript 认为它们没有初始化。</p>
<p>这时就可以使用非空断言，表示这两个属性肯定会有值，这样就不会报错了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!:<span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line">  y!:<span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，非空断言只有在打开编译选项<code>strictNullChecks</code>时才有意义。如果不打开这个选项，编译器就不会检查某个变量是否可能为<code>undefined</code>或<code>null</code>。</p>
<h2 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h2><p>断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isString()</code>就是一个断言函数，用来保证参数<code>value</code>是一个字符串，否则就会抛出错误，中断程序的执行。</p>
<p>下面是它的用法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toUpper</span>(<span class="params">x: <span class="built_in">string</span>|<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="title function_">isString</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>toUpper()</code>的参数<code>x</code>，可能是字符串，也可能是数值。但是，函数体的最后一行调用<code>toUpperCase()</code>方法，必须保证<code>x</code>是字符串，否则报错。所以，这一行前面调用断言函数<code>isString()</code>，调用以后 TypeScript 就能确定，变量<code>x</code>一定是字符串，不是数值，也就不报错了。</p>
<p>传统的断言函数<code>isString()</code>的写法有一个缺点，它的参数类型是<code>unknown</code>，返回值类型是<code>void</code>（即没有返回值）。单单从这样的类型声明，很难看出<code>isString()</code>是一个断言函数。</p>
<p>为了更清晰地表达断言函数，TypeScript 3.7 引入了新的类型写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>isString()</code>的返回值类型写成<code>asserts value is string</code>，其中<code>asserts</code>和<code>is</code>都是关键词，<code>value</code>是函数的参数名，<code>string</code>是函数参数的预期类型。它的意思是，该函数用来断言参数<code>value</code>的类型是<code>string</code>，如果达不到要求，程序就会在这里中断。</p>
<p>使用了断言函数的新写法以后，TypeScript 就会自动识别，只要执行了该函数，对应的变量都为断言的类型。</p>
<p>注意，函数返回值的断言写法，只是用来更清晰地表达函数意图，真正的检查是需要开发者自己部署的。而且，如果内部的检查与断言不一致，TypeScript 也不会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数的断言是参数<code>value</code>类型为字符串，但是实际上，内部检查的却是它是否为数值，如果不是就抛错。这段代码能够正常通过编译，表示 TypeScript 并不会检查断言与实际的类型检查是否一致。</p>
<p>另外，断言函数的<code>asserts</code>语句等同于<code>void</code>类型，所以如果返回除了<code>undefined</code>和<code>null</code>以外的值，都会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，断言函数返回了<code>true</code>，导致报错。</p>
<p>下面是另一个例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AccessLevel</span> = <span class="string">&#x27;r&#x27;</span> | <span class="string">&#x27;w&#x27;</span> | <span class="string">&#x27;rw&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">allowsReadAccess</span>(<span class="params"></span></span><br><span class="line"><span class="params">  level:AccessLevel</span></span><br><span class="line"><span class="params"></span>):asserts level is <span class="string">&#x27;r&#x27;</span> | <span class="string">&#x27;rw&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!level.<span class="title function_">includes</span>(<span class="string">&#x27;r&#x27;</span>))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Read not allowed&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>allowsReadAccess()</code>用来断言参数<code>level</code>一定等于<code>r</code>或<code>rw</code>。</p>
<p>如果要断言参数非空，可以使用工具类型<code>NonNullable&lt;T&gt;</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> assertIsDefined&lt;T&gt;(</span><br><span class="line">  <span class="attr">value</span>:T</span><br><span class="line">):asserts value is <span class="title class_">NonNullable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span> || value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not defined`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，工具类型<code>NonNullable&lt;T&gt;</code>对应类型<code>T</code>去除空类型后的剩余类型。</p>
<p>如果要将断言函数用于函数表达式，可以采用下面的写法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> assertIsNumber = (</span><br><span class="line">  <span class="attr">value</span>:<span class="built_in">unknown</span></span><br><span class="line">):asserts value is <span class="built_in">number</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AssertIsNumber</span> =</span><br><span class="line">  <span class="function">(<span class="params">value:<span class="built_in">unknown</span></span>) =&gt;</span> asserts value is <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">assertIsNumber</span>:<span class="title class_">AssertIsNumber</span> = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，断言函数与类型保护函数（type guard）是两种不同的函数。它们的区别是，断言函数不返回值，而类型保护函数总是返回一个布尔值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">unknown</span></span></span><br><span class="line"><span class="params"></span>):value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例就是一个类型保护函数<code>isString()</code>，作用是检查参数<code>value</code>是否为字符串。如果是的，返回<code>true</code>，否则返回<code>false</code>。该函数的返回值类型是<code>value is string</code>，其中的<code>is</code>是一个类型运算符，如果左侧的值符合右侧的类型，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p>如果要断言某个参数保证为真（即不等于<code>false</code>、<code>undefined</code>和<code>null</code>），TypeScript 提供了断言函数的一种简写形式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">x:<span class="built_in">unknown</span></span>):asserts x &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>assert()</code>的断言部分，<code>asserts x</code>省略了谓语和宾语，表示参数<code>x</code>保证为真（<code>true</code>）。</p>
<p>同样的，参数为真的实际检查需要开发者自己实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">x:<span class="built_in">unknown</span></span>):asserts x &#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;x&#125;</span> should be a truthy value.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种断言函数的简写形式，通常用来检查某个操作是否成功。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  email?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadPerson</span>(<span class="params"></span>): <span class="title class_">Person</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">loadPerson</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params"></span></span><br><span class="line"><span class="params">  condition: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  message: <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):asserts condition &#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Person is not defined</span></span><br><span class="line"><span class="title function_">assert</span>(person, <span class="string">&#x27;Person is not defined&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，只有<code>loadPerson()</code>返回结果为真（即操作成功），<code>assert()</code>才不会报错。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mariusschulz.com/blog/const-assertions-in-literal-expressions-in-typescript">Const Assertions in Literal Expressions in TypeScript</a>, Marius Schulz</li>
<li><a target="_blank" rel="noopener" href="https://mariusschulz.com/blog/assertion-functions-in-typescript">Assertion Functions in TypeScript</a>, Marius Schulz</li>
<li><a target="_blank" rel="noopener" href="https://blog.logrocket.com/assertion-functions-typescript/">Assertion functions in TypeScript</a>, Matteo Di Pirro</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "没有梦想的程序员",
							"blogId": "27935-0924879545953-871",
							"qrcode": "https://ronn97.github.io/images/static/qrcode.jpg",
							"keyword": "code",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/ts-assert/" data-id="clm60yqzi000cewwl8582524q" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2023/09/05/ts-basic/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      TypeScript 基本用法
      
    </div>
  </a>
  
  
  <a href="/2023/09/05/ts-class/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">TypeScript 的 class 类型</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>没有梦想的程序员 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="没有梦想的程序员"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/TS%E6%95%99%E7%A8%8B">TS教程</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
      <li class="nav-item">
        <div id="translate"></div>
      </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

<!--添加多语言翻译效果-->
<script src="https://res.zvo.cn/translate/translate.js"></script>
<script>
  translate.setUseVersion2(); //设置使用v2.x 版本
  translate.language.setLocal('chinese_simplified'); //设置本地语种（当前网页的语种）。如果不设置，默认自动识别当前网页显示文字的语种。 可填写如 'english'、'chinese_simplified' 等，具体参见文档下方关于此的说明。
  translate.execute();//进行翻译
</script>
</html>